shadow$provide.module$node_modules$katex$dist$katex = function(global, require, module, exports) {
  (function(root, factory) {
    "object" === typeof exports && "object" === typeof module ? module.exports = factory() : "function" === typeof define && define.amd ? define([], factory) : "object" === typeof exports ? exports.katex = factory() : root.katex = factory();
  })("undefined" !== typeof self ? self : this, function() {
    return function() {
      function getDefaultValue(schema) {
        if (schema.default) {
          return schema.default;
        }
        schema = schema.type;
        schema = Array.isArray(schema) ? schema[0] : schema;
        if ("string" !== typeof schema) {
          return schema.enum[0];
        }
        switch(schema) {
          case "boolean":
            return !1;
          case "string":
            return "";
          case "number":
            return 0;
          case "object":
            return {};
        }
      }
      function supportedCodepoint(codepoint) {
        for (let i = 0; i < allBlocks.length; i += 2) {
          if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
            return !0;
          }
        }
        return !1;
      }
      function getCharacterMetrics(character, font, mode) {
        if (!fontMetricsData[font]) {
          throw Error("Font metrics not found for font: " + font + ".");
        }
        let ch = character.charCodeAt(0), metrics = fontMetricsData[font][ch];
        !metrics && character[0] in extraCharacterMap && (ch = extraCharacterMap[character[0]].charCodeAt(0), metrics = fontMetricsData[font][ch]);
        metrics || "text" !== mode || supportedCodepoint(ch) && (metrics = fontMetricsData[font][77]);
        if (metrics) {
          return {depth:metrics[0], height:metrics[1], italic:metrics[2], skew:metrics[3], width:metrics[4]};
        }
      }
      function assertSymbolDomNode(group) {
        if (group instanceof SymbolNode) {
          return group;
        }
        throw Error("Expected symbolNode but got " + String(group) + ".");
      }
      function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
        symbols[mode][name] = {font, group, replace};
        acceptUnicodeChar && replace && (symbols[mode][replace] = symbols[mode][name]);
      }
      function defineFunction(_ref) {
        let {type, names, props, handler, htmlBuilder, mathmlBuilder} = _ref;
        _ref = {type, numArgs:props.numArgs, argTypes:props.argTypes, allowedInArgument:!!props.allowedInArgument, allowedInText:!!props.allowedInText, allowedInMath:void 0 === props.allowedInMath ? !0 : props.allowedInMath, numOptionalArgs:props.numOptionalArgs || 0, infix:!!props.infix, primitive:!!props.primitive, handler};
        for (let i = 0; i < names.length; ++i) {
          _functions[names[i]] = _ref;
        }
        type && (htmlBuilder && (_htmlGroupBuilders[type] = htmlBuilder), mathmlBuilder && (_mathmlGroupBuilders[type] = mathmlBuilder));
      }
      function defineFunctionBuilders(_ref2) {
        let {type, htmlBuilder, mathmlBuilder} = _ref2;
        defineFunction({type, names:[], props:{numArgs:0}, handler() {
          throw Error("Should never be called.");
        }, htmlBuilder, mathmlBuilder});
      }
      function buildHTMLUnbreakable(children, options) {
        children = buildHTML_makeSpan(["base"], children, options);
        options = buildHTML_makeSpan(["strut"]);
        options.style.height = makeEm(children.height + children.depth);
        children.depth && (options.style.verticalAlign = makeEm(-children.depth));
        children.children.unshift(options);
        return children;
      }
      function buildHTML(tree, options) {
        let tag = null;
        1 === tree.length && "tag" === tree[0].type && (tag = tree[0].tag, tree = tree[0].body);
        tree = buildExpression(tree, options, "root");
        let eqnNum;
        2 === tree.length && tree[1].hasClass("tag") && (eqnNum = tree.pop());
        const children = [];
        let parts = [];
        for (let i = 0; i < tree.length; i++) {
          if (parts.push(tree[i]), tree[i].hasClass("mbin") || tree[i].hasClass("mrel") || tree[i].hasClass("allowbreak")) {
            let nobreak = !1;
            for (; i < tree.length - 1 && tree[i + 1].hasClass("mspace") && !tree[i + 1].hasClass("newline");) {
              i++, parts.push(tree[i]), tree[i].hasClass("nobreak") && (nobreak = !0);
            }
            nobreak || (children.push(buildHTMLUnbreakable(parts, options)), parts = []);
          } else {
            tree[i].hasClass("newline") && (parts.pop(), 0 < parts.length && (children.push(buildHTMLUnbreakable(parts, options)), parts = []), children.push(tree[i]));
          }
        }
        0 < parts.length && children.push(buildHTMLUnbreakable(parts, options));
        if (tag) {
          var tagChild = buildHTMLUnbreakable(buildExpression(tag, options, !0));
          tagChild.classes = ["tag"];
          children.push(tagChild);
        } else {
          eqnNum && children.push(eqnNum);
        }
        options = buildHTML_makeSpan(["katex-html"], children);
        options.setAttribute("aria-hidden", "true");
        tagChild && (tagChild = tagChild.children[0], tagChild.style.height = makeEm(options.height + options.depth), options.depth && (tagChild.style.verticalAlign = makeEm(-options.depth)));
        return options;
      }
      function newDocumentFragment(children) {
        return new DocumentFragment(children);
      }
      function isNumberPunctuation(group) {
        return group ? "mi" === group.type && 1 === group.children.length ? (group = group.children[0], group instanceof TextNode && "." === group.text) : "mo" === group.type && 1 === group.children.length && "true" === group.getAttribute("separator") && "0em" === group.getAttribute("lspace") && "0em" === group.getAttribute("rspace") ? (group = group.children[0], group instanceof TextNode && "," === group.text) : !1 : !1;
      }
      function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
        tree = buildMathML_buildExpression(tree, options);
        tree = 1 === tree.length && tree[0] instanceof MathNode && utils.contains(["mrow", "mtable"], tree[0].type) ? tree[0] : new mathMLTree.MathNode("mrow", tree);
        texExpression = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
        texExpression.setAttribute("encoding", "application/x-tex");
        texExpression = new mathMLTree.MathNode("semantics", [tree, texExpression]);
        texExpression = new mathMLTree.MathNode("math", [texExpression]);
        texExpression.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
        isDisplayMode && texExpression.setAttribute("display", "block");
        return buildCommon.makeSpan([forMathmlOnly ? "katex" : "katex-mathml"], [texExpression]);
      }
      function assertNodeType(node, type) {
        if (!node || node.type !== type) {
          throw Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
        }
        return node;
      }
      function assertSymbolNodeType(node) {
        const typedNode = checkSymbolNodeType(node);
        if (!typedNode) {
          throw Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
        }
        return typedNode;
      }
      function checkSymbolNodeType(node) {
        return node && ("atom" === node.type || NON_ATOMS.hasOwnProperty(node.type)) ? node : null;
      }
      function mclass_htmlBuilder(group, options) {
        const elements = buildExpression(group.body, options, !0);
        return mclass_makeSpan([group.mclass], elements, options);
      }
      function mclass_mathmlBuilder(group, options) {
        options = buildMathML_buildExpression(group.body, options);
        "minner" === group.mclass ? options = new mathMLTree.MathNode("mpadded", options) : "mord" === group.mclass ? group.isCharacterBox ? (options = options[0], options.type = "mi") : options = new mathMLTree.MathNode("mi", options) : (group.isCharacterBox ? (options = options[0], options.type = "mo") : options = new mathMLTree.MathNode("mo", options), "mbin" === group.mclass ? (options.attributes.lspace = "0.22em", options.attributes.rspace = "0.22em") : "mpunct" === group.mclass ? (options.attributes.lspace = 
        "0em", options.attributes.rspace = "0.17em") : "mopen" === group.mclass || "mclose" === group.mclass ? (options.attributes.lspace = "0em", options.attributes.rspace = "0em") : "minner" === group.mclass && (options.attributes.lspace = "0.0556em", options.attributes.width = "+0.1111em"));
        return options;
      }
      function cdArrow(arrowChar, labels, parser) {
        var funcName = cdArrowFunctionName[arrowChar];
        switch(funcName) {
          case "\\\\cdrightarrow":
          case "\\\\cdleftarrow":
            return parser.callFunction(funcName, [labels[0]], [labels[1]]);
          case "\\uparrow":
          case "\\downarrow":
            return arrowChar = parser.callFunction("\\\\cdleft", [labels[0]], []), funcName = parser.callFunction("\\Big", [{type:"atom", text:funcName, mode:"math", family:"rel"}], []), labels = parser.callFunction("\\\\cdright", [labels[1]], []), parser.callFunction("\\\\cdparent", [{type:"ordgroup", mode:"math", body:[arrowChar, funcName, labels]}], []);
          case "\\\\cdlongequal":
            return parser.callFunction("\\\\cdlongequal", [], []);
          case "\\Vert":
            return parser.callFunction("\\Big", [{type:"textord", text:"\\Vert", mode:"math"}], []);
          default:
            return {type:"textord", text:" ", mode:"math"};
        }
      }
      function checkDelimiter(delim, context) {
        const symDelim = checkSymbolNodeType(delim);
        if (symDelim && utils.contains(delimiters, symDelim.text)) {
          return symDelim;
        }
        if (symDelim) {
          throw new src_ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
        }
        throw new src_ParseError("Invalid delimiter type '" + delim.type + "'", delim);
      }
      function assertParsed(group) {
        if (!group.body) {
          throw Error("Bug: The leftright ParseNode wasn't fully parsed.");
        }
      }
      function defineEnvironment(_ref) {
        let {type, names, props, handler, htmlBuilder, mathmlBuilder} = _ref;
        _ref = {type, numArgs:props.numArgs || 0, allowedInText:!1, numOptionalArgs:0, handler};
        for (let i = 0; i < names.length; ++i) {
          _environments[names[i]] = _ref;
        }
        htmlBuilder && (_htmlGroupBuilders[type] = htmlBuilder);
        mathmlBuilder && (_mathmlGroupBuilders[type] = mathmlBuilder);
      }
      function defineMacro(name, body) {
        _macros[name] = body;
      }
      function getHLines(parser) {
        const hlineInfo = [];
        parser.consumeSpaces();
        let nxt = parser.fetch().text;
        "\\relax" === nxt && (parser.consume(), parser.consumeSpaces(), nxt = parser.fetch().text);
        for (; "\\hline" === nxt || "\\hdashline" === nxt;) {
          parser.consume(), hlineInfo.push("\\hdashline" === nxt), parser.consumeSpaces(), nxt = parser.fetch().text;
        }
        return hlineInfo;
      }
      function getAutoTag(name) {
        if (-1 === name.indexOf("ed")) {
          return -1 === name.indexOf("*");
        }
      }
      function parseArray(parser, _ref, style) {
        function beginRow() {
          autoTag && parser.gullet.macros.set("\\@eqnsw", "1", !0);
        }
        function endRow() {
          tags && (parser.gullet.macros.get("\\df@tag") ? (tags.push(parser.subparse([new Token("\\df@tag")])), parser.gullet.macros.set("\\df@tag", void 0, !0)) : tags.push(!!autoTag && "1" === parser.gullet.macros.get("\\@eqnsw")));
        }
        let {hskipBeforeAndAfter, addJot, cols, arraystretch, colSeparationType, autoTag, singleRow, emptySingleRow, maxNumCols, leqno} = _ref;
        parser.gullet.beginGroup();
        singleRow || parser.gullet.macros.set("\\cr", "\\\\\\relax");
        if (!arraystretch) {
          if (_ref = parser.gullet.expandMacroAsText("\\arraystretch"), null == _ref) {
            arraystretch = 1;
          } else {
            if (arraystretch = parseFloat(_ref), !arraystretch || 0 > arraystretch) {
              throw new src_ParseError("Invalid \\arraystretch: " + _ref);
            }
          }
        }
        parser.gullet.beginGroup();
        _ref = [];
        const body = [_ref], rowGaps = [], hLinesBeforeRow = [], tags = null != autoTag ? [] : void 0;
        beginRow();
        for (hLinesBeforeRow.push(getHLines(parser));;) {
          let cell = parser.parseExpression(!1, singleRow ? "\\end" : "\\\\");
          parser.gullet.endGroup();
          parser.gullet.beginGroup();
          cell = {type:"ordgroup", mode:parser.mode, body:cell};
          style && (cell = {type:"styling", mode:parser.mode, style, body:[cell]});
          _ref.push(cell);
          const next = parser.fetch().text;
          if ("\x26" === next) {
            if (maxNumCols && _ref.length === maxNumCols) {
              if (singleRow || colSeparationType) {
                throw new src_ParseError("Too many tab characters: \x26", parser.nextToken);
              }
              parser.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
            }
            parser.consume();
          } else if ("\\end" === next) {
            endRow();
            1 === _ref.length && "styling" === cell.type && 0 === cell.body[0].body.length && (1 < body.length || !emptySingleRow) && body.pop();
            hLinesBeforeRow.length < body.length + 1 && hLinesBeforeRow.push([]);
            break;
          } else if ("\\\\" === next) {
            parser.consume();
            let size;
            " " !== parser.gullet.future().text && (size = parser.parseSizeGroup(!0));
            rowGaps.push(size ? size.value : null);
            endRow();
            hLinesBeforeRow.push(getHLines(parser));
            _ref = [];
            body.push(_ref);
            beginRow();
          } else {
            throw new src_ParseError("Expected \x26 or \\\\ or \\cr or \\end", parser.nextToken);
          }
        }
        parser.gullet.endGroup();
        parser.gullet.endGroup();
        return {type:"array", mode:parser.mode, addJot, arraystretch, body, cols, rowGaps, hskipBeforeAndAfter, hLinesBeforeRow, colSeparationType, tags, leqno};
      }
      function dCellStyle(envName) {
        return "d" === envName.slice(0, 1) ? "display" : "text";
      }
      function sizingGroup(value, options, baseOptions) {
        value = buildExpression(value, options, !1);
        const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
        for (let i = 0; i < value.length; i++) {
          const pos = value[i].classes.indexOf("sizing");
          0 > pos ? Array.prototype.push.apply(value[i].classes, options.sizingClasses(baseOptions)) : value[i].classes[pos + 1] === "reset-size" + options.size && (value[i].classes[pos + 1] = "reset-size" + baseOptions.size);
          value[i].height *= multiplier;
          value[i].depth *= multiplier;
        }
        return buildCommon.makeFragment(value);
      }
      var __webpack_require__ = {};
      !function() {
        __webpack_require__.d = function(exports, definition) {
          for (var key in definition) {
            __webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key) && Object.defineProperty(exports, key, {enumerable:!0, get:definition[key]});
          }
        };
      }();
      !function() {
        __webpack_require__.o = function(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        };
      }();
      var __webpack_exports__ = {};
      __webpack_require__.d(__webpack_exports__, {"default":function() {
        return katex_webpack;
      }});
      class ParseError {
        constructor(message, token) {
          this.rawMessage = this.length = this.position = this.name = void 0;
          var error = "KaTeX parse error: " + message;
          let start, end;
          var loc = token && token.loc;
          if (loc && loc.start <= loc.end) {
            token = loc.lexer.input;
            start = loc.start;
            end = loc.end;
            error = start === token.length ? error + " at end of input: " : error + (" at position " + (start + 1) + ": ");
            loc = token.slice(start, end).replace(/[^]/g, "$\x26̲");
            let left;
            left = 15 < start ? "…" + token.slice(start - 15, start) : token.slice(0, start);
            token = end + 15 < token.length ? token.slice(end, end + 15) + "…" : token.slice(end);
            error += left + loc + token;
          }
          error = Error(error);
          error.name = "ParseError";
          error.__proto__ = ParseError.prototype;
          error.position = start;
          null != start && null != end && (error.length = end - start);
          error.rawMessage = message;
          return error;
        }
      }
      ParseError.prototype.__proto__ = Error.prototype;
      var src_ParseError = ParseError;
      const uppercase = /([A-Z])/g, ESCAPE_LOOKUP = {"\x26":"\x26amp;", "\x3e":"\x26gt;", "\x3c":"\x26lt;", '"':"\x26quot;", "'":"\x26#x27;"}, ESCAPE_REGEX = /[&><"']/g, getBaseElem = function(group) {
        return "ordgroup" === group.type ? 1 === group.body.length ? getBaseElem(group.body[0]) : group : "color" === group.type ? 1 === group.body.length ? getBaseElem(group.body[0]) : group : "font" === group.type ? getBaseElem(group.body) : group;
      };
      var utils = {contains:function(list, elem) {
        return -1 !== list.indexOf(elem);
      }, deflt:function(setting, defaultIfUndefined) {
        return void 0 === setting ? defaultIfUndefined : setting;
      }, escape:function(text) {
        return String(text).replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);
      }, hyphenate:function(str) {
        return str.replace(uppercase, "-$1").toLowerCase();
      }, getBaseElem, isCharacterBox:function(group) {
        group = getBaseElem(group);
        return "mathord" === group.type || "textord" === group.type || "atom" === group.type;
      }, protocolFromUrl:function(url) {
        return (url = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url)) ? ":" === url[2] && /^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(url[1]) ? url[1].toLowerCase() : null : "_relative";
      }};
      const SETTINGS_SCHEMA = {displayMode:{type:"boolean", description:"Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.", cli:"-d, --display-mode"}, output:{type:{enum:["htmlAndMathml", "html", "mathml"]}, description:"Determines the markup language of the output.", cli:"-F, --format \x3ctype\x3e"}, leqno:{type:"boolean", description:"Render display math in leqno style (left-justified tags)."}, 
      fleqn:{type:"boolean", description:"Render display math flush left."}, throwOnError:{type:"boolean", default:!0, cli:"-t, --no-throw-on-error", cliDescription:"Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."}, errorColor:{type:"string", default:"#cc0000", cli:"-c, --error-color \x3ccolor\x3e", cliDescription:"A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.", 
      cliProcessor:color => "#" + color}, macros:{type:"object", cli:"-m, --macro \x3cdef\x3e", cliDescription:"Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).", cliDefault:[], cliProcessor:(def, defs) => {
        defs.push(def);
        return defs;
      }}, minRuleThickness:{type:"number", description:"Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.", processor:t => Math.max(0, t), cli:"--min-rule-thickness \x3csize\x3e", cliProcessor:parseFloat}, colorIsTextColor:{type:"boolean", description:"Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.", 
      cli:"-b, --color-is-text-color"}, strict:{type:[{enum:["warn", "ignore", "error"]}, "boolean", "function"], description:"Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.", cli:"-S, --strict", cliDefault:!1}, trust:{type:["boolean", "function"], description:"Trust the input, enabling all HTML features such as \\url.", cli:"-T, --trust"}, maxSize:{type:"number", default:Infinity, description:"If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large", 
      processor:s => Math.max(0, s), cli:"-s, --max-size \x3cn\x3e", cliProcessor:parseInt}, maxExpand:{type:"number", default:1000, description:"Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.", processor:n => Math.max(0, n), cli:"-e, --max-expand \x3cn\x3e", cliProcessor:n => "Infinity" === n ? Infinity : parseInt(n)}, globalGroup:{type:"boolean", cli:!1}};
      class Settings {
        constructor(options) {
          this.globalGroup = this.maxExpand = this.maxSize = this.trust = this.strict = this.colorIsTextColor = this.minRuleThickness = this.macros = this.errorColor = this.throwOnError = this.fleqn = this.leqno = this.output = this.displayMode = void 0;
          options = options || {};
          for (const prop in SETTINGS_SCHEMA) {
            if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
              const schema = SETTINGS_SCHEMA[prop];
              this[prop] = void 0 !== options[prop] ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
            }
          }
        }
        reportNonstrict(errorCode, errorMsg, token) {
          let strict = this.strict;
          "function" === typeof strict && (strict = strict(errorCode, errorMsg, token));
          if (strict && "ignore" !== strict) {
            if (!0 === strict || "error" === strict) {
              throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
            }
            "warn" === strict ? "undefined" !== typeof console && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]")) : "undefined" !== typeof console && console.warn("LaTeX-incompatible input and strict mode is set to unrecognized '" + (strict + "': " + errorMsg + " [" + errorCode + "]"));
          }
        }
        useStrictBehavior(errorCode, errorMsg, token) {
          let strict = this.strict;
          if ("function" === typeof strict) {
            try {
              strict = strict(errorCode, errorMsg, token);
            } catch (error) {
              strict = "error";
            }
          }
          if (strict && "ignore" !== strict) {
            if (!0 === strict || "error" === strict) {
              return !0;
            }
            "warn" === strict ? "undefined" !== typeof console && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]")) : "undefined" !== typeof console && console.warn("LaTeX-incompatible input and strict mode is set to unrecognized '" + (strict + "': " + errorMsg + " [" + errorCode + "]"));
          }
          return !1;
        }
        isTrusted(context) {
          if (context.url && !context.protocol) {
            const protocol = utils.protocolFromUrl(context.url);
            if (null == protocol) {
              return !1;
            }
            context.protocol = protocol;
          }
          return !("function" === typeof this.trust ? !this.trust(context) : !this.trust);
        }
      }
      class Style {
        constructor(id, size, cramped) {
          this.cramped = this.size = this.id = void 0;
          this.id = id;
          this.size = size;
          this.cramped = cramped;
        }
        sup() {
          return styles[sup[this.id]];
        }
        sub() {
          return styles[sub[this.id]];
        }
        fracNum() {
          return styles[fracNum[this.id]];
        }
        fracDen() {
          return styles[fracDen[this.id]];
        }
        cramp() {
          return styles[cramp[this.id]];
        }
        text() {
          return styles[Style_text[this.id]];
        }
        isTight() {
          return 2 <= this.size;
        }
      }
      const styles = [new Style(0, 0, !1), new Style(1, 0, !0), new Style(2, 1, !1), new Style(3, 1, !0), new Style(4, 2, !1), new Style(5, 2, !0), new Style(6, 3, !1), new Style(7, 3, !0)], sup = [4, 5, 4, 5, 6, 7, 6, 7], sub = [5, 5, 5, 5, 7, 7, 7, 7], fracNum = [2, 3, 4, 5, 6, 7, 6, 7], fracDen = [3, 3, 5, 5, 7, 7, 7, 7], cramp = [1, 1, 3, 3, 5, 5, 7, 7], Style_text = [0, 1, 2, 3, 2, 3, 2, 3];
      var JSCompiler_object_inline_DISPLAY_2534 = styles[0], JSCompiler_object_inline_TEXT_2535 = styles[2], JSCompiler_object_inline_SCRIPT_2536 = styles[4], JSCompiler_object_inline_SCRIPTSCRIPT_2537 = styles[6];
      const scriptData = [{name:"latin", blocks:[[256, 591], [768, 879]]}, {name:"cyrillic", blocks:[[1024, 1279]]}, {name:"armenian", blocks:[[1328, 1423]]}, {name:"brahmic", blocks:[[2304, 4255]]}, {name:"georgian", blocks:[[4256, 4351]]}, {name:"cjk", blocks:[[12288, 12543], [19968, 40879], [65280, 65376]]}, {name:"hangul", blocks:[[44032, 55215]]}], allBlocks = [];
      scriptData.forEach(s => s.blocks.forEach(b => allBlocks.push(...b)));
      const innerPath = function(name, height) {
        switch(name) {
          case "⎜":
            return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
          case "∣":
            return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
          case "∥":
            return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145zM367 0 H410 V" + (height + " H367z M367 0 H410 V" + height + " H367z");
          case "⎟":
            return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
          case "⎢":
            return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
          case "⎥":
            return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
          case "⎪":
            return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
          case "⏐":
            return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
          case "‖":
            return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257zM478 0 H521 V" + (height + " H478z M478 0 H521 V" + height + " H478z");
          default:
            return "";
        }
      }, path = {doubleleftarrow:"M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z", 
      doublerightarrow:"M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z", 
      leftarrow:"M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z", leftbrace:"M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z", 
      leftbraceunder:"M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z", leftgroup:"M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z", leftgroupunder:"M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z", 
      leftharpoon:"M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z", leftharpoonplus:"M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z", 
      leftharpoondown:"M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z", leftharpoondownplus:"M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z", 
      lefthook:"M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z", leftlinesegment:"M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z", leftmapsto:"M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z", leftToFrom:"M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z", 
      longequal:"M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z", midbrace:"M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z", midbraceunder:"M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z", 
      oiintSize1:"M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z", oiintSize2:"M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z", 
      oiiintSize1:"M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z", oiiintSize2:"M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z", 
      rightarrow:"M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z", rightbrace:"M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z", 
      rightbraceunder:"M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z", rightgroup:"M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z", rightgroupunder:"M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z", rightharpoon:"M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z", 
      rightharpoonplus:"M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z", rightharpoondown:"M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z", 
      rightharpoondownplus:"M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z", righthook:"M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z", 
      rightlinesegment:"M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z", rightToFrom:"M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z", twoheadleftarrow:"M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z", 
      twoheadrightarrow:"M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z", tilde1:"M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z", 
      tilde2:"M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z", tilde3:"M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z", 
      tilde4:"M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z", vec:"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z", 
      widehat1:"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z", widehat2:"M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z", widehat3:"M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z", widehat4:"M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z", 
      widecheck1:"M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z", widecheck2:"M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z", widecheck3:"M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z", widecheck4:"M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z", 
      baraboveleftarrow:"M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z", 
      rightarrowabovebar:"M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z", 
      baraboveshortleftharpoon:"M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z", rightharpoonaboveshortbar:"M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z", 
      shortbaraboveleftharpoon:"M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z", shortrightharpoonabovebar:"M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"}, 
      tallDelim = function(label, midHeight) {
        switch(label) {
          case "lbrack":
            return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
          case "rbrack":
            return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
          case "vert":
            return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
          case "doublevert":
            return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
          case "lfloor":
            return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
          case "rfloor":
            return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
          case "lceil":
            return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
          case "rceil":
            return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
          case "lparen":
            return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
          case "rparen":
            return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + 
            (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
          default:
            throw Error("Unknown stretchy delimiter.");
        }
      };
      class DocumentFragment {
        constructor(children) {
          this.style = this.maxFontSize = this.depth = this.height = this.classes = this.children = void 0;
          this.children = children;
          this.classes = [];
          this.maxFontSize = this.depth = this.height = 0;
          this.style = {};
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          const frag = document.createDocumentFragment();
          for (let i = 0; i < this.children.length; i++) {
            frag.appendChild(this.children[i].toNode());
          }
          return frag;
        }
        toMarkup() {
          let markup = "";
          for (let i = 0; i < this.children.length; i++) {
            markup += this.children[i].toMarkup();
          }
          return markup;
        }
        toText() {
          return this.children.map(child => child.toText()).join("");
        }
      }
      var fontMetricsData = {"AMS-Regular":{32:[0, 0, 0, 0, 0.25], 65:[0, 0.68889, 0, 0, 0.72222], 66:[0, 0.68889, 0, 0, 0.66667], 67:[0, 0.68889, 0, 0, 0.72222], 68:[0, 0.68889, 0, 0, 0.72222], 69:[0, 0.68889, 0, 0, 0.66667], 70:[0, 0.68889, 0, 0, 0.61111], 71:[0, 0.68889, 0, 0, 0.77778], 72:[0, 0.68889, 0, 0, 0.77778], 73:[0, 0.68889, 0, 0, 0.38889], 74:[0.16667, 0.68889, 0, 0, 0.5], 75:[0, 0.68889, 0, 0, 0.77778], 76:[0, 0.68889, 0, 0, 0.66667], 77:[0, 0.68889, 0, 0, 0.94445], 78:[0, 0.68889, 
      0, 0, 0.72222], 79:[0.16667, 0.68889, 0, 0, 0.77778], 80:[0, 0.68889, 0, 0, 0.61111], 81:[0.16667, 0.68889, 0, 0, 0.77778], 82:[0, 0.68889, 0, 0, 0.72222], 83:[0, 0.68889, 0, 0, 0.55556], 84:[0, 0.68889, 0, 0, 0.66667], 85:[0, 0.68889, 0, 0, 0.72222], 86:[0, 0.68889, 0, 0, 0.72222], 87:[0, 0.68889, 0, 0, 1.0], 88:[0, 0.68889, 0, 0, 0.72222], 89:[0, 0.68889, 0, 0, 0.72222], 90:[0, 0.68889, 0, 0, 0.66667], 107:[0, 0.68889, 0, 0, 0.55556], 160:[0, 0, 0, 0, 0.25], 165:[0, 0.675, 0.025, 0, 0.75], 
      174:[0.15559, 0.69224, 0, 0, 0.94666], 240:[0, 0.68889, 0, 0, 0.55556], 295:[0, 0.68889, 0, 0, 0.54028], 710:[0, 0.825, 0, 0, 2.33334], 732:[0, 0.9, 0, 0, 2.33334], 770:[0, 0.825, 0, 0, 2.33334], 771:[0, 0.9, 0, 0, 2.33334], 989:[0.08167, 0.58167, 0, 0, 0.77778], 1008:[0, 0.43056, 0.04028, 0, 0.66667], 8245:[0, 0.54986, 0, 0, 0.275], 8463:[0, 0.68889, 0, 0, 0.54028], 8487:[0, 0.68889, 0, 0, 0.72222], 8498:[0, 0.68889, 0, 0, 0.55556], 8502:[0, 0.68889, 0, 0, 0.66667], 8503:[0, 0.68889, 0, 0, 
      0.44445], 8504:[0, 0.68889, 0, 0, 0.66667], 8513:[0, 0.68889, 0, 0, 0.63889], 8592:[-0.03598, 0.46402, 0, 0, 0.5], 8594:[-0.03598, 0.46402, 0, 0, 0.5], 8602:[-0.13313, 0.36687, 0, 0, 1.0], 8603:[-0.13313, 0.36687, 0, 0, 1.0], 8606:[0.01354, 0.52239, 0, 0, 1.0], 8608:[0.01354, 0.52239, 0, 0, 1.0], 8610:[0.01354, 0.52239, 0, 0, 1.11111], 8611:[0.01354, 0.52239, 0, 0, 1.11111], 8619:[0, 0.54986, 0, 0, 1.0], 8620:[0, 0.54986, 0, 0, 1.0], 8621:[-0.13313, 0.37788, 0, 0, 1.38889], 8622:[-0.13313, 
      0.36687, 0, 0, 1.0], 8624:[0, 0.69224, 0, 0, 0.5], 8625:[0, 0.69224, 0, 0, 0.5], 8630:[0, 0.43056, 0, 0, 1.0], 8631:[0, 0.43056, 0, 0, 1.0], 8634:[0.08198, 0.58198, 0, 0, 0.77778], 8635:[0.08198, 0.58198, 0, 0, 0.77778], 8638:[0.19444, 0.69224, 0, 0, 0.41667], 8639:[0.19444, 0.69224, 0, 0, 0.41667], 8642:[0.19444, 0.69224, 0, 0, 0.41667], 8643:[0.19444, 0.69224, 0, 0, 0.41667], 8644:[0.1808, 0.675, 0, 0, 1.0], 8646:[0.1808, 0.675, 0, 0, 1.0], 8647:[0.1808, 0.675, 0, 0, 1.0], 8648:[0.19444, 
      0.69224, 0, 0, 0.83334], 8649:[0.1808, 0.675, 0, 0, 1.0], 8650:[0.19444, 0.69224, 0, 0, 0.83334], 8651:[0.01354, 0.52239, 0, 0, 1.0], 8652:[0.01354, 0.52239, 0, 0, 1.0], 8653:[-0.13313, 0.36687, 0, 0, 1.0], 8654:[-0.13313, 0.36687, 0, 0, 1.0], 8655:[-0.13313, 0.36687, 0, 0, 1.0], 8666:[0.13667, 0.63667, 0, 0, 1.0], 8667:[0.13667, 0.63667, 0, 0, 1.0], 8669:[-0.13313, 0.37788, 0, 0, 1.0], 8672:[-0.064, 0.437, 0, 0, 1.334], 8674:[-0.064, 0.437, 0, 0, 1.334], 8705:[0, 0.825, 0, 0, 0.5], 8708:[0, 
      0.68889, 0, 0, 0.55556], 8709:[0.08167, 0.58167, 0, 0, 0.77778], 8717:[0, 0.43056, 0, 0, 0.42917], 8722:[-0.03598, 0.46402, 0, 0, 0.5], 8724:[0.08198, 0.69224, 0, 0, 0.77778], 8726:[0.08167, 0.58167, 0, 0, 0.77778], 8733:[0, 0.69224, 0, 0, 0.77778], 8736:[0, 0.69224, 0, 0, 0.72222], 8737:[0, 0.69224, 0, 0, 0.72222], 8738:[0.03517, 0.52239, 0, 0, 0.72222], 8739:[0.08167, 0.58167, 0, 0, 0.22222], 8740:[0.25142, 0.74111, 0, 0, 0.27778], 8741:[0.08167, 0.58167, 0, 0, 0.38889], 8742:[0.25142, 0.74111, 
      0, 0, 0.5], 8756:[0, 0.69224, 0, 0, 0.66667], 8757:[0, 0.69224, 0, 0, 0.66667], 8764:[-0.13313, 0.36687, 0, 0, 0.77778], 8765:[-0.13313, 0.37788, 0, 0, 0.77778], 8769:[-0.13313, 0.36687, 0, 0, 0.77778], 8770:[-0.03625, 0.46375, 0, 0, 0.77778], 8774:[0.30274, 0.79383, 0, 0, 0.77778], 8776:[-0.01688, 0.48312, 0, 0, 0.77778], 8778:[0.08167, 0.58167, 0, 0, 0.77778], 8782:[0.06062, 0.54986, 0, 0, 0.77778], 8783:[0.06062, 0.54986, 0, 0, 0.77778], 8785:[0.08198, 0.58198, 0, 0, 0.77778], 8786:[0.08198, 
      0.58198, 0, 0, 0.77778], 8787:[0.08198, 0.58198, 0, 0, 0.77778], 8790:[0, 0.69224, 0, 0, 0.77778], 8791:[0.22958, 0.72958, 0, 0, 0.77778], 8796:[0.08198, 0.91667, 0, 0, 0.77778], 8806:[0.25583, 0.75583, 0, 0, 0.77778], 8807:[0.25583, 0.75583, 0, 0, 0.77778], 8808:[0.25142, 0.75726, 0, 0, 0.77778], 8809:[0.25142, 0.75726, 0, 0, 0.77778], 8812:[0.25583, 0.75583, 0, 0, 0.5], 8814:[0.20576, 0.70576, 0, 0, 0.77778], 8815:[0.20576, 0.70576, 0, 0, 0.77778], 8816:[0.30274, 0.79383, 0, 0, 0.77778], 
      8817:[0.30274, 0.79383, 0, 0, 0.77778], 8818:[0.22958, 0.72958, 0, 0, 0.77778], 8819:[0.22958, 0.72958, 0, 0, 0.77778], 8822:[0.1808, 0.675, 0, 0, 0.77778], 8823:[0.1808, 0.675, 0, 0, 0.77778], 8828:[0.13667, 0.63667, 0, 0, 0.77778], 8829:[0.13667, 0.63667, 0, 0, 0.77778], 8830:[0.22958, 0.72958, 0, 0, 0.77778], 8831:[0.22958, 0.72958, 0, 0, 0.77778], 8832:[0.20576, 0.70576, 0, 0, 0.77778], 8833:[0.20576, 0.70576, 0, 0, 0.77778], 8840:[0.30274, 0.79383, 0, 0, 0.77778], 8841:[0.30274, 0.79383, 
      0, 0, 0.77778], 8842:[0.13597, 0.63597, 0, 0, 0.77778], 8843:[0.13597, 0.63597, 0, 0, 0.77778], 8847:[0.03517, 0.54986, 0, 0, 0.77778], 8848:[0.03517, 0.54986, 0, 0, 0.77778], 8858:[0.08198, 0.58198, 0, 0, 0.77778], 8859:[0.08198, 0.58198, 0, 0, 0.77778], 8861:[0.08198, 0.58198, 0, 0, 0.77778], 8862:[0, 0.675, 0, 0, 0.77778], 8863:[0, 0.675, 0, 0, 0.77778], 8864:[0, 0.675, 0, 0, 0.77778], 8865:[0, 0.675, 0, 0, 0.77778], 8872:[0, 0.69224, 0, 0, 0.61111], 8873:[0, 0.69224, 0, 0, 0.72222], 8874:[0, 
      0.69224, 0, 0, 0.88889], 8876:[0, 0.68889, 0, 0, 0.61111], 8877:[0, 0.68889, 0, 0, 0.61111], 8878:[0, 0.68889, 0, 0, 0.72222], 8879:[0, 0.68889, 0, 0, 0.72222], 8882:[0.03517, 0.54986, 0, 0, 0.77778], 8883:[0.03517, 0.54986, 0, 0, 0.77778], 8884:[0.13667, 0.63667, 0, 0, 0.77778], 8885:[0.13667, 0.63667, 0, 0, 0.77778], 8888:[0, 0.54986, 0, 0, 1.11111], 8890:[0.19444, 0.43056, 0, 0, 0.55556], 8891:[0.19444, 0.69224, 0, 0, 0.61111], 8892:[0.19444, 0.69224, 0, 0, 0.61111], 8901:[0, 0.54986, 0, 
      0, 0.27778], 8903:[0.08167, 0.58167, 0, 0, 0.77778], 8905:[0.08167, 0.58167, 0, 0, 0.77778], 8906:[0.08167, 0.58167, 0, 0, 0.77778], 8907:[0, 0.69224, 0, 0, 0.77778], 8908:[0, 0.69224, 0, 0, 0.77778], 8909:[-0.03598, 0.46402, 0, 0, 0.77778], 8910:[0, 0.54986, 0, 0, 0.76042], 8911:[0, 0.54986, 0, 0, 0.76042], 8912:[0.03517, 0.54986, 0, 0, 0.77778], 8913:[0.03517, 0.54986, 0, 0, 0.77778], 8914:[0, 0.54986, 0, 0, 0.66667], 8915:[0, 0.54986, 0, 0, 0.66667], 8916:[0, 0.69224, 0, 0, 0.66667], 8918:[0.0391, 
      0.5391, 0, 0, 0.77778], 8919:[0.0391, 0.5391, 0, 0, 0.77778], 8920:[0.03517, 0.54986, 0, 0, 1.33334], 8921:[0.03517, 0.54986, 0, 0, 1.33334], 8922:[0.38569, 0.88569, 0, 0, 0.77778], 8923:[0.38569, 0.88569, 0, 0, 0.77778], 8926:[0.13667, 0.63667, 0, 0, 0.77778], 8927:[0.13667, 0.63667, 0, 0, 0.77778], 8928:[0.30274, 0.79383, 0, 0, 0.77778], 8929:[0.30274, 0.79383, 0, 0, 0.77778], 8934:[0.23222, 0.74111, 0, 0, 0.77778], 8935:[0.23222, 0.74111, 0, 0, 0.77778], 8936:[0.23222, 0.74111, 0, 0, 0.77778], 
      8937:[0.23222, 0.74111, 0, 0, 0.77778], 8938:[0.20576, 0.70576, 0, 0, 0.77778], 8939:[0.20576, 0.70576, 0, 0, 0.77778], 8940:[0.30274, 0.79383, 0, 0, 0.77778], 8941:[0.30274, 0.79383, 0, 0, 0.77778], 8994:[0.19444, 0.69224, 0, 0, 0.77778], 8995:[0.19444, 0.69224, 0, 0, 0.77778], 9416:[0.15559, 0.69224, 0, 0, 0.90222], 9484:[0, 0.69224, 0, 0, 0.5], 9488:[0, 0.69224, 0, 0, 0.5], 9492:[0, 0.37788, 0, 0, 0.5], 9496:[0, 0.37788, 0, 0, 0.5], 9585:[0.19444, 0.68889, 0, 0, 0.88889], 9586:[0.19444, 
      0.74111, 0, 0, 0.88889], 9632:[0, 0.675, 0, 0, 0.77778], 9633:[0, 0.675, 0, 0, 0.77778], 9650:[0, 0.54986, 0, 0, 0.72222], 9651:[0, 0.54986, 0, 0, 0.72222], 9654:[0.03517, 0.54986, 0, 0, 0.77778], 9660:[0, 0.54986, 0, 0, 0.72222], 9661:[0, 0.54986, 0, 0, 0.72222], 9664:[0.03517, 0.54986, 0, 0, 0.77778], 9674:[0.11111, 0.69224, 0, 0, 0.66667], 9733:[0.19444, 0.69224, 0, 0, 0.94445], 10003:[0, 0.69224, 0, 0, 0.83334], 10016:[0, 0.69224, 0, 0, 0.83334], 10731:[0.11111, 0.69224, 0, 0, 0.66667], 
      10846:[0.19444, 0.75583, 0, 0, 0.61111], 10877:[0.13667, 0.63667, 0, 0, 0.77778], 10878:[0.13667, 0.63667, 0, 0, 0.77778], 10885:[0.25583, 0.75583, 0, 0, 0.77778], 10886:[0.25583, 0.75583, 0, 0, 0.77778], 10887:[0.13597, 0.63597, 0, 0, 0.77778], 10888:[0.13597, 0.63597, 0, 0, 0.77778], 10889:[0.26167, 0.75726, 0, 0, 0.77778], 10890:[0.26167, 0.75726, 0, 0, 0.77778], 10891:[0.48256, 0.98256, 0, 0, 0.77778], 10892:[0.48256, 0.98256, 0, 0, 0.77778], 10901:[0.13667, 0.63667, 0, 0, 0.77778], 10902:[0.13667, 
      0.63667, 0, 0, 0.77778], 10933:[0.25142, 0.75726, 0, 0, 0.77778], 10934:[0.25142, 0.75726, 0, 0, 0.77778], 10935:[0.26167, 0.75726, 0, 0, 0.77778], 10936:[0.26167, 0.75726, 0, 0, 0.77778], 10937:[0.26167, 0.75726, 0, 0, 0.77778], 10938:[0.26167, 0.75726, 0, 0, 0.77778], 10949:[0.25583, 0.75583, 0, 0, 0.77778], 10950:[0.25583, 0.75583, 0, 0, 0.77778], 10955:[0.28481, 0.79383, 0, 0, 0.77778], 10956:[0.28481, 0.79383, 0, 0, 0.77778], 57350:[0.08167, 0.58167, 0, 0, 0.22222], 57351:[0.08167, 0.58167, 
      0, 0, 0.38889], 57352:[0.08167, 0.58167, 0, 0, 0.77778], 57353:[0, 0.43056, 0.04028, 0, 0.66667], 57356:[0.25142, 0.75726, 0, 0, 0.77778], 57357:[0.25142, 0.75726, 0, 0, 0.77778], 57358:[0.41951, 0.91951, 0, 0, 0.77778], 57359:[0.30274, 0.79383, 0, 0, 0.77778], 57360:[0.30274, 0.79383, 0, 0, 0.77778], 57361:[0.41951, 0.91951, 0, 0, 0.77778], 57366:[0.25142, 0.75726, 0, 0, 0.77778], 57367:[0.25142, 0.75726, 0, 0, 0.77778], 57368:[0.25142, 0.75726, 0, 0, 0.77778], 57369:[0.25142, 0.75726, 0, 
      0, 0.77778], 57370:[0.13597, 0.63597, 0, 0, 0.77778], 57371:[0.13597, 0.63597, 0, 0, 0.77778]}, "Caligraphic-Regular":{32:[0, 0, 0, 0, 0.25], 65:[0, 0.68333, 0, 0.19445, 0.79847], 66:[0, 0.68333, 0.03041, 0.13889, 0.65681], 67:[0, 0.68333, 0.05834, 0.13889, 0.52653], 68:[0, 0.68333, 0.02778, 0.08334, 0.77139], 69:[0, 0.68333, 0.08944, 0.11111, 0.52778], 70:[0, 0.68333, 0.09931, 0.11111, 0.71875], 71:[0.09722, 0.68333, 0.0593, 0.11111, 0.59487], 72:[0, 0.68333, 0.00965, 0.11111, 0.84452], 73:[0, 
      0.68333, 0.07382, 0, 0.54452], 74:[0.09722, 0.68333, 0.18472, 0.16667, 0.67778], 75:[0, 0.68333, 0.01445, 0.05556, 0.76195], 76:[0, 0.68333, 0, 0.13889, 0.68972], 77:[0, 0.68333, 0, 0.13889, 1.2009], 78:[0, 0.68333, 0.14736, 0.08334, 0.82049], 79:[0, 0.68333, 0.02778, 0.11111, 0.79611], 80:[0, 0.68333, 0.08222, 0.08334, 0.69556], 81:[0.09722, 0.68333, 0, 0.11111, 0.81667], 82:[0, 0.68333, 0, 0.08334, 0.8475], 83:[0, 0.68333, 0.075, 0.13889, 0.60556], 84:[0, 0.68333, 0.25417, 0, 0.54464], 85:[0, 
      0.68333, 0.09931, 0.08334, 0.62583], 86:[0, 0.68333, 0.08222, 0, 0.61278], 87:[0, 0.68333, 0.08222, 0.08334, 0.98778], 88:[0, 0.68333, 0.14643, 0.13889, 0.7133], 89:[0.09722, 0.68333, 0.08222, 0.08334, 0.66834], 90:[0, 0.68333, 0.07944, 0.13889, 0.72473], 160:[0, 0, 0, 0, 0.25]}, "Fraktur-Regular":{32:[0, 0, 0, 0, 0.25], 33:[0, 0.69141, 0, 0, 0.29574], 34:[0, 0.69141, 0, 0, 0.21471], 38:[0, 0.69141, 0, 0, 0.73786], 39:[0, 0.69141, 0, 0, 0.21201], 40:[0.24982, 0.74947, 0, 0, 0.38865], 41:[0.24982, 
      0.74947, 0, 0, 0.38865], 42:[0, 0.62119, 0, 0, 0.27764], 43:[0.08319, 0.58283, 0, 0, 0.75623], 44:[0, 0.10803, 0, 0, 0.27764], 45:[0.08319, 0.58283, 0, 0, 0.75623], 46:[0, 0.10803, 0, 0, 0.27764], 47:[0.24982, 0.74947, 0, 0, 0.50181], 48:[0, 0.47534, 0, 0, 0.50181], 49:[0, 0.47534, 0, 0, 0.50181], 50:[0, 0.47534, 0, 0, 0.50181], 51:[0.18906, 0.47534, 0, 0, 0.50181], 52:[0.18906, 0.47534, 0, 0, 0.50181], 53:[0.18906, 0.47534, 0, 0, 0.50181], 54:[0, 0.69141, 0, 0, 0.50181], 55:[0.18906, 0.47534, 
      0, 0, 0.50181], 56:[0, 0.69141, 0, 0, 0.50181], 57:[0.18906, 0.47534, 0, 0, 0.50181], 58:[0, 0.47534, 0, 0, 0.21606], 59:[0.12604, 0.47534, 0, 0, 0.21606], 61:[-0.13099, 0.36866, 0, 0, 0.75623], 63:[0, 0.69141, 0, 0, 0.36245], 65:[0, 0.69141, 0, 0, 0.7176], 66:[0, 0.69141, 0, 0, 0.88397], 67:[0, 0.69141, 0, 0, 0.61254], 68:[0, 0.69141, 0, 0, 0.83158], 69:[0, 0.69141, 0, 0, 0.66278], 70:[0.12604, 0.69141, 0, 0, 0.61119], 71:[0, 0.69141, 0, 0, 0.78539], 72:[0.06302, 0.69141, 0, 0, 0.7203], 73:[0, 
      0.69141, 0, 0, 0.55448], 74:[0.12604, 0.69141, 0, 0, 0.55231], 75:[0, 0.69141, 0, 0, 0.66845], 76:[0, 0.69141, 0, 0, 0.66602], 77:[0, 0.69141, 0, 0, 1.04953], 78:[0, 0.69141, 0, 0, 0.83212], 79:[0, 0.69141, 0, 0, 0.82699], 80:[0.18906, 0.69141, 0, 0, 0.82753], 81:[0.03781, 0.69141, 0, 0, 0.82699], 82:[0, 0.69141, 0, 0, 0.82807], 83:[0, 0.69141, 0, 0, 0.82861], 84:[0, 0.69141, 0, 0, 0.66899], 85:[0, 0.69141, 0, 0, 0.64576], 86:[0, 0.69141, 0, 0, 0.83131], 87:[0, 0.69141, 0, 0, 1.04602], 88:[0, 
      0.69141, 0, 0, 0.71922], 89:[0.18906, 0.69141, 0, 0, 0.83293], 90:[0.12604, 0.69141, 0, 0, 0.60201], 91:[0.24982, 0.74947, 0, 0, 0.27764], 93:[0.24982, 0.74947, 0, 0, 0.27764], 94:[0, 0.69141, 0, 0, 0.49965], 97:[0, 0.47534, 0, 0, 0.50046], 98:[0, 0.69141, 0, 0, 0.51315], 99:[0, 0.47534, 0, 0, 0.38946], 100:[0, 0.62119, 0, 0, 0.49857], 101:[0, 0.47534, 0, 0, 0.40053], 102:[0.18906, 0.69141, 0, 0, 0.32626], 103:[0.18906, 0.47534, 0, 0, 0.5037], 104:[0.18906, 0.69141, 0, 0, 0.52126], 105:[0, 
      0.69141, 0, 0, 0.27899], 106:[0, 0.69141, 0, 0, 0.28088], 107:[0, 0.69141, 0, 0, 0.38946], 108:[0, 0.69141, 0, 0, 0.27953], 109:[0, 0.47534, 0, 0, 0.76676], 110:[0, 0.47534, 0, 0, 0.52666], 111:[0, 0.47534, 0, 0, 0.48885], 112:[0.18906, 0.52396, 0, 0, 0.50046], 113:[0.18906, 0.47534, 0, 0, 0.48912], 114:[0, 0.47534, 0, 0, 0.38919], 115:[0, 0.47534, 0, 0, 0.44266], 116:[0, 0.62119, 0, 0, 0.33301], 117:[0, 0.47534, 0, 0, 0.5172], 118:[0, 0.52396, 0, 0, 0.5118], 119:[0, 0.52396, 0, 0, 0.77351], 
      120:[0.18906, 0.47534, 0, 0, 0.38865], 121:[0.18906, 0.47534, 0, 0, 0.49884], 122:[0.18906, 0.47534, 0, 0, 0.39054], 160:[0, 0, 0, 0, 0.25], 8216:[0, 0.69141, 0, 0, 0.21471], 8217:[0, 0.69141, 0, 0, 0.21471], 58112:[0, 0.62119, 0, 0, 0.49749], 58113:[0, 0.62119, 0, 0, 0.4983], 58114:[0.18906, 0.69141, 0, 0, 0.33328], 58115:[0.18906, 0.69141, 0, 0, 0.32923], 58116:[0.18906, 0.47534, 0, 0, 0.50343], 58117:[0, 0.69141, 0, 0, 0.33301], 58118:[0, 0.62119, 0, 0, 0.33409], 58119:[0, 0.47534, 0, 0, 
      0.50073]}, "Main-Bold":{32:[0, 0, 0, 0, 0.25], 33:[0, 0.69444, 0, 0, 0.35], 34:[0, 0.69444, 0, 0, 0.60278], 35:[0.19444, 0.69444, 0, 0, 0.95833], 36:[0.05556, 0.75, 0, 0, 0.575], 37:[0.05556, 0.75, 0, 0, 0.95833], 38:[0, 0.69444, 0, 0, 0.89444], 39:[0, 0.69444, 0, 0, 0.31944], 40:[0.25, 0.75, 0, 0, 0.44722], 41:[0.25, 0.75, 0, 0, 0.44722], 42:[0, 0.75, 0, 0, 0.575], 43:[0.13333, 0.63333, 0, 0, 0.89444], 44:[0.19444, 0.15556, 0, 0, 0.31944], 45:[0, 0.44444, 0, 0, 0.38333], 46:[0, 0.15556, 0, 
      0, 0.31944], 47:[0.25, 0.75, 0, 0, 0.575], 48:[0, 0.64444, 0, 0, 0.575], 49:[0, 0.64444, 0, 0, 0.575], 50:[0, 0.64444, 0, 0, 0.575], 51:[0, 0.64444, 0, 0, 0.575], 52:[0, 0.64444, 0, 0, 0.575], 53:[0, 0.64444, 0, 0, 0.575], 54:[0, 0.64444, 0, 0, 0.575], 55:[0, 0.64444, 0, 0, 0.575], 56:[0, 0.64444, 0, 0, 0.575], 57:[0, 0.64444, 0, 0, 0.575], 58:[0, 0.44444, 0, 0, 0.31944], 59:[0.19444, 0.44444, 0, 0, 0.31944], 60:[0.08556, 0.58556, 0, 0, 0.89444], 61:[-0.10889, 0.39111, 0, 0, 0.89444], 62:[0.08556, 
      0.58556, 0, 0, 0.89444], 63:[0, 0.69444, 0, 0, 0.54305], 64:[0, 0.69444, 0, 0, 0.89444], 65:[0, 0.68611, 0, 0, 0.86944], 66:[0, 0.68611, 0, 0, 0.81805], 67:[0, 0.68611, 0, 0, 0.83055], 68:[0, 0.68611, 0, 0, 0.88194], 69:[0, 0.68611, 0, 0, 0.75555], 70:[0, 0.68611, 0, 0, 0.72361], 71:[0, 0.68611, 0, 0, 0.90416], 72:[0, 0.68611, 0, 0, 0.9], 73:[0, 0.68611, 0, 0, 0.43611], 74:[0, 0.68611, 0, 0, 0.59444], 75:[0, 0.68611, 0, 0, 0.90138], 76:[0, 0.68611, 0, 0, 0.69166], 77:[0, 0.68611, 0, 0, 1.09166], 
      78:[0, 0.68611, 0, 0, 0.9], 79:[0, 0.68611, 0, 0, 0.86388], 80:[0, 0.68611, 0, 0, 0.78611], 81:[0.19444, 0.68611, 0, 0, 0.86388], 82:[0, 0.68611, 0, 0, 0.8625], 83:[0, 0.68611, 0, 0, 0.63889], 84:[0, 0.68611, 0, 0, 0.8], 85:[0, 0.68611, 0, 0, 0.88472], 86:[0, 0.68611, 0.01597, 0, 0.86944], 87:[0, 0.68611, 0.01597, 0, 1.18888], 88:[0, 0.68611, 0, 0, 0.86944], 89:[0, 0.68611, 0.02875, 0, 0.86944], 90:[0, 0.68611, 0, 0, 0.70277], 91:[0.25, 0.75, 0, 0, 0.31944], 92:[0.25, 0.75, 0, 0, 0.575], 93:[0.25, 
      0.75, 0, 0, 0.31944], 94:[0, 0.69444, 0, 0, 0.575], 95:[0.31, 0.13444, 0.03194, 0, 0.575], 97:[0, 0.44444, 0, 0, 0.55902], 98:[0, 0.69444, 0, 0, 0.63889], 99:[0, 0.44444, 0, 0, 0.51111], 100:[0, 0.69444, 0, 0, 0.63889], 101:[0, 0.44444, 0, 0, 0.52708], 102:[0, 0.69444, 0.10903, 0, 0.35139], 103:[0.19444, 0.44444, 0.01597, 0, 0.575], 104:[0, 0.69444, 0, 0, 0.63889], 105:[0, 0.69444, 0, 0, 0.31944], 106:[0.19444, 0.69444, 0, 0, 0.35139], 107:[0, 0.69444, 0, 0, 0.60694], 108:[0, 0.69444, 0, 0, 
      0.31944], 109:[0, 0.44444, 0, 0, 0.95833], 110:[0, 0.44444, 0, 0, 0.63889], 111:[0, 0.44444, 0, 0, 0.575], 112:[0.19444, 0.44444, 0, 0, 0.63889], 113:[0.19444, 0.44444, 0, 0, 0.60694], 114:[0, 0.44444, 0, 0, 0.47361], 115:[0, 0.44444, 0, 0, 0.45361], 116:[0, 0.63492, 0, 0, 0.44722], 117:[0, 0.44444, 0, 0, 0.63889], 118:[0, 0.44444, 0.01597, 0, 0.60694], 119:[0, 0.44444, 0.01597, 0, 0.83055], 120:[0, 0.44444, 0, 0, 0.60694], 121:[0.19444, 0.44444, 0.01597, 0, 0.60694], 122:[0, 0.44444, 0, 0, 
      0.51111], 123:[0.25, 0.75, 0, 0, 0.575], 124:[0.25, 0.75, 0, 0, 0.31944], 125:[0.25, 0.75, 0, 0, 0.575], 126:[0.35, 0.34444, 0, 0, 0.575], 160:[0, 0, 0, 0, 0.25], 163:[0, 0.69444, 0, 0, 0.86853], 168:[0, 0.69444, 0, 0, 0.575], 172:[0, 0.44444, 0, 0, 0.76666], 176:[0, 0.69444, 0, 0, 0.86944], 177:[0.13333, 0.63333, 0, 0, 0.89444], 184:[0.17014, 0, 0, 0, 0.51111], 198:[0, 0.68611, 0, 0, 1.04166], 215:[0.13333, 0.63333, 0, 0, 0.89444], 216:[0.04861, 0.73472, 0, 0, 0.89444], 223:[0, 0.69444, 0, 
      0, 0.59722], 230:[0, 0.44444, 0, 0, 0.83055], 247:[0.13333, 0.63333, 0, 0, 0.89444], 248:[0.09722, 0.54167, 0, 0, 0.575], 305:[0, 0.44444, 0, 0, 0.31944], 338:[0, 0.68611, 0, 0, 1.16944], 339:[0, 0.44444, 0, 0, 0.89444], 567:[0.19444, 0.44444, 0, 0, 0.35139], 710:[0, 0.69444, 0, 0, 0.575], 711:[0, 0.63194, 0, 0, 0.575], 713:[0, 0.59611, 0, 0, 0.575], 714:[0, 0.69444, 0, 0, 0.575], 715:[0, 0.69444, 0, 0, 0.575], 728:[0, 0.69444, 0, 0, 0.575], 729:[0, 0.69444, 0, 0, 0.31944], 730:[0, 0.69444, 
      0, 0, 0.86944], 732:[0, 0.69444, 0, 0, 0.575], 733:[0, 0.69444, 0, 0, 0.575], 915:[0, 0.68611, 0, 0, 0.69166], 916:[0, 0.68611, 0, 0, 0.95833], 920:[0, 0.68611, 0, 0, 0.89444], 923:[0, 0.68611, 0, 0, 0.80555], 926:[0, 0.68611, 0, 0, 0.76666], 928:[0, 0.68611, 0, 0, 0.9], 931:[0, 0.68611, 0, 0, 0.83055], 933:[0, 0.68611, 0, 0, 0.89444], 934:[0, 0.68611, 0, 0, 0.83055], 936:[0, 0.68611, 0, 0, 0.89444], 937:[0, 0.68611, 0, 0, 0.83055], 8211:[0, 0.44444, 0.03194, 0, 0.575], 8212:[0, 0.44444, 0.03194, 
      0, 1.14999], 8216:[0, 0.69444, 0, 0, 0.31944], 8217:[0, 0.69444, 0, 0, 0.31944], 8220:[0, 0.69444, 0, 0, 0.60278], 8221:[0, 0.69444, 0, 0, 0.60278], 8224:[0.19444, 0.69444, 0, 0, 0.51111], 8225:[0.19444, 0.69444, 0, 0, 0.51111], 8242:[0, 0.55556, 0, 0, 0.34444], 8407:[0, 0.72444, 0.15486, 0, 0.575], 8463:[0, 0.69444, 0, 0, 0.66759], 8465:[0, 0.69444, 0, 0, 0.83055], 8467:[0, 0.69444, 0, 0, 0.47361], 8472:[0.19444, 0.44444, 0, 0, 0.74027], 8476:[0, 0.69444, 0, 0, 0.83055], 8501:[0, 0.69444, 
      0, 0, 0.70277], 8592:[-0.10889, 0.39111, 0, 0, 1.14999], 8593:[0.19444, 0.69444, 0, 0, 0.575], 8594:[-0.10889, 0.39111, 0, 0, 1.14999], 8595:[0.19444, 0.69444, 0, 0, 0.575], 8596:[-0.10889, 0.39111, 0, 0, 1.14999], 8597:[0.25, 0.75, 0, 0, 0.575], 8598:[0.19444, 0.69444, 0, 0, 1.14999], 8599:[0.19444, 0.69444, 0, 0, 1.14999], 8600:[0.19444, 0.69444, 0, 0, 1.14999], 8601:[0.19444, 0.69444, 0, 0, 1.14999], 8636:[-0.10889, 0.39111, 0, 0, 1.14999], 8637:[-0.10889, 0.39111, 0, 0, 1.14999], 8640:[-0.10889, 
      0.39111, 0, 0, 1.14999], 8641:[-0.10889, 0.39111, 0, 0, 1.14999], 8656:[-0.10889, 0.39111, 0, 0, 1.14999], 8657:[0.19444, 0.69444, 0, 0, 0.70277], 8658:[-0.10889, 0.39111, 0, 0, 1.14999], 8659:[0.19444, 0.69444, 0, 0, 0.70277], 8660:[-0.10889, 0.39111, 0, 0, 1.14999], 8661:[0.25, 0.75, 0, 0, 0.70277], 8704:[0, 0.69444, 0, 0, 0.63889], 8706:[0, 0.69444, 0.06389, 0, 0.62847], 8707:[0, 0.69444, 0, 0, 0.63889], 8709:[0.05556, 0.75, 0, 0, 0.575], 8711:[0, 0.68611, 0, 0, 0.95833], 8712:[0.08556, 
      0.58556, 0, 0, 0.76666], 8715:[0.08556, 0.58556, 0, 0, 0.76666], 8722:[0.13333, 0.63333, 0, 0, 0.89444], 8723:[0.13333, 0.63333, 0, 0, 0.89444], 8725:[0.25, 0.75, 0, 0, 0.575], 8726:[0.25, 0.75, 0, 0, 0.575], 8727:[-0.02778, 0.47222, 0, 0, 0.575], 8728:[-0.02639, 0.47361, 0, 0, 0.575], 8729:[-0.02639, 0.47361, 0, 0, 0.575], 8730:[0.18, 0.82, 0, 0, 0.95833], 8733:[0, 0.44444, 0, 0, 0.89444], 8734:[0, 0.44444, 0, 0, 1.14999], 8736:[0, 0.69224, 0, 0, 0.72222], 8739:[0.25, 0.75, 0, 0, 0.31944], 
      8741:[0.25, 0.75, 0, 0, 0.575], 8743:[0, 0.55556, 0, 0, 0.76666], 8744:[0, 0.55556, 0, 0, 0.76666], 8745:[0, 0.55556, 0, 0, 0.76666], 8746:[0, 0.55556, 0, 0, 0.76666], 8747:[0.19444, 0.69444, 0.12778, 0, 0.56875], 8764:[-0.10889, 0.39111, 0, 0, 0.89444], 8768:[0.19444, 0.69444, 0, 0, 0.31944], 8771:[0.00222, 0.50222, 0, 0, 0.89444], 8773:[0.027, 0.638, 0, 0, 0.894], 8776:[0.02444, 0.52444, 0, 0, 0.89444], 8781:[0.00222, 0.50222, 0, 0, 0.89444], 8801:[0.00222, 0.50222, 0, 0, 0.89444], 8804:[0.19667, 
      0.69667, 0, 0, 0.89444], 8805:[0.19667, 0.69667, 0, 0, 0.89444], 8810:[0.08556, 0.58556, 0, 0, 1.14999], 8811:[0.08556, 0.58556, 0, 0, 1.14999], 8826:[0.08556, 0.58556, 0, 0, 0.89444], 8827:[0.08556, 0.58556, 0, 0, 0.89444], 8834:[0.08556, 0.58556, 0, 0, 0.89444], 8835:[0.08556, 0.58556, 0, 0, 0.89444], 8838:[0.19667, 0.69667, 0, 0, 0.89444], 8839:[0.19667, 0.69667, 0, 0, 0.89444], 8846:[0, 0.55556, 0, 0, 0.76666], 8849:[0.19667, 0.69667, 0, 0, 0.89444], 8850:[0.19667, 0.69667, 0, 0, 0.89444], 
      8851:[0, 0.55556, 0, 0, 0.76666], 8852:[0, 0.55556, 0, 0, 0.76666], 8853:[0.13333, 0.63333, 0, 0, 0.89444], 8854:[0.13333, 0.63333, 0, 0, 0.89444], 8855:[0.13333, 0.63333, 0, 0, 0.89444], 8856:[0.13333, 0.63333, 0, 0, 0.89444], 8857:[0.13333, 0.63333, 0, 0, 0.89444], 8866:[0, 0.69444, 0, 0, 0.70277], 8867:[0, 0.69444, 0, 0, 0.70277], 8868:[0, 0.69444, 0, 0, 0.89444], 8869:[0, 0.69444, 0, 0, 0.89444], 8900:[-0.02639, 0.47361, 0, 0, 0.575], 8901:[-0.02639, 0.47361, 0, 0, 0.31944], 8902:[-0.02778, 
      0.47222, 0, 0, 0.575], 8968:[0.25, 0.75, 0, 0, 0.51111], 8969:[0.25, 0.75, 0, 0, 0.51111], 8970:[0.25, 0.75, 0, 0, 0.51111], 8971:[0.25, 0.75, 0, 0, 0.51111], 8994:[-0.13889, 0.36111, 0, 0, 1.14999], 8995:[-0.13889, 0.36111, 0, 0, 1.14999], 9651:[0.19444, 0.69444, 0, 0, 1.02222], 9657:[-0.02778, 0.47222, 0, 0, 0.575], 9661:[0.19444, 0.69444, 0, 0, 1.02222], 9667:[-0.02778, 0.47222, 0, 0, 0.575], 9711:[0.19444, 0.69444, 0, 0, 1.14999], 9824:[0.12963, 0.69444, 0, 0, 0.89444], 9825:[0.12963, 0.69444, 
      0, 0, 0.89444], 9826:[0.12963, 0.69444, 0, 0, 0.89444], 9827:[0.12963, 0.69444, 0, 0, 0.89444], 9837:[0, 0.75, 0, 0, 0.44722], 9838:[0.19444, 0.69444, 0, 0, 0.44722], 9839:[0.19444, 0.69444, 0, 0, 0.44722], 10216:[0.25, 0.75, 0, 0, 0.44722], 10217:[0.25, 0.75, 0, 0, 0.44722], 10815:[0, 0.68611, 0, 0, 0.9], 10927:[0.19667, 0.69667, 0, 0, 0.89444], 10928:[0.19667, 0.69667, 0, 0, 0.89444], 57376:[0.19444, 0.69444, 0, 0, 0]}, "Main-BoldItalic":{32:[0, 0, 0, 0, 0.25], 33:[0, 0.69444, 0.11417, 0, 
      0.38611], 34:[0, 0.69444, 0.07939, 0, 0.62055], 35:[0.19444, 0.69444, 0.06833, 0, 0.94444], 37:[0.05556, 0.75, 0.12861, 0, 0.94444], 38:[0, 0.69444, 0.08528, 0, 0.88555], 39:[0, 0.69444, 0.12945, 0, 0.35555], 40:[0.25, 0.75, 0.15806, 0, 0.47333], 41:[0.25, 0.75, 0.03306, 0, 0.47333], 42:[0, 0.75, 0.14333, 0, 0.59111], 43:[0.10333, 0.60333, 0.03306, 0, 0.88555], 44:[0.19444, 0.14722, 0, 0, 0.35555], 45:[0, 0.44444, 0.02611, 0, 0.41444], 46:[0, 0.14722, 0, 0, 0.35555], 47:[0.25, 0.75, 0.15806, 
      0, 0.59111], 48:[0, 0.64444, 0.13167, 0, 0.59111], 49:[0, 0.64444, 0.13167, 0, 0.59111], 50:[0, 0.64444, 0.13167, 0, 0.59111], 51:[0, 0.64444, 0.13167, 0, 0.59111], 52:[0.19444, 0.64444, 0.13167, 0, 0.59111], 53:[0, 0.64444, 0.13167, 0, 0.59111], 54:[0, 0.64444, 0.13167, 0, 0.59111], 55:[0.19444, 0.64444, 0.13167, 0, 0.59111], 56:[0, 0.64444, 0.13167, 0, 0.59111], 57:[0, 0.64444, 0.13167, 0, 0.59111], 58:[0, 0.44444, 0.06695, 0, 0.35555], 59:[0.19444, 0.44444, 0.06695, 0, 0.35555], 61:[-0.10889, 
      0.39111, 0.06833, 0, 0.88555], 63:[0, 0.69444, 0.11472, 0, 0.59111], 64:[0, 0.69444, 0.09208, 0, 0.88555], 65:[0, 0.68611, 0, 0, 0.86555], 66:[0, 0.68611, 0.0992, 0, 0.81666], 67:[0, 0.68611, 0.14208, 0, 0.82666], 68:[0, 0.68611, 0.09062, 0, 0.87555], 69:[0, 0.68611, 0.11431, 0, 0.75666], 70:[0, 0.68611, 0.12903, 0, 0.72722], 71:[0, 0.68611, 0.07347, 0, 0.89527], 72:[0, 0.68611, 0.17208, 0, 0.8961], 73:[0, 0.68611, 0.15681, 0, 0.47166], 74:[0, 0.68611, 0.145, 0, 0.61055], 75:[0, 0.68611, 0.14208, 
      0, 0.89499], 76:[0, 0.68611, 0, 0, 0.69777], 77:[0, 0.68611, 0.17208, 0, 1.07277], 78:[0, 0.68611, 0.17208, 0, 0.8961], 79:[0, 0.68611, 0.09062, 0, 0.85499], 80:[0, 0.68611, 0.0992, 0, 0.78721], 81:[0.19444, 0.68611, 0.09062, 0, 0.85499], 82:[0, 0.68611, 0.02559, 0, 0.85944], 83:[0, 0.68611, 0.11264, 0, 0.64999], 84:[0, 0.68611, 0.12903, 0, 0.7961], 85:[0, 0.68611, 0.17208, 0, 0.88083], 86:[0, 0.68611, 0.18625, 0, 0.86555], 87:[0, 0.68611, 0.18625, 0, 1.15999], 88:[0, 0.68611, 0.15681, 0, 0.86555], 
      89:[0, 0.68611, 0.19803, 0, 0.86555], 90:[0, 0.68611, 0.14208, 0, 0.70888], 91:[0.25, 0.75, 0.1875, 0, 0.35611], 93:[0.25, 0.75, 0.09972, 0, 0.35611], 94:[0, 0.69444, 0.06709, 0, 0.59111], 95:[0.31, 0.13444, 0.09811, 0, 0.59111], 97:[0, 0.44444, 0.09426, 0, 0.59111], 98:[0, 0.69444, 0.07861, 0, 0.53222], 99:[0, 0.44444, 0.05222, 0, 0.53222], 100:[0, 0.69444, 0.10861, 0, 0.59111], 101:[0, 0.44444, 0.085, 0, 0.53222], 102:[0.19444, 0.69444, 0.21778, 0, 0.4], 103:[0.19444, 0.44444, 0.105, 0, 0.53222], 
      104:[0, 0.69444, 0.09426, 0, 0.59111], 105:[0, 0.69326, 0.11387, 0, 0.35555], 106:[0.19444, 0.69326, 0.1672, 0, 0.35555], 107:[0, 0.69444, 0.11111, 0, 0.53222], 108:[0, 0.69444, 0.10861, 0, 0.29666], 109:[0, 0.44444, 0.09426, 0, 0.94444], 110:[0, 0.44444, 0.09426, 0, 0.64999], 111:[0, 0.44444, 0.07861, 0, 0.59111], 112:[0.19444, 0.44444, 0.07861, 0, 0.59111], 113:[0.19444, 0.44444, 0.105, 0, 0.53222], 114:[0, 0.44444, 0.11111, 0, 0.50167], 115:[0, 0.44444, 0.08167, 0, 0.48694], 116:[0, 0.63492, 
      0.09639, 0, 0.385], 117:[0, 0.44444, 0.09426, 0, 0.62055], 118:[0, 0.44444, 0.11111, 0, 0.53222], 119:[0, 0.44444, 0.11111, 0, 0.76777], 120:[0, 0.44444, 0.12583, 0, 0.56055], 121:[0.19444, 0.44444, 0.105, 0, 0.56166], 122:[0, 0.44444, 0.13889, 0, 0.49055], 126:[0.35, 0.34444, 0.11472, 0, 0.59111], 160:[0, 0, 0, 0, 0.25], 168:[0, 0.69444, 0.11473, 0, 0.59111], 176:[0, 0.69444, 0, 0, 0.94888], 184:[0.17014, 0, 0, 0, 0.53222], 198:[0, 0.68611, 0.11431, 0, 1.02277], 216:[0.04861, 0.73472, 0.09062, 
      0, 0.88555], 223:[0.19444, 0.69444, 0.09736, 0, 0.665], 230:[0, 0.44444, 0.085, 0, 0.82666], 248:[0.09722, 0.54167, 0.09458, 0, 0.59111], 305:[0, 0.44444, 0.09426, 0, 0.35555], 338:[0, 0.68611, 0.11431, 0, 1.14054], 339:[0, 0.44444, 0.085, 0, 0.82666], 567:[0.19444, 0.44444, 0.04611, 0, 0.385], 710:[0, 0.69444, 0.06709, 0, 0.59111], 711:[0, 0.63194, 0.08271, 0, 0.59111], 713:[0, 0.59444, 0.10444, 0, 0.59111], 714:[0, 0.69444, 0.08528, 0, 0.59111], 715:[0, 0.69444, 0, 0, 0.59111], 728:[0, 0.69444, 
      0.10333, 0, 0.59111], 729:[0, 0.69444, 0.12945, 0, 0.35555], 730:[0, 0.69444, 0, 0, 0.94888], 732:[0, 0.69444, 0.11472, 0, 0.59111], 733:[0, 0.69444, 0.11472, 0, 0.59111], 915:[0, 0.68611, 0.12903, 0, 0.69777], 916:[0, 0.68611, 0, 0, 0.94444], 920:[0, 0.68611, 0.09062, 0, 0.88555], 923:[0, 0.68611, 0, 0, 0.80666], 926:[0, 0.68611, 0.15092, 0, 0.76777], 928:[0, 0.68611, 0.17208, 0, 0.8961], 931:[0, 0.68611, 0.11431, 0, 0.82666], 933:[0, 0.68611, 0.10778, 0, 0.88555], 934:[0, 0.68611, 0.05632, 
      0, 0.82666], 936:[0, 0.68611, 0.10778, 0, 0.88555], 937:[0, 0.68611, 0.0992, 0, 0.82666], 8211:[0, 0.44444, 0.09811, 0, 0.59111], 8212:[0, 0.44444, 0.09811, 0, 1.18221], 8216:[0, 0.69444, 0.12945, 0, 0.35555], 8217:[0, 0.69444, 0.12945, 0, 0.35555], 8220:[0, 0.69444, 0.16772, 0, 0.62055], 8221:[0, 0.69444, 0.07939, 0, 0.62055]}, "Main-Italic":{32:[0, 0, 0, 0, 0.25], 33:[0, 0.69444, 0.12417, 0, 0.30667], 34:[0, 0.69444, 0.06961, 0, 0.51444], 35:[0.19444, 0.69444, 0.06616, 0, 0.81777], 37:[0.05556, 
      0.75, 0.13639, 0, 0.81777], 38:[0, 0.69444, 0.09694, 0, 0.76666], 39:[0, 0.69444, 0.12417, 0, 0.30667], 40:[0.25, 0.75, 0.16194, 0, 0.40889], 41:[0.25, 0.75, 0.03694, 0, 0.40889], 42:[0, 0.75, 0.14917, 0, 0.51111], 43:[0.05667, 0.56167, 0.03694, 0, 0.76666], 44:[0.19444, 0.10556, 0, 0, 0.30667], 45:[0, 0.43056, 0.02826, 0, 0.35778], 46:[0, 0.10556, 0, 0, 0.30667], 47:[0.25, 0.75, 0.16194, 0, 0.51111], 48:[0, 0.64444, 0.13556, 0, 0.51111], 49:[0, 0.64444, 0.13556, 0, 0.51111], 50:[0, 0.64444, 
      0.13556, 0, 0.51111], 51:[0, 0.64444, 0.13556, 0, 0.51111], 52:[0.19444, 0.64444, 0.13556, 0, 0.51111], 53:[0, 0.64444, 0.13556, 0, 0.51111], 54:[0, 0.64444, 0.13556, 0, 0.51111], 55:[0.19444, 0.64444, 0.13556, 0, 0.51111], 56:[0, 0.64444, 0.13556, 0, 0.51111], 57:[0, 0.64444, 0.13556, 0, 0.51111], 58:[0, 0.43056, 0.0582, 0, 0.30667], 59:[0.19444, 0.43056, 0.0582, 0, 0.30667], 61:[-0.13313, 0.36687, 0.06616, 0, 0.76666], 63:[0, 0.69444, 0.1225, 0, 0.51111], 64:[0, 0.69444, 0.09597, 0, 0.76666], 
      65:[0, 0.68333, 0, 0, 0.74333], 66:[0, 0.68333, 0.10257, 0, 0.70389], 67:[0, 0.68333, 0.14528, 0, 0.71555], 68:[0, 0.68333, 0.09403, 0, 0.755], 69:[0, 0.68333, 0.12028, 0, 0.67833], 70:[0, 0.68333, 0.13305, 0, 0.65277], 71:[0, 0.68333, 0.08722, 0, 0.77361], 72:[0, 0.68333, 0.16389, 0, 0.74333], 73:[0, 0.68333, 0.15806, 0, 0.38555], 74:[0, 0.68333, 0.14028, 0, 0.525], 75:[0, 0.68333, 0.14528, 0, 0.76888], 76:[0, 0.68333, 0, 0, 0.62722], 77:[0, 0.68333, 0.16389, 0, 0.89666], 78:[0, 0.68333, 0.16389, 
      0, 0.74333], 79:[0, 0.68333, 0.09403, 0, 0.76666], 80:[0, 0.68333, 0.10257, 0, 0.67833], 81:[0.19444, 0.68333, 0.09403, 0, 0.76666], 82:[0, 0.68333, 0.03868, 0, 0.72944], 83:[0, 0.68333, 0.11972, 0, 0.56222], 84:[0, 0.68333, 0.13305, 0, 0.71555], 85:[0, 0.68333, 0.16389, 0, 0.74333], 86:[0, 0.68333, 0.18361, 0, 0.74333], 87:[0, 0.68333, 0.18361, 0, 0.99888], 88:[0, 0.68333, 0.15806, 0, 0.74333], 89:[0, 0.68333, 0.19383, 0, 0.74333], 90:[0, 0.68333, 0.14528, 0, 0.61333], 91:[0.25, 0.75, 0.1875, 
      0, 0.30667], 93:[0.25, 0.75, 0.10528, 0, 0.30667], 94:[0, 0.69444, 0.06646, 0, 0.51111], 95:[0.31, 0.12056, 0.09208, 0, 0.51111], 97:[0, 0.43056, 0.07671, 0, 0.51111], 98:[0, 0.69444, 0.06312, 0, 0.46], 99:[0, 0.43056, 0.05653, 0, 0.46], 100:[0, 0.69444, 0.10333, 0, 0.51111], 101:[0, 0.43056, 0.07514, 0, 0.46], 102:[0.19444, 0.69444, 0.21194, 0, 0.30667], 103:[0.19444, 0.43056, 0.08847, 0, 0.46], 104:[0, 0.69444, 0.07671, 0, 0.51111], 105:[0, 0.65536, 0.1019, 0, 0.30667], 106:[0.19444, 0.65536, 
      0.14467, 0, 0.30667], 107:[0, 0.69444, 0.10764, 0, 0.46], 108:[0, 0.69444, 0.10333, 0, 0.25555], 109:[0, 0.43056, 0.07671, 0, 0.81777], 110:[0, 0.43056, 0.07671, 0, 0.56222], 111:[0, 0.43056, 0.06312, 0, 0.51111], 112:[0.19444, 0.43056, 0.06312, 0, 0.51111], 113:[0.19444, 0.43056, 0.08847, 0, 0.46], 114:[0, 0.43056, 0.10764, 0, 0.42166], 115:[0, 0.43056, 0.08208, 0, 0.40889], 116:[0, 0.61508, 0.09486, 0, 0.33222], 117:[0, 0.43056, 0.07671, 0, 0.53666], 118:[0, 0.43056, 0.10764, 0, 0.46], 119:[0, 
      0.43056, 0.10764, 0, 0.66444], 120:[0, 0.43056, 0.12042, 0, 0.46389], 121:[0.19444, 0.43056, 0.08847, 0, 0.48555], 122:[0, 0.43056, 0.12292, 0, 0.40889], 126:[0.35, 0.31786, 0.11585, 0, 0.51111], 160:[0, 0, 0, 0, 0.25], 168:[0, 0.66786, 0.10474, 0, 0.51111], 176:[0, 0.69444, 0, 0, 0.83129], 184:[0.17014, 0, 0, 0, 0.46], 198:[0, 0.68333, 0.12028, 0, 0.88277], 216:[0.04861, 0.73194, 0.09403, 0, 0.76666], 223:[0.19444, 0.69444, 0.10514, 0, 0.53666], 230:[0, 0.43056, 0.07514, 0, 0.71555], 248:[0.09722, 
      0.52778, 0.09194, 0, 0.51111], 338:[0, 0.68333, 0.12028, 0, 0.98499], 339:[0, 0.43056, 0.07514, 0, 0.71555], 710:[0, 0.69444, 0.06646, 0, 0.51111], 711:[0, 0.62847, 0.08295, 0, 0.51111], 713:[0, 0.56167, 0.10333, 0, 0.51111], 714:[0, 0.69444, 0.09694, 0, 0.51111], 715:[0, 0.69444, 0, 0, 0.51111], 728:[0, 0.69444, 0.10806, 0, 0.51111], 729:[0, 0.66786, 0.11752, 0, 0.30667], 730:[0, 0.69444, 0, 0, 0.83129], 732:[0, 0.66786, 0.11585, 0, 0.51111], 733:[0, 0.69444, 0.1225, 0, 0.51111], 915:[0, 0.68333, 
      0.13305, 0, 0.62722], 916:[0, 0.68333, 0, 0, 0.81777], 920:[0, 0.68333, 0.09403, 0, 0.76666], 923:[0, 0.68333, 0, 0, 0.69222], 926:[0, 0.68333, 0.15294, 0, 0.66444], 928:[0, 0.68333, 0.16389, 0, 0.74333], 931:[0, 0.68333, 0.12028, 0, 0.71555], 933:[0, 0.68333, 0.11111, 0, 0.76666], 934:[0, 0.68333, 0.05986, 0, 0.71555], 936:[0, 0.68333, 0.11111, 0, 0.76666], 937:[0, 0.68333, 0.10257, 0, 0.71555], 8211:[0, 0.43056, 0.09208, 0, 0.51111], 8212:[0, 0.43056, 0.09208, 0, 1.02222], 8216:[0, 0.69444, 
      0.12417, 0, 0.30667], 8217:[0, 0.69444, 0.12417, 0, 0.30667], 8220:[0, 0.69444, 0.1685, 0, 0.51444], 8221:[0, 0.69444, 0.06961, 0, 0.51444], 8463:[0, 0.68889, 0, 0, 0.54028]}, "Main-Regular":{32:[0, 0, 0, 0, 0.25], 33:[0, 0.69444, 0, 0, 0.27778], 34:[0, 0.69444, 0, 0, 0.5], 35:[0.19444, 0.69444, 0, 0, 0.83334], 36:[0.05556, 0.75, 0, 0, 0.5], 37:[0.05556, 0.75, 0, 0, 0.83334], 38:[0, 0.69444, 0, 0, 0.77778], 39:[0, 0.69444, 0, 0, 0.27778], 40:[0.25, 0.75, 0, 0, 0.38889], 41:[0.25, 0.75, 0, 0, 
      0.38889], 42:[0, 0.75, 0, 0, 0.5], 43:[0.08333, 0.58333, 0, 0, 0.77778], 44:[0.19444, 0.10556, 0, 0, 0.27778], 45:[0, 0.43056, 0, 0, 0.33333], 46:[0, 0.10556, 0, 0, 0.27778], 47:[0.25, 0.75, 0, 0, 0.5], 48:[0, 0.64444, 0, 0, 0.5], 49:[0, 0.64444, 0, 0, 0.5], 50:[0, 0.64444, 0, 0, 0.5], 51:[0, 0.64444, 0, 0, 0.5], 52:[0, 0.64444, 0, 0, 0.5], 53:[0, 0.64444, 0, 0, 0.5], 54:[0, 0.64444, 0, 0, 0.5], 55:[0, 0.64444, 0, 0, 0.5], 56:[0, 0.64444, 0, 0, 0.5], 57:[0, 0.64444, 0, 0, 0.5], 58:[0, 0.43056, 
      0, 0, 0.27778], 59:[0.19444, 0.43056, 0, 0, 0.27778], 60:[0.0391, 0.5391, 0, 0, 0.77778], 61:[-0.13313, 0.36687, 0, 0, 0.77778], 62:[0.0391, 0.5391, 0, 0, 0.77778], 63:[0, 0.69444, 0, 0, 0.47222], 64:[0, 0.69444, 0, 0, 0.77778], 65:[0, 0.68333, 0, 0, 0.75], 66:[0, 0.68333, 0, 0, 0.70834], 67:[0, 0.68333, 0, 0, 0.72222], 68:[0, 0.68333, 0, 0, 0.76389], 69:[0, 0.68333, 0, 0, 0.68056], 70:[0, 0.68333, 0, 0, 0.65278], 71:[0, 0.68333, 0, 0, 0.78472], 72:[0, 0.68333, 0, 0, 0.75], 73:[0, 0.68333, 
      0, 0, 0.36111], 74:[0, 0.68333, 0, 0, 0.51389], 75:[0, 0.68333, 0, 0, 0.77778], 76:[0, 0.68333, 0, 0, 0.625], 77:[0, 0.68333, 0, 0, 0.91667], 78:[0, 0.68333, 0, 0, 0.75], 79:[0, 0.68333, 0, 0, 0.77778], 80:[0, 0.68333, 0, 0, 0.68056], 81:[0.19444, 0.68333, 0, 0, 0.77778], 82:[0, 0.68333, 0, 0, 0.73611], 83:[0, 0.68333, 0, 0, 0.55556], 84:[0, 0.68333, 0, 0, 0.72222], 85:[0, 0.68333, 0, 0, 0.75], 86:[0, 0.68333, 0.01389, 0, 0.75], 87:[0, 0.68333, 0.01389, 0, 1.02778], 88:[0, 0.68333, 0, 0, 0.75], 
      89:[0, 0.68333, 0.025, 0, 0.75], 90:[0, 0.68333, 0, 0, 0.61111], 91:[0.25, 0.75, 0, 0, 0.27778], 92:[0.25, 0.75, 0, 0, 0.5], 93:[0.25, 0.75, 0, 0, 0.27778], 94:[0, 0.69444, 0, 0, 0.5], 95:[0.31, 0.12056, 0.02778, 0, 0.5], 97:[0, 0.43056, 0, 0, 0.5], 98:[0, 0.69444, 0, 0, 0.55556], 99:[0, 0.43056, 0, 0, 0.44445], 100:[0, 0.69444, 0, 0, 0.55556], 101:[0, 0.43056, 0, 0, 0.44445], 102:[0, 0.69444, 0.07778, 0, 0.30556], 103:[0.19444, 0.43056, 0.01389, 0, 0.5], 104:[0, 0.69444, 0, 0, 0.55556], 105:[0, 
      0.66786, 0, 0, 0.27778], 106:[0.19444, 0.66786, 0, 0, 0.30556], 107:[0, 0.69444, 0, 0, 0.52778], 108:[0, 0.69444, 0, 0, 0.27778], 109:[0, 0.43056, 0, 0, 0.83334], 110:[0, 0.43056, 0, 0, 0.55556], 111:[0, 0.43056, 0, 0, 0.5], 112:[0.19444, 0.43056, 0, 0, 0.55556], 113:[0.19444, 0.43056, 0, 0, 0.52778], 114:[0, 0.43056, 0, 0, 0.39167], 115:[0, 0.43056, 0, 0, 0.39445], 116:[0, 0.61508, 0, 0, 0.38889], 117:[0, 0.43056, 0, 0, 0.55556], 118:[0, 0.43056, 0.01389, 0, 0.52778], 119:[0, 0.43056, 0.01389, 
      0, 0.72222], 120:[0, 0.43056, 0, 0, 0.52778], 121:[0.19444, 0.43056, 0.01389, 0, 0.52778], 122:[0, 0.43056, 0, 0, 0.44445], 123:[0.25, 0.75, 0, 0, 0.5], 124:[0.25, 0.75, 0, 0, 0.27778], 125:[0.25, 0.75, 0, 0, 0.5], 126:[0.35, 0.31786, 0, 0, 0.5], 160:[0, 0, 0, 0, 0.25], 163:[0, 0.69444, 0, 0, 0.76909], 167:[0.19444, 0.69444, 0, 0, 0.44445], 168:[0, 0.66786, 0, 0, 0.5], 172:[0, 0.43056, 0, 0, 0.66667], 176:[0, 0.69444, 0, 0, 0.75], 177:[0.08333, 0.58333, 0, 0, 0.77778], 182:[0.19444, 0.69444, 
      0, 0, 0.61111], 184:[0.17014, 0, 0, 0, 0.44445], 198:[0, 0.68333, 0, 0, 0.90278], 215:[0.08333, 0.58333, 0, 0, 0.77778], 216:[0.04861, 0.73194, 0, 0, 0.77778], 223:[0, 0.69444, 0, 0, 0.5], 230:[0, 0.43056, 0, 0, 0.72222], 247:[0.08333, 0.58333, 0, 0, 0.77778], 248:[0.09722, 0.52778, 0, 0, 0.5], 305:[0, 0.43056, 0, 0, 0.27778], 338:[0, 0.68333, 0, 0, 1.01389], 339:[0, 0.43056, 0, 0, 0.77778], 567:[0.19444, 0.43056, 0, 0, 0.30556], 710:[0, 0.69444, 0, 0, 0.5], 711:[0, 0.62847, 0, 0, 0.5], 713:[0, 
      0.56778, 0, 0, 0.5], 714:[0, 0.69444, 0, 0, 0.5], 715:[0, 0.69444, 0, 0, 0.5], 728:[0, 0.69444, 0, 0, 0.5], 729:[0, 0.66786, 0, 0, 0.27778], 730:[0, 0.69444, 0, 0, 0.75], 732:[0, 0.66786, 0, 0, 0.5], 733:[0, 0.69444, 0, 0, 0.5], 915:[0, 0.68333, 0, 0, 0.625], 916:[0, 0.68333, 0, 0, 0.83334], 920:[0, 0.68333, 0, 0, 0.77778], 923:[0, 0.68333, 0, 0, 0.69445], 926:[0, 0.68333, 0, 0, 0.66667], 928:[0, 0.68333, 0, 0, 0.75], 931:[0, 0.68333, 0, 0, 0.72222], 933:[0, 0.68333, 0, 0, 0.77778], 934:[0, 
      0.68333, 0, 0, 0.72222], 936:[0, 0.68333, 0, 0, 0.77778], 937:[0, 0.68333, 0, 0, 0.72222], 8211:[0, 0.43056, 0.02778, 0, 0.5], 8212:[0, 0.43056, 0.02778, 0, 1.0], 8216:[0, 0.69444, 0, 0, 0.27778], 8217:[0, 0.69444, 0, 0, 0.27778], 8220:[0, 0.69444, 0, 0, 0.5], 8221:[0, 0.69444, 0, 0, 0.5], 8224:[0.19444, 0.69444, 0, 0, 0.44445], 8225:[0.19444, 0.69444, 0, 0, 0.44445], 8230:[0, 0.123, 0, 0, 1.172], 8242:[0, 0.55556, 0, 0, 0.275], 8407:[0, 0.71444, 0.15382, 0, 0.5], 8463:[0, 0.68889, 0, 0, 0.54028], 
      8465:[0, 0.69444, 0, 0, 0.72222], 8467:[0, 0.69444, 0, 0.11111, 0.41667], 8472:[0.19444, 0.43056, 0, 0.11111, 0.63646], 8476:[0, 0.69444, 0, 0, 0.72222], 8501:[0, 0.69444, 0, 0, 0.61111], 8592:[-0.13313, 0.36687, 0, 0, 1.0], 8593:[0.19444, 0.69444, 0, 0, 0.5], 8594:[-0.13313, 0.36687, 0, 0, 1.0], 8595:[0.19444, 0.69444, 0, 0, 0.5], 8596:[-0.13313, 0.36687, 0, 0, 1.0], 8597:[0.25, 0.75, 0, 0, 0.5], 8598:[0.19444, 0.69444, 0, 0, 1.0], 8599:[0.19444, 0.69444, 0, 0, 1.0], 8600:[0.19444, 0.69444, 
      0, 0, 1.0], 8601:[0.19444, 0.69444, 0, 0, 1.0], 8614:[0.011, 0.511, 0, 0, 1.0], 8617:[0.011, 0.511, 0, 0, 1.126], 8618:[0.011, 0.511, 0, 0, 1.126], 8636:[-0.13313, 0.36687, 0, 0, 1.0], 8637:[-0.13313, 0.36687, 0, 0, 1.0], 8640:[-0.13313, 0.36687, 0, 0, 1.0], 8641:[-0.13313, 0.36687, 0, 0, 1.0], 8652:[0.011, 0.671, 0, 0, 1.0], 8656:[-0.13313, 0.36687, 0, 0, 1.0], 8657:[0.19444, 0.69444, 0, 0, 0.61111], 8658:[-0.13313, 0.36687, 0, 0, 1.0], 8659:[0.19444, 0.69444, 0, 0, 0.61111], 8660:[-0.13313, 
      0.36687, 0, 0, 1.0], 8661:[0.25, 0.75, 0, 0, 0.61111], 8704:[0, 0.69444, 0, 0, 0.55556], 8706:[0, 0.69444, 0.05556, 0.08334, 0.5309], 8707:[0, 0.69444, 0, 0, 0.55556], 8709:[0.05556, 0.75, 0, 0, 0.5], 8711:[0, 0.68333, 0, 0, 0.83334], 8712:[0.0391, 0.5391, 0, 0, 0.66667], 8715:[0.0391, 0.5391, 0, 0, 0.66667], 8722:[0.08333, 0.58333, 0, 0, 0.77778], 8723:[0.08333, 0.58333, 0, 0, 0.77778], 8725:[0.25, 0.75, 0, 0, 0.5], 8726:[0.25, 0.75, 0, 0, 0.5], 8727:[-0.03472, 0.46528, 0, 0, 0.5], 8728:[-0.05555, 
      0.44445, 0, 0, 0.5], 8729:[-0.05555, 0.44445, 0, 0, 0.5], 8730:[0.2, 0.8, 0, 0, 0.83334], 8733:[0, 0.43056, 0, 0, 0.77778], 8734:[0, 0.43056, 0, 0, 1.0], 8736:[0, 0.69224, 0, 0, 0.72222], 8739:[0.25, 0.75, 0, 0, 0.27778], 8741:[0.25, 0.75, 0, 0, 0.5], 8743:[0, 0.55556, 0, 0, 0.66667], 8744:[0, 0.55556, 0, 0, 0.66667], 8745:[0, 0.55556, 0, 0, 0.66667], 8746:[0, 0.55556, 0, 0, 0.66667], 8747:[0.19444, 0.69444, 0.11111, 0, 0.41667], 8764:[-0.13313, 0.36687, 0, 0, 0.77778], 8768:[0.19444, 0.69444, 
      0, 0, 0.27778], 8771:[-0.03625, 0.46375, 0, 0, 0.77778], 8773:[-0.022, 0.589, 0, 0, 0.778], 8776:[-0.01688, 0.48312, 0, 0, 0.77778], 8781:[-0.03625, 0.46375, 0, 0, 0.77778], 8784:[-0.133, 0.673, 0, 0, 0.778], 8801:[-0.03625, 0.46375, 0, 0, 0.77778], 8804:[0.13597, 0.63597, 0, 0, 0.77778], 8805:[0.13597, 0.63597, 0, 0, 0.77778], 8810:[0.0391, 0.5391, 0, 0, 1.0], 8811:[0.0391, 0.5391, 0, 0, 1.0], 8826:[0.0391, 0.5391, 0, 0, 0.77778], 8827:[0.0391, 0.5391, 0, 0, 0.77778], 8834:[0.0391, 0.5391, 
      0, 0, 0.77778], 8835:[0.0391, 0.5391, 0, 0, 0.77778], 8838:[0.13597, 0.63597, 0, 0, 0.77778], 8839:[0.13597, 0.63597, 0, 0, 0.77778], 8846:[0, 0.55556, 0, 0, 0.66667], 8849:[0.13597, 0.63597, 0, 0, 0.77778], 8850:[0.13597, 0.63597, 0, 0, 0.77778], 8851:[0, 0.55556, 0, 0, 0.66667], 8852:[0, 0.55556, 0, 0, 0.66667], 8853:[0.08333, 0.58333, 0, 0, 0.77778], 8854:[0.08333, 0.58333, 0, 0, 0.77778], 8855:[0.08333, 0.58333, 0, 0, 0.77778], 8856:[0.08333, 0.58333, 0, 0, 0.77778], 8857:[0.08333, 0.58333, 
      0, 0, 0.77778], 8866:[0, 0.69444, 0, 0, 0.61111], 8867:[0, 0.69444, 0, 0, 0.61111], 8868:[0, 0.69444, 0, 0, 0.77778], 8869:[0, 0.69444, 0, 0, 0.77778], 8872:[0.249, 0.75, 0, 0, 0.867], 8900:[-0.05555, 0.44445, 0, 0, 0.5], 8901:[-0.05555, 0.44445, 0, 0, 0.27778], 8902:[-0.03472, 0.46528, 0, 0, 0.5], 8904:[0.005, 0.505, 0, 0, 0.9], 8942:[0.03, 0.903, 0, 0, 0.278], 8943:[-0.19, 0.313, 0, 0, 1.172], 8945:[-0.1, 0.823, 0, 0, 1.282], 8968:[0.25, 0.75, 0, 0, 0.44445], 8969:[0.25, 0.75, 0, 0, 0.44445], 
      8970:[0.25, 0.75, 0, 0, 0.44445], 8971:[0.25, 0.75, 0, 0, 0.44445], 8994:[-0.14236, 0.35764, 0, 0, 1.0], 8995:[-0.14236, 0.35764, 0, 0, 1.0], 9136:[0.244, 0.744, 0, 0, 0.412], 9137:[0.244, 0.745, 0, 0, 0.412], 9651:[0.19444, 0.69444, 0, 0, 0.88889], 9657:[-0.03472, 0.46528, 0, 0, 0.5], 9661:[0.19444, 0.69444, 0, 0, 0.88889], 9667:[-0.03472, 0.46528, 0, 0, 0.5], 9711:[0.19444, 0.69444, 0, 0, 1.0], 9824:[0.12963, 0.69444, 0, 0, 0.77778], 9825:[0.12963, 0.69444, 0, 0, 0.77778], 9826:[0.12963, 
      0.69444, 0, 0, 0.77778], 9827:[0.12963, 0.69444, 0, 0, 0.77778], 9837:[0, 0.75, 0, 0, 0.38889], 9838:[0.19444, 0.69444, 0, 0, 0.38889], 9839:[0.19444, 0.69444, 0, 0, 0.38889], 10216:[0.25, 0.75, 0, 0, 0.38889], 10217:[0.25, 0.75, 0, 0, 0.38889], 10222:[0.244, 0.744, 0, 0, 0.412], 10223:[0.244, 0.745, 0, 0, 0.412], 10229:[0.011, 0.511, 0, 0, 1.609], 10230:[0.011, 0.511, 0, 0, 1.638], 10231:[0.011, 0.511, 0, 0, 1.859], 10232:[0.024, 0.525, 0, 0, 1.609], 10233:[0.024, 0.525, 0, 0, 1.638], 10234:[0.024, 
      0.525, 0, 0, 1.858], 10236:[0.011, 0.511, 0, 0, 1.638], 10815:[0, 0.68333, 0, 0, 0.75], 10927:[0.13597, 0.63597, 0, 0, 0.77778], 10928:[0.13597, 0.63597, 0, 0, 0.77778], 57376:[0.19444, 0.69444, 0, 0, 0]}, "Math-BoldItalic":{32:[0, 0, 0, 0, 0.25], 48:[0, 0.44444, 0, 0, 0.575], 49:[0, 0.44444, 0, 0, 0.575], 50:[0, 0.44444, 0, 0, 0.575], 51:[0.19444, 0.44444, 0, 0, 0.575], 52:[0.19444, 0.44444, 0, 0, 0.575], 53:[0.19444, 0.44444, 0, 0, 0.575], 54:[0, 0.64444, 0, 0, 0.575], 55:[0.19444, 0.44444, 
      0, 0, 0.575], 56:[0, 0.64444, 0, 0, 0.575], 57:[0.19444, 0.44444, 0, 0, 0.575], 65:[0, 0.68611, 0, 0, 0.86944], 66:[0, 0.68611, 0.04835, 0, 0.8664], 67:[0, 0.68611, 0.06979, 0, 0.81694], 68:[0, 0.68611, 0.03194, 0, 0.93812], 69:[0, 0.68611, 0.05451, 0, 0.81007], 70:[0, 0.68611, 0.15972, 0, 0.68889], 71:[0, 0.68611, 0, 0, 0.88673], 72:[0, 0.68611, 0.08229, 0, 0.98229], 73:[0, 0.68611, 0.07778, 0, 0.51111], 74:[0, 0.68611, 0.10069, 0, 0.63125], 75:[0, 0.68611, 0.06979, 0, 0.97118], 76:[0, 0.68611, 
      0, 0, 0.75555], 77:[0, 0.68611, 0.11424, 0, 1.14201], 78:[0, 0.68611, 0.11424, 0, 0.95034], 79:[0, 0.68611, 0.03194, 0, 0.83666], 80:[0, 0.68611, 0.15972, 0, 0.72309], 81:[0.19444, 0.68611, 0, 0, 0.86861], 82:[0, 0.68611, 0.00421, 0, 0.87235], 83:[0, 0.68611, 0.05382, 0, 0.69271], 84:[0, 0.68611, 0.15972, 0, 0.63663], 85:[0, 0.68611, 0.11424, 0, 0.80027], 86:[0, 0.68611, 0.25555, 0, 0.67778], 87:[0, 0.68611, 0.15972, 0, 1.09305], 88:[0, 0.68611, 0.07778, 0, 0.94722], 89:[0, 0.68611, 0.25555, 
      0, 0.67458], 90:[0, 0.68611, 0.06979, 0, 0.77257], 97:[0, 0.44444, 0, 0, 0.63287], 98:[0, 0.69444, 0, 0, 0.52083], 99:[0, 0.44444, 0, 0, 0.51342], 100:[0, 0.69444, 0, 0, 0.60972], 101:[0, 0.44444, 0, 0, 0.55361], 102:[0.19444, 0.69444, 0.11042, 0, 0.56806], 103:[0.19444, 0.44444, 0.03704, 0, 0.5449], 104:[0, 0.69444, 0, 0, 0.66759], 105:[0, 0.69326, 0, 0, 0.4048], 106:[0.19444, 0.69326, 0.0622, 0, 0.47083], 107:[0, 0.69444, 0.01852, 0, 0.6037], 108:[0, 0.69444, 0.0088, 0, 0.34815], 109:[0, 
      0.44444, 0, 0, 1.0324], 110:[0, 0.44444, 0, 0, 0.71296], 111:[0, 0.44444, 0, 0, 0.58472], 112:[0.19444, 0.44444, 0, 0, 0.60092], 113:[0.19444, 0.44444, 0.03704, 0, 0.54213], 114:[0, 0.44444, 0.03194, 0, 0.5287], 115:[0, 0.44444, 0, 0, 0.53125], 116:[0, 0.63492, 0, 0, 0.41528], 117:[0, 0.44444, 0, 0, 0.68102], 118:[0, 0.44444, 0.03704, 0, 0.56666], 119:[0, 0.44444, 0.02778, 0, 0.83148], 120:[0, 0.44444, 0, 0, 0.65903], 121:[0.19444, 0.44444, 0.03704, 0, 0.59028], 122:[0, 0.44444, 0.04213, 0, 
      0.55509], 160:[0, 0, 0, 0, 0.25], 915:[0, 0.68611, 0.15972, 0, 0.65694], 916:[0, 0.68611, 0, 0, 0.95833], 920:[0, 0.68611, 0.03194, 0, 0.86722], 923:[0, 0.68611, 0, 0, 0.80555], 926:[0, 0.68611, 0.07458, 0, 0.84125], 928:[0, 0.68611, 0.08229, 0, 0.98229], 931:[0, 0.68611, 0.05451, 0, 0.88507], 933:[0, 0.68611, 0.15972, 0, 0.67083], 934:[0, 0.68611, 0, 0, 0.76666], 936:[0, 0.68611, 0.11653, 0, 0.71402], 937:[0, 0.68611, 0.04835, 0, 0.8789], 945:[0, 0.44444, 0, 0, 0.76064], 946:[0.19444, 0.69444, 
      0.03403, 0, 0.65972], 947:[0.19444, 0.44444, 0.06389, 0, 0.59003], 948:[0, 0.69444, 0.03819, 0, 0.52222], 949:[0, 0.44444, 0, 0, 0.52882], 950:[0.19444, 0.69444, 0.06215, 0, 0.50833], 951:[0.19444, 0.44444, 0.03704, 0, 0.6], 952:[0, 0.69444, 0.03194, 0, 0.5618], 953:[0, 0.44444, 0, 0, 0.41204], 954:[0, 0.44444, 0, 0, 0.66759], 955:[0, 0.69444, 0, 0, 0.67083], 956:[0.19444, 0.44444, 0, 0, 0.70787], 957:[0, 0.44444, 0.06898, 0, 0.57685], 958:[0.19444, 0.69444, 0.03021, 0, 0.50833], 959:[0, 0.44444, 
      0, 0, 0.58472], 960:[0, 0.44444, 0.03704, 0, 0.68241], 961:[0.19444, 0.44444, 0, 0, 0.6118], 962:[0.09722, 0.44444, 0.07917, 0, 0.42361], 963:[0, 0.44444, 0.03704, 0, 0.68588], 964:[0, 0.44444, 0.13472, 0, 0.52083], 965:[0, 0.44444, 0.03704, 0, 0.63055], 966:[0.19444, 0.44444, 0, 0, 0.74722], 967:[0.19444, 0.44444, 0, 0, 0.71805], 968:[0.19444, 0.69444, 0.03704, 0, 0.75833], 969:[0, 0.44444, 0.03704, 0, 0.71782], 977:[0, 0.69444, 0, 0, 0.69155], 981:[0.19444, 0.69444, 0, 0, 0.7125], 982:[0, 
      0.44444, 0.03194, 0, 0.975], 1009:[0.19444, 0.44444, 0, 0, 0.6118], 1013:[0, 0.44444, 0, 0, 0.48333], 57649:[0, 0.44444, 0, 0, 0.39352], 57911:[0.19444, 0.44444, 0, 0, 0.43889]}, "Math-Italic":{32:[0, 0, 0, 0, 0.25], 48:[0, 0.43056, 0, 0, 0.5], 49:[0, 0.43056, 0, 0, 0.5], 50:[0, 0.43056, 0, 0, 0.5], 51:[0.19444, 0.43056, 0, 0, 0.5], 52:[0.19444, 0.43056, 0, 0, 0.5], 53:[0.19444, 0.43056, 0, 0, 0.5], 54:[0, 0.64444, 0, 0, 0.5], 55:[0.19444, 0.43056, 0, 0, 0.5], 56:[0, 0.64444, 0, 0, 0.5], 57:[0.19444, 
      0.43056, 0, 0, 0.5], 65:[0, 0.68333, 0, 0.13889, 0.75], 66:[0, 0.68333, 0.05017, 0.08334, 0.75851], 67:[0, 0.68333, 0.07153, 0.08334, 0.71472], 68:[0, 0.68333, 0.02778, 0.05556, 0.82792], 69:[0, 0.68333, 0.05764, 0.08334, 0.7382], 70:[0, 0.68333, 0.13889, 0.08334, 0.64306], 71:[0, 0.68333, 0, 0.08334, 0.78625], 72:[0, 0.68333, 0.08125, 0.05556, 0.83125], 73:[0, 0.68333, 0.07847, 0.11111, 0.43958], 74:[0, 0.68333, 0.09618, 0.16667, 0.55451], 75:[0, 0.68333, 0.07153, 0.05556, 0.84931], 76:[0, 
      0.68333, 0, 0.02778, 0.68056], 77:[0, 0.68333, 0.10903, 0.08334, 0.97014], 78:[0, 0.68333, 0.10903, 0.08334, 0.80347], 79:[0, 0.68333, 0.02778, 0.08334, 0.76278], 80:[0, 0.68333, 0.13889, 0.08334, 0.64201], 81:[0.19444, 0.68333, 0, 0.08334, 0.79056], 82:[0, 0.68333, 0.00773, 0.08334, 0.75929], 83:[0, 0.68333, 0.05764, 0.08334, 0.6132], 84:[0, 0.68333, 0.13889, 0.08334, 0.58438], 85:[0, 0.68333, 0.10903, 0.02778, 0.68278], 86:[0, 0.68333, 0.22222, 0, 0.58333], 87:[0, 0.68333, 0.13889, 0, 0.94445], 
      88:[0, 0.68333, 0.07847, 0.08334, 0.82847], 89:[0, 0.68333, 0.22222, 0, 0.58056], 90:[0, 0.68333, 0.07153, 0.08334, 0.68264], 97:[0, 0.43056, 0, 0, 0.52859], 98:[0, 0.69444, 0, 0, 0.42917], 99:[0, 0.43056, 0, 0.05556, 0.43276], 100:[0, 0.69444, 0, 0.16667, 0.52049], 101:[0, 0.43056, 0, 0.05556, 0.46563], 102:[0.19444, 0.69444, 0.10764, 0.16667, 0.48959], 103:[0.19444, 0.43056, 0.03588, 0.02778, 0.47697], 104:[0, 0.69444, 0, 0, 0.57616], 105:[0, 0.65952, 0, 0, 0.34451], 106:[0.19444, 0.65952, 
      0.05724, 0, 0.41181], 107:[0, 0.69444, 0.03148, 0, 0.5206], 108:[0, 0.69444, 0.01968, 0.08334, 0.29838], 109:[0, 0.43056, 0, 0, 0.87801], 110:[0, 0.43056, 0, 0, 0.60023], 111:[0, 0.43056, 0, 0.05556, 0.48472], 112:[0.19444, 0.43056, 0, 0.08334, 0.50313], 113:[0.19444, 0.43056, 0.03588, 0.08334, 0.44641], 114:[0, 0.43056, 0.02778, 0.05556, 0.45116], 115:[0, 0.43056, 0, 0.05556, 0.46875], 116:[0, 0.61508, 0, 0.08334, 0.36111], 117:[0, 0.43056, 0, 0.02778, 0.57246], 118:[0, 0.43056, 0.03588, 0.02778, 
      0.48472], 119:[0, 0.43056, 0.02691, 0.08334, 0.71592], 120:[0, 0.43056, 0, 0.02778, 0.57153], 121:[0.19444, 0.43056, 0.03588, 0.05556, 0.49028], 122:[0, 0.43056, 0.04398, 0.05556, 0.46505], 160:[0, 0, 0, 0, 0.25], 915:[0, 0.68333, 0.13889, 0.08334, 0.61528], 916:[0, 0.68333, 0, 0.16667, 0.83334], 920:[0, 0.68333, 0.02778, 0.08334, 0.76278], 923:[0, 0.68333, 0, 0.16667, 0.69445], 926:[0, 0.68333, 0.07569, 0.08334, 0.74236], 928:[0, 0.68333, 0.08125, 0.05556, 0.83125], 931:[0, 0.68333, 0.05764, 
      0.08334, 0.77986], 933:[0, 0.68333, 0.13889, 0.05556, 0.58333], 934:[0, 0.68333, 0, 0.08334, 0.66667], 936:[0, 0.68333, 0.11, 0.05556, 0.61222], 937:[0, 0.68333, 0.05017, 0.08334, 0.7724], 945:[0, 0.43056, 0.0037, 0.02778, 0.6397], 946:[0.19444, 0.69444, 0.05278, 0.08334, 0.56563], 947:[0.19444, 0.43056, 0.05556, 0, 0.51773], 948:[0, 0.69444, 0.03785, 0.05556, 0.44444], 949:[0, 0.43056, 0, 0.08334, 0.46632], 950:[0.19444, 0.69444, 0.07378, 0.08334, 0.4375], 951:[0.19444, 0.43056, 0.03588, 0.05556, 
      0.49653], 952:[0, 0.69444, 0.02778, 0.08334, 0.46944], 953:[0, 0.43056, 0, 0.05556, 0.35394], 954:[0, 0.43056, 0, 0, 0.57616], 955:[0, 0.69444, 0, 0, 0.58334], 956:[0.19444, 0.43056, 0, 0.02778, 0.60255], 957:[0, 0.43056, 0.06366, 0.02778, 0.49398], 958:[0.19444, 0.69444, 0.04601, 0.11111, 0.4375], 959:[0, 0.43056, 0, 0.05556, 0.48472], 960:[0, 0.43056, 0.03588, 0, 0.57003], 961:[0.19444, 0.43056, 0, 0.08334, 0.51702], 962:[0.09722, 0.43056, 0.07986, 0.08334, 0.36285], 963:[0, 0.43056, 0.03588, 
      0, 0.57141], 964:[0, 0.43056, 0.1132, 0.02778, 0.43715], 965:[0, 0.43056, 0.03588, 0.02778, 0.54028], 966:[0.19444, 0.43056, 0, 0.08334, 0.65417], 967:[0.19444, 0.43056, 0, 0.05556, 0.62569], 968:[0.19444, 0.69444, 0.03588, 0.11111, 0.65139], 969:[0, 0.43056, 0.03588, 0, 0.62245], 977:[0, 0.69444, 0, 0.08334, 0.59144], 981:[0.19444, 0.69444, 0, 0.08334, 0.59583], 982:[0, 0.43056, 0.02778, 0, 0.82813], 1009:[0.19444, 0.43056, 0, 0.08334, 0.51702], 1013:[0, 0.43056, 0, 0.05556, 0.4059], 57649:[0, 
      0.43056, 0, 0.02778, 0.32246], 57911:[0.19444, 0.43056, 0, 0.08334, 0.38403]}, "SansSerif-Bold":{32:[0, 0, 0, 0, 0.25], 33:[0, 0.69444, 0, 0, 0.36667], 34:[0, 0.69444, 0, 0, 0.55834], 35:[0.19444, 0.69444, 0, 0, 0.91667], 36:[0.05556, 0.75, 0, 0, 0.55], 37:[0.05556, 0.75, 0, 0, 1.02912], 38:[0, 0.69444, 0, 0, 0.83056], 39:[0, 0.69444, 0, 0, 0.30556], 40:[0.25, 0.75, 0, 0, 0.42778], 41:[0.25, 0.75, 0, 0, 0.42778], 42:[0, 0.75, 0, 0, 0.55], 43:[0.11667, 0.61667, 0, 0, 0.85556], 44:[0.10556, 0.13056, 
      0, 0, 0.30556], 45:[0, 0.45833, 0, 0, 0.36667], 46:[0, 0.13056, 0, 0, 0.30556], 47:[0.25, 0.75, 0, 0, 0.55], 48:[0, 0.69444, 0, 0, 0.55], 49:[0, 0.69444, 0, 0, 0.55], 50:[0, 0.69444, 0, 0, 0.55], 51:[0, 0.69444, 0, 0, 0.55], 52:[0, 0.69444, 0, 0, 0.55], 53:[0, 0.69444, 0, 0, 0.55], 54:[0, 0.69444, 0, 0, 0.55], 55:[0, 0.69444, 0, 0, 0.55], 56:[0, 0.69444, 0, 0, 0.55], 57:[0, 0.69444, 0, 0, 0.55], 58:[0, 0.45833, 0, 0, 0.30556], 59:[0.10556, 0.45833, 0, 0, 0.30556], 61:[-0.09375, 0.40625, 0, 
      0, 0.85556], 63:[0, 0.69444, 0, 0, 0.51945], 64:[0, 0.69444, 0, 0, 0.73334], 65:[0, 0.69444, 0, 0, 0.73334], 66:[0, 0.69444, 0, 0, 0.73334], 67:[0, 0.69444, 0, 0, 0.70278], 68:[0, 0.69444, 0, 0, 0.79445], 69:[0, 0.69444, 0, 0, 0.64167], 70:[0, 0.69444, 0, 0, 0.61111], 71:[0, 0.69444, 0, 0, 0.73334], 72:[0, 0.69444, 0, 0, 0.79445], 73:[0, 0.69444, 0, 0, 0.33056], 74:[0, 0.69444, 0, 0, 0.51945], 75:[0, 0.69444, 0, 0, 0.76389], 76:[0, 0.69444, 0, 0, 0.58056], 77:[0, 0.69444, 0, 0, 0.97778], 78:[0, 
      0.69444, 0, 0, 0.79445], 79:[0, 0.69444, 0, 0, 0.79445], 80:[0, 0.69444, 0, 0, 0.70278], 81:[0.10556, 0.69444, 0, 0, 0.79445], 82:[0, 0.69444, 0, 0, 0.70278], 83:[0, 0.69444, 0, 0, 0.61111], 84:[0, 0.69444, 0, 0, 0.73334], 85:[0, 0.69444, 0, 0, 0.76389], 86:[0, 0.69444, 0.01528, 0, 0.73334], 87:[0, 0.69444, 0.01528, 0, 1.03889], 88:[0, 0.69444, 0, 0, 0.73334], 89:[0, 0.69444, 0.0275, 0, 0.73334], 90:[0, 0.69444, 0, 0, 0.67223], 91:[0.25, 0.75, 0, 0, 0.34306], 93:[0.25, 0.75, 0, 0, 0.34306], 
      94:[0, 0.69444, 0, 0, 0.55], 95:[0.35, 0.10833, 0.03056, 0, 0.55], 97:[0, 0.45833, 0, 0, 0.525], 98:[0, 0.69444, 0, 0, 0.56111], 99:[0, 0.45833, 0, 0, 0.48889], 100:[0, 0.69444, 0, 0, 0.56111], 101:[0, 0.45833, 0, 0, 0.51111], 102:[0, 0.69444, 0.07639, 0, 0.33611], 103:[0.19444, 0.45833, 0.01528, 0, 0.55], 104:[0, 0.69444, 0, 0, 0.56111], 105:[0, 0.69444, 0, 0, 0.25556], 106:[0.19444, 0.69444, 0, 0, 0.28611], 107:[0, 0.69444, 0, 0, 0.53056], 108:[0, 0.69444, 0, 0, 0.25556], 109:[0, 0.45833, 
      0, 0, 0.86667], 110:[0, 0.45833, 0, 0, 0.56111], 111:[0, 0.45833, 0, 0, 0.55], 112:[0.19444, 0.45833, 0, 0, 0.56111], 113:[0.19444, 0.45833, 0, 0, 0.56111], 114:[0, 0.45833, 0.01528, 0, 0.37222], 115:[0, 0.45833, 0, 0, 0.42167], 116:[0, 0.58929, 0, 0, 0.40417], 117:[0, 0.45833, 0, 0, 0.56111], 118:[0, 0.45833, 0.01528, 0, 0.5], 119:[0, 0.45833, 0.01528, 0, 0.74445], 120:[0, 0.45833, 0, 0, 0.5], 121:[0.19444, 0.45833, 0.01528, 0, 0.5], 122:[0, 0.45833, 0, 0, 0.47639], 126:[0.35, 0.34444, 0, 
      0, 0.55], 160:[0, 0, 0, 0, 0.25], 168:[0, 0.69444, 0, 0, 0.55], 176:[0, 0.69444, 0, 0, 0.73334], 180:[0, 0.69444, 0, 0, 0.55], 184:[0.17014, 0, 0, 0, 0.48889], 305:[0, 0.45833, 0, 0, 0.25556], 567:[0.19444, 0.45833, 0, 0, 0.28611], 710:[0, 0.69444, 0, 0, 0.55], 711:[0, 0.63542, 0, 0, 0.55], 713:[0, 0.63778, 0, 0, 0.55], 728:[0, 0.69444, 0, 0, 0.55], 729:[0, 0.69444, 0, 0, 0.30556], 730:[0, 0.69444, 0, 0, 0.73334], 732:[0, 0.69444, 0, 0, 0.55], 733:[0, 0.69444, 0, 0, 0.55], 915:[0, 0.69444, 
      0, 0, 0.58056], 916:[0, 0.69444, 0, 0, 0.91667], 920:[0, 0.69444, 0, 0, 0.85556], 923:[0, 0.69444, 0, 0, 0.67223], 926:[0, 0.69444, 0, 0, 0.73334], 928:[0, 0.69444, 0, 0, 0.79445], 931:[0, 0.69444, 0, 0, 0.79445], 933:[0, 0.69444, 0, 0, 0.85556], 934:[0, 0.69444, 0, 0, 0.79445], 936:[0, 0.69444, 0, 0, 0.85556], 937:[0, 0.69444, 0, 0, 0.79445], 8211:[0, 0.45833, 0.03056, 0, 0.55], 8212:[0, 0.45833, 0.03056, 0, 1.10001], 8216:[0, 0.69444, 0, 0, 0.30556], 8217:[0, 0.69444, 0, 0, 0.30556], 8220:[0, 
      0.69444, 0, 0, 0.55834], 8221:[0, 0.69444, 0, 0, 0.55834]}, "SansSerif-Italic":{32:[0, 0, 0, 0, 0.25], 33:[0, 0.69444, 0.05733, 0, 0.31945], 34:[0, 0.69444, 0.00316, 0, 0.5], 35:[0.19444, 0.69444, 0.05087, 0, 0.83334], 36:[0.05556, 0.75, 0.11156, 0, 0.5], 37:[0.05556, 0.75, 0.03126, 0, 0.83334], 38:[0, 0.69444, 0.03058, 0, 0.75834], 39:[0, 0.69444, 0.07816, 0, 0.27778], 40:[0.25, 0.75, 0.13164, 0, 0.38889], 41:[0.25, 0.75, 0.02536, 0, 0.38889], 42:[0, 0.75, 0.11775, 0, 0.5], 43:[0.08333, 0.58333, 
      0.02536, 0, 0.77778], 44:[0.125, 0.08333, 0, 0, 0.27778], 45:[0, 0.44444, 0.01946, 0, 0.33333], 46:[0, 0.08333, 0, 0, 0.27778], 47:[0.25, 0.75, 0.13164, 0, 0.5], 48:[0, 0.65556, 0.11156, 0, 0.5], 49:[0, 0.65556, 0.11156, 0, 0.5], 50:[0, 0.65556, 0.11156, 0, 0.5], 51:[0, 0.65556, 0.11156, 0, 0.5], 52:[0, 0.65556, 0.11156, 0, 0.5], 53:[0, 0.65556, 0.11156, 0, 0.5], 54:[0, 0.65556, 0.11156, 0, 0.5], 55:[0, 0.65556, 0.11156, 0, 0.5], 56:[0, 0.65556, 0.11156, 0, 0.5], 57:[0, 0.65556, 0.11156, 0, 
      0.5], 58:[0, 0.44444, 0.02502, 0, 0.27778], 59:[0.125, 0.44444, 0.02502, 0, 0.27778], 61:[-0.13, 0.37, 0.05087, 0, 0.77778], 63:[0, 0.69444, 0.11809, 0, 0.47222], 64:[0, 0.69444, 0.07555, 0, 0.66667], 65:[0, 0.69444, 0, 0, 0.66667], 66:[0, 0.69444, 0.08293, 0, 0.66667], 67:[0, 0.69444, 0.11983, 0, 0.63889], 68:[0, 0.69444, 0.07555, 0, 0.72223], 69:[0, 0.69444, 0.11983, 0, 0.59722], 70:[0, 0.69444, 0.13372, 0, 0.56945], 71:[0, 0.69444, 0.11983, 0, 0.66667], 72:[0, 0.69444, 0.08094, 0, 0.70834], 
      73:[0, 0.69444, 0.13372, 0, 0.27778], 74:[0, 0.69444, 0.08094, 0, 0.47222], 75:[0, 0.69444, 0.11983, 0, 0.69445], 76:[0, 0.69444, 0, 0, 0.54167], 77:[0, 0.69444, 0.08094, 0, 0.875], 78:[0, 0.69444, 0.08094, 0, 0.70834], 79:[0, 0.69444, 0.07555, 0, 0.73611], 80:[0, 0.69444, 0.08293, 0, 0.63889], 81:[0.125, 0.69444, 0.07555, 0, 0.73611], 82:[0, 0.69444, 0.08293, 0, 0.64584], 83:[0, 0.69444, 0.09205, 0, 0.55556], 84:[0, 0.69444, 0.13372, 0, 0.68056], 85:[0, 0.69444, 0.08094, 0, 0.6875], 86:[0, 
      0.69444, 0.1615, 0, 0.66667], 87:[0, 0.69444, 0.1615, 0, 0.94445], 88:[0, 0.69444, 0.13372, 0, 0.66667], 89:[0, 0.69444, 0.17261, 0, 0.66667], 90:[0, 0.69444, 0.11983, 0, 0.61111], 91:[0.25, 0.75, 0.15942, 0, 0.28889], 93:[0.25, 0.75, 0.08719, 0, 0.28889], 94:[0, 0.69444, 0.0799, 0, 0.5], 95:[0.35, 0.09444, 0.08616, 0, 0.5], 97:[0, 0.44444, 0.00981, 0, 0.48056], 98:[0, 0.69444, 0.03057, 0, 0.51667], 99:[0, 0.44444, 0.08336, 0, 0.44445], 100:[0, 0.69444, 0.09483, 0, 0.51667], 101:[0, 0.44444, 
      0.06778, 0, 0.44445], 102:[0, 0.69444, 0.21705, 0, 0.30556], 103:[0.19444, 0.44444, 0.10836, 0, 0.5], 104:[0, 0.69444, 0.01778, 0, 0.51667], 105:[0, 0.67937, 0.09718, 0, 0.23889], 106:[0.19444, 0.67937, 0.09162, 0, 0.26667], 107:[0, 0.69444, 0.08336, 0, 0.48889], 108:[0, 0.69444, 0.09483, 0, 0.23889], 109:[0, 0.44444, 0.01778, 0, 0.79445], 110:[0, 0.44444, 0.01778, 0, 0.51667], 111:[0, 0.44444, 0.06613, 0, 0.5], 112:[0.19444, 0.44444, 0.0389, 0, 0.51667], 113:[0.19444, 0.44444, 0.04169, 0, 
      0.51667], 114:[0, 0.44444, 0.10836, 0, 0.34167], 115:[0, 0.44444, 0.0778, 0, 0.38333], 116:[0, 0.57143, 0.07225, 0, 0.36111], 117:[0, 0.44444, 0.04169, 0, 0.51667], 118:[0, 0.44444, 0.10836, 0, 0.46111], 119:[0, 0.44444, 0.10836, 0, 0.68334], 120:[0, 0.44444, 0.09169, 0, 0.46111], 121:[0.19444, 0.44444, 0.10836, 0, 0.46111], 122:[0, 0.44444, 0.08752, 0, 0.43472], 126:[0.35, 0.32659, 0.08826, 0, 0.5], 160:[0, 0, 0, 0, 0.25], 168:[0, 0.67937, 0.06385, 0, 0.5], 176:[0, 0.69444, 0, 0, 0.73752], 
      184:[0.17014, 0, 0, 0, 0.44445], 305:[0, 0.44444, 0.04169, 0, 0.23889], 567:[0.19444, 0.44444, 0.04169, 0, 0.26667], 710:[0, 0.69444, 0.0799, 0, 0.5], 711:[0, 0.63194, 0.08432, 0, 0.5], 713:[0, 0.60889, 0.08776, 0, 0.5], 714:[0, 0.69444, 0.09205, 0, 0.5], 715:[0, 0.69444, 0, 0, 0.5], 728:[0, 0.69444, 0.09483, 0, 0.5], 729:[0, 0.67937, 0.07774, 0, 0.27778], 730:[0, 0.69444, 0, 0, 0.73752], 732:[0, 0.67659, 0.08826, 0, 0.5], 733:[0, 0.69444, 0.09205, 0, 0.5], 915:[0, 0.69444, 0.13372, 0, 0.54167], 
      916:[0, 0.69444, 0, 0, 0.83334], 920:[0, 0.69444, 0.07555, 0, 0.77778], 923:[0, 0.69444, 0, 0, 0.61111], 926:[0, 0.69444, 0.12816, 0, 0.66667], 928:[0, 0.69444, 0.08094, 0, 0.70834], 931:[0, 0.69444, 0.11983, 0, 0.72222], 933:[0, 0.69444, 0.09031, 0, 0.77778], 934:[0, 0.69444, 0.04603, 0, 0.72222], 936:[0, 0.69444, 0.09031, 0, 0.77778], 937:[0, 0.69444, 0.08293, 0, 0.72222], 8211:[0, 0.44444, 0.08616, 0, 0.5], 8212:[0, 0.44444, 0.08616, 0, 1.0], 8216:[0, 0.69444, 0.07816, 0, 0.27778], 8217:[0, 
      0.69444, 0.07816, 0, 0.27778], 8220:[0, 0.69444, 0.14205, 0, 0.5], 8221:[0, 0.69444, 0.00316, 0, 0.5]}, "SansSerif-Regular":{32:[0, 0, 0, 0, 0.25], 33:[0, 0.69444, 0, 0, 0.31945], 34:[0, 0.69444, 0, 0, 0.5], 35:[0.19444, 0.69444, 0, 0, 0.83334], 36:[0.05556, 0.75, 0, 0, 0.5], 37:[0.05556, 0.75, 0, 0, 0.83334], 38:[0, 0.69444, 0, 0, 0.75834], 39:[0, 0.69444, 0, 0, 0.27778], 40:[0.25, 0.75, 0, 0, 0.38889], 41:[0.25, 0.75, 0, 0, 0.38889], 42:[0, 0.75, 0, 0, 0.5], 43:[0.08333, 0.58333, 0, 0, 0.77778], 
      44:[0.125, 0.08333, 0, 0, 0.27778], 45:[0, 0.44444, 0, 0, 0.33333], 46:[0, 0.08333, 0, 0, 0.27778], 47:[0.25, 0.75, 0, 0, 0.5], 48:[0, 0.65556, 0, 0, 0.5], 49:[0, 0.65556, 0, 0, 0.5], 50:[0, 0.65556, 0, 0, 0.5], 51:[0, 0.65556, 0, 0, 0.5], 52:[0, 0.65556, 0, 0, 0.5], 53:[0, 0.65556, 0, 0, 0.5], 54:[0, 0.65556, 0, 0, 0.5], 55:[0, 0.65556, 0, 0, 0.5], 56:[0, 0.65556, 0, 0, 0.5], 57:[0, 0.65556, 0, 0, 0.5], 58:[0, 0.44444, 0, 0, 0.27778], 59:[0.125, 0.44444, 0, 0, 0.27778], 61:[-0.13, 0.37, 0, 
      0, 0.77778], 63:[0, 0.69444, 0, 0, 0.47222], 64:[0, 0.69444, 0, 0, 0.66667], 65:[0, 0.69444, 0, 0, 0.66667], 66:[0, 0.69444, 0, 0, 0.66667], 67:[0, 0.69444, 0, 0, 0.63889], 68:[0, 0.69444, 0, 0, 0.72223], 69:[0, 0.69444, 0, 0, 0.59722], 70:[0, 0.69444, 0, 0, 0.56945], 71:[0, 0.69444, 0, 0, 0.66667], 72:[0, 0.69444, 0, 0, 0.70834], 73:[0, 0.69444, 0, 0, 0.27778], 74:[0, 0.69444, 0, 0, 0.47222], 75:[0, 0.69444, 0, 0, 0.69445], 76:[0, 0.69444, 0, 0, 0.54167], 77:[0, 0.69444, 0, 0, 0.875], 78:[0, 
      0.69444, 0, 0, 0.70834], 79:[0, 0.69444, 0, 0, 0.73611], 80:[0, 0.69444, 0, 0, 0.63889], 81:[0.125, 0.69444, 0, 0, 0.73611], 82:[0, 0.69444, 0, 0, 0.64584], 83:[0, 0.69444, 0, 0, 0.55556], 84:[0, 0.69444, 0, 0, 0.68056], 85:[0, 0.69444, 0, 0, 0.6875], 86:[0, 0.69444, 0.01389, 0, 0.66667], 87:[0, 0.69444, 0.01389, 0, 0.94445], 88:[0, 0.69444, 0, 0, 0.66667], 89:[0, 0.69444, 0.025, 0, 0.66667], 90:[0, 0.69444, 0, 0, 0.61111], 91:[0.25, 0.75, 0, 0, 0.28889], 93:[0.25, 0.75, 0, 0, 0.28889], 94:[0, 
      0.69444, 0, 0, 0.5], 95:[0.35, 0.09444, 0.02778, 0, 0.5], 97:[0, 0.44444, 0, 0, 0.48056], 98:[0, 0.69444, 0, 0, 0.51667], 99:[0, 0.44444, 0, 0, 0.44445], 100:[0, 0.69444, 0, 0, 0.51667], 101:[0, 0.44444, 0, 0, 0.44445], 102:[0, 0.69444, 0.06944, 0, 0.30556], 103:[0.19444, 0.44444, 0.01389, 0, 0.5], 104:[0, 0.69444, 0, 0, 0.51667], 105:[0, 0.67937, 0, 0, 0.23889], 106:[0.19444, 0.67937, 0, 0, 0.26667], 107:[0, 0.69444, 0, 0, 0.48889], 108:[0, 0.69444, 0, 0, 0.23889], 109:[0, 0.44444, 0, 0, 0.79445], 
      110:[0, 0.44444, 0, 0, 0.51667], 111:[0, 0.44444, 0, 0, 0.5], 112:[0.19444, 0.44444, 0, 0, 0.51667], 113:[0.19444, 0.44444, 0, 0, 0.51667], 114:[0, 0.44444, 0.01389, 0, 0.34167], 115:[0, 0.44444, 0, 0, 0.38333], 116:[0, 0.57143, 0, 0, 0.36111], 117:[0, 0.44444, 0, 0, 0.51667], 118:[0, 0.44444, 0.01389, 0, 0.46111], 119:[0, 0.44444, 0.01389, 0, 0.68334], 120:[0, 0.44444, 0, 0, 0.46111], 121:[0.19444, 0.44444, 0.01389, 0, 0.46111], 122:[0, 0.44444, 0, 0, 0.43472], 126:[0.35, 0.32659, 0, 0, 0.5], 
      160:[0, 0, 0, 0, 0.25], 168:[0, 0.67937, 0, 0, 0.5], 176:[0, 0.69444, 0, 0, 0.66667], 184:[0.17014, 0, 0, 0, 0.44445], 305:[0, 0.44444, 0, 0, 0.23889], 567:[0.19444, 0.44444, 0, 0, 0.26667], 710:[0, 0.69444, 0, 0, 0.5], 711:[0, 0.63194, 0, 0, 0.5], 713:[0, 0.60889, 0, 0, 0.5], 714:[0, 0.69444, 0, 0, 0.5], 715:[0, 0.69444, 0, 0, 0.5], 728:[0, 0.69444, 0, 0, 0.5], 729:[0, 0.67937, 0, 0, 0.27778], 730:[0, 0.69444, 0, 0, 0.66667], 732:[0, 0.67659, 0, 0, 0.5], 733:[0, 0.69444, 0, 0, 0.5], 915:[0, 
      0.69444, 0, 0, 0.54167], 916:[0, 0.69444, 0, 0, 0.83334], 920:[0, 0.69444, 0, 0, 0.77778], 923:[0, 0.69444, 0, 0, 0.61111], 926:[0, 0.69444, 0, 0, 0.66667], 928:[0, 0.69444, 0, 0, 0.70834], 931:[0, 0.69444, 0, 0, 0.72222], 933:[0, 0.69444, 0, 0, 0.77778], 934:[0, 0.69444, 0, 0, 0.72222], 936:[0, 0.69444, 0, 0, 0.77778], 937:[0, 0.69444, 0, 0, 0.72222], 8211:[0, 0.44444, 0.02778, 0, 0.5], 8212:[0, 0.44444, 0.02778, 0, 1.0], 8216:[0, 0.69444, 0, 0, 0.27778], 8217:[0, 0.69444, 0, 0, 0.27778], 
      8220:[0, 0.69444, 0, 0, 0.5], 8221:[0, 0.69444, 0, 0, 0.5]}, "Script-Regular":{32:[0, 0, 0, 0, 0.25], 65:[0, 0.7, 0.22925, 0, 0.80253], 66:[0, 0.7, 0.04087, 0, 0.90757], 67:[0, 0.7, 0.1689, 0, 0.66619], 68:[0, 0.7, 0.09371, 0, 0.77443], 69:[0, 0.7, 0.18583, 0, 0.56162], 70:[0, 0.7, 0.13634, 0, 0.89544], 71:[0, 0.7, 0.17322, 0, 0.60961], 72:[0, 0.7, 0.29694, 0, 0.96919], 73:[0, 0.7, 0.19189, 0, 0.80907], 74:[0.27778, 0.7, 0.19189, 0, 1.05159], 75:[0, 0.7, 0.31259, 0, 0.91364], 76:[0, 0.7, 0.19189, 
      0, 0.87373], 77:[0, 0.7, 0.15981, 0, 1.08031], 78:[0, 0.7, 0.3525, 0, 0.9015], 79:[0, 0.7, 0.08078, 0, 0.73787], 80:[0, 0.7, 0.08078, 0, 1.01262], 81:[0, 0.7, 0.03305, 0, 0.88282], 82:[0, 0.7, 0.06259, 0, 0.85], 83:[0, 0.7, 0.19189, 0, 0.86767], 84:[0, 0.7, 0.29087, 0, 0.74697], 85:[0, 0.7, 0.25815, 0, 0.79996], 86:[0, 0.7, 0.27523, 0, 0.62204], 87:[0, 0.7, 0.27523, 0, 0.80532], 88:[0, 0.7, 0.26006, 0, 0.94445], 89:[0, 0.7, 0.2939, 0, 0.70961], 90:[0, 0.7, 0.24037, 0, 0.8212], 160:[0, 0, 0, 
      0, 0.25]}, "Size1-Regular":{32:[0, 0, 0, 0, 0.25], 40:[0.35001, 0.85, 0, 0, 0.45834], 41:[0.35001, 0.85, 0, 0, 0.45834], 47:[0.35001, 0.85, 0, 0, 0.57778], 91:[0.35001, 0.85, 0, 0, 0.41667], 92:[0.35001, 0.85, 0, 0, 0.57778], 93:[0.35001, 0.85, 0, 0, 0.41667], 123:[0.35001, 0.85, 0, 0, 0.58334], 125:[0.35001, 0.85, 0, 0, 0.58334], 160:[0, 0, 0, 0, 0.25], 710:[0, 0.72222, 0, 0, 0.55556], 732:[0, 0.72222, 0, 0, 0.55556], 770:[0, 0.72222, 0, 0, 0.55556], 771:[0, 0.72222, 0, 0, 0.55556], 8214:[-0.00099, 
      0.601, 0, 0, 0.77778], 8593:[1e-05, 0.6, 0, 0, 0.66667], 8595:[1e-05, 0.6, 0, 0, 0.66667], 8657:[1e-05, 0.6, 0, 0, 0.77778], 8659:[1e-05, 0.6, 0, 0, 0.77778], 8719:[0.25001, 0.75, 0, 0, 0.94445], 8720:[0.25001, 0.75, 0, 0, 0.94445], 8721:[0.25001, 0.75, 0, 0, 1.05556], 8730:[0.35001, 0.85, 0, 0, 1.0], 8739:[-0.00599, 0.606, 0, 0, 0.33333], 8741:[-0.00599, 0.606, 0, 0, 0.55556], 8747:[0.30612, 0.805, 0.19445, 0, 0.47222], 8748:[0.306, 0.805, 0.19445, 0, 0.47222], 8749:[0.306, 0.805, 0.19445, 
      0, 0.47222], 8750:[0.30612, 0.805, 0.19445, 0, 0.47222], 8896:[0.25001, 0.75, 0, 0, 0.83334], 8897:[0.25001, 0.75, 0, 0, 0.83334], 8898:[0.25001, 0.75, 0, 0, 0.83334], 8899:[0.25001, 0.75, 0, 0, 0.83334], 8968:[0.35001, 0.85, 0, 0, 0.47222], 8969:[0.35001, 0.85, 0, 0, 0.47222], 8970:[0.35001, 0.85, 0, 0, 0.47222], 8971:[0.35001, 0.85, 0, 0, 0.47222], 9168:[-0.00099, 0.601, 0, 0, 0.66667], 10216:[0.35001, 0.85, 0, 0, 0.47222], 10217:[0.35001, 0.85, 0, 0, 0.47222], 10752:[0.25001, 0.75, 0, 0, 
      1.11111], 10753:[0.25001, 0.75, 0, 0, 1.11111], 10754:[0.25001, 0.75, 0, 0, 1.11111], 10756:[0.25001, 0.75, 0, 0, 0.83334], 10758:[0.25001, 0.75, 0, 0, 0.83334]}, "Size2-Regular":{32:[0, 0, 0, 0, 0.25], 40:[0.65002, 1.15, 0, 0, 0.59722], 41:[0.65002, 1.15, 0, 0, 0.59722], 47:[0.65002, 1.15, 0, 0, 0.81111], 91:[0.65002, 1.15, 0, 0, 0.47222], 92:[0.65002, 1.15, 0, 0, 0.81111], 93:[0.65002, 1.15, 0, 0, 0.47222], 123:[0.65002, 1.15, 0, 0, 0.66667], 125:[0.65002, 1.15, 0, 0, 0.66667], 160:[0, 0, 
      0, 0, 0.25], 710:[0, 0.75, 0, 0, 1.0], 732:[0, 0.75, 0, 0, 1.0], 770:[0, 0.75, 0, 0, 1.0], 771:[0, 0.75, 0, 0, 1.0], 8719:[0.55001, 1.05, 0, 0, 1.27778], 8720:[0.55001, 1.05, 0, 0, 1.27778], 8721:[0.55001, 1.05, 0, 0, 1.44445], 8730:[0.65002, 1.15, 0, 0, 1.0], 8747:[0.86225, 1.36, 0.44445, 0, 0.55556], 8748:[0.862, 1.36, 0.44445, 0, 0.55556], 8749:[0.862, 1.36, 0.44445, 0, 0.55556], 8750:[0.86225, 1.36, 0.44445, 0, 0.55556], 8896:[0.55001, 1.05, 0, 0, 1.11111], 8897:[0.55001, 1.05, 0, 0, 1.11111], 
      8898:[0.55001, 1.05, 0, 0, 1.11111], 8899:[0.55001, 1.05, 0, 0, 1.11111], 8968:[0.65002, 1.15, 0, 0, 0.52778], 8969:[0.65002, 1.15, 0, 0, 0.52778], 8970:[0.65002, 1.15, 0, 0, 0.52778], 8971:[0.65002, 1.15, 0, 0, 0.52778], 10216:[0.65002, 1.15, 0, 0, 0.61111], 10217:[0.65002, 1.15, 0, 0, 0.61111], 10752:[0.55001, 1.05, 0, 0, 1.51112], 10753:[0.55001, 1.05, 0, 0, 1.51112], 10754:[0.55001, 1.05, 0, 0, 1.51112], 10756:[0.55001, 1.05, 0, 0, 1.11111], 10758:[0.55001, 1.05, 0, 0, 1.11111]}, "Size3-Regular":{32:[0, 
      0, 0, 0, 0.25], 40:[0.95003, 1.45, 0, 0, 0.73611], 41:[0.95003, 1.45, 0, 0, 0.73611], 47:[0.95003, 1.45, 0, 0, 1.04445], 91:[0.95003, 1.45, 0, 0, 0.52778], 92:[0.95003, 1.45, 0, 0, 1.04445], 93:[0.95003, 1.45, 0, 0, 0.52778], 123:[0.95003, 1.45, 0, 0, 0.75], 125:[0.95003, 1.45, 0, 0, 0.75], 160:[0, 0, 0, 0, 0.25], 710:[0, 0.75, 0, 0, 1.44445], 732:[0, 0.75, 0, 0, 1.44445], 770:[0, 0.75, 0, 0, 1.44445], 771:[0, 0.75, 0, 0, 1.44445], 8730:[0.95003, 1.45, 0, 0, 1.0], 8968:[0.95003, 1.45, 0, 0, 
      0.58334], 8969:[0.95003, 1.45, 0, 0, 0.58334], 8970:[0.95003, 1.45, 0, 0, 0.58334], 8971:[0.95003, 1.45, 0, 0, 0.58334], 10216:[0.95003, 1.45, 0, 0, 0.75], 10217:[0.95003, 1.45, 0, 0, 0.75]}, "Size4-Regular":{32:[0, 0, 0, 0, 0.25], 40:[1.25003, 1.75, 0, 0, 0.79167], 41:[1.25003, 1.75, 0, 0, 0.79167], 47:[1.25003, 1.75, 0, 0, 1.27778], 91:[1.25003, 1.75, 0, 0, 0.58334], 92:[1.25003, 1.75, 0, 0, 1.27778], 93:[1.25003, 1.75, 0, 0, 0.58334], 123:[1.25003, 1.75, 0, 0, 0.80556], 125:[1.25003, 1.75, 
      0, 0, 0.80556], 160:[0, 0, 0, 0, 0.25], 710:[0, 0.825, 0, 0, 1.8889], 732:[0, 0.825, 0, 0, 1.8889], 770:[0, 0.825, 0, 0, 1.8889], 771:[0, 0.825, 0, 0, 1.8889], 8730:[1.25003, 1.75, 0, 0, 1.0], 8968:[1.25003, 1.75, 0, 0, 0.63889], 8969:[1.25003, 1.75, 0, 0, 0.63889], 8970:[1.25003, 1.75, 0, 0, 0.63889], 8971:[1.25003, 1.75, 0, 0, 0.63889], 9115:[0.64502, 1.155, 0, 0, 0.875], 9116:[1e-05, 0.6, 0, 0, 0.875], 9117:[0.64502, 1.155, 0, 0, 0.875], 9118:[0.64502, 1.155, 0, 0, 0.875], 9119:[1e-05, 0.6, 
      0, 0, 0.875], 9120:[0.64502, 1.155, 0, 0, 0.875], 9121:[0.64502, 1.155, 0, 0, 0.66667], 9122:[-0.00099, 0.601, 0, 0, 0.66667], 9123:[0.64502, 1.155, 0, 0, 0.66667], 9124:[0.64502, 1.155, 0, 0, 0.66667], 9125:[-0.00099, 0.601, 0, 0, 0.66667], 9126:[0.64502, 1.155, 0, 0, 0.66667], 9127:[1e-05, 0.9, 0, 0, 0.88889], 9128:[0.65002, 1.15, 0, 0, 0.88889], 9129:[0.90001, 0, 0, 0, 0.88889], 9130:[0, 0.3, 0, 0, 0.88889], 9131:[1e-05, 0.9, 0, 0, 0.88889], 9132:[0.65002, 1.15, 0, 0, 0.88889], 9133:[0.90001, 
      0, 0, 0, 0.88889], 9143:[0.88502, 0.915, 0, 0, 1.05556], 10216:[1.25003, 1.75, 0, 0, 0.80556], 10217:[1.25003, 1.75, 0, 0, 0.80556], 57344:[-0.00499, 0.605, 0, 0, 1.05556], 57345:[-0.00499, 0.605, 0, 0, 1.05556], 57680:[0, 0.12, 0, 0, 0.45], 57681:[0, 0.12, 0, 0, 0.45], 57682:[0, 0.12, 0, 0, 0.45], 57683:[0, 0.12, 0, 0, 0.45]}, "Typewriter-Regular":{32:[0, 0, 0, 0, 0.525], 33:[0, 0.61111, 0, 0, 0.525], 34:[0, 0.61111, 0, 0, 0.525], 35:[0, 0.61111, 0, 0, 0.525], 36:[0.08333, 0.69444, 0, 0, 0.525], 
      37:[0.08333, 0.69444, 0, 0, 0.525], 38:[0, 0.61111, 0, 0, 0.525], 39:[0, 0.61111, 0, 0, 0.525], 40:[0.08333, 0.69444, 0, 0, 0.525], 41:[0.08333, 0.69444, 0, 0, 0.525], 42:[0, 0.52083, 0, 0, 0.525], 43:[-0.08056, 0.53055, 0, 0, 0.525], 44:[0.13889, 0.125, 0, 0, 0.525], 45:[-0.08056, 0.53055, 0, 0, 0.525], 46:[0, 0.125, 0, 0, 0.525], 47:[0.08333, 0.69444, 0, 0, 0.525], 48:[0, 0.61111, 0, 0, 0.525], 49:[0, 0.61111, 0, 0, 0.525], 50:[0, 0.61111, 0, 0, 0.525], 51:[0, 0.61111, 0, 0, 0.525], 52:[0, 
      0.61111, 0, 0, 0.525], 53:[0, 0.61111, 0, 0, 0.525], 54:[0, 0.61111, 0, 0, 0.525], 55:[0, 0.61111, 0, 0, 0.525], 56:[0, 0.61111, 0, 0, 0.525], 57:[0, 0.61111, 0, 0, 0.525], 58:[0, 0.43056, 0, 0, 0.525], 59:[0.13889, 0.43056, 0, 0, 0.525], 60:[-0.05556, 0.55556, 0, 0, 0.525], 61:[-0.19549, 0.41562, 0, 0, 0.525], 62:[-0.05556, 0.55556, 0, 0, 0.525], 63:[0, 0.61111, 0, 0, 0.525], 64:[0, 0.61111, 0, 0, 0.525], 65:[0, 0.61111, 0, 0, 0.525], 66:[0, 0.61111, 0, 0, 0.525], 67:[0, 0.61111, 0, 0, 0.525], 
      68:[0, 0.61111, 0, 0, 0.525], 69:[0, 0.61111, 0, 0, 0.525], 70:[0, 0.61111, 0, 0, 0.525], 71:[0, 0.61111, 0, 0, 0.525], 72:[0, 0.61111, 0, 0, 0.525], 73:[0, 0.61111, 0, 0, 0.525], 74:[0, 0.61111, 0, 0, 0.525], 75:[0, 0.61111, 0, 0, 0.525], 76:[0, 0.61111, 0, 0, 0.525], 77:[0, 0.61111, 0, 0, 0.525], 78:[0, 0.61111, 0, 0, 0.525], 79:[0, 0.61111, 0, 0, 0.525], 80:[0, 0.61111, 0, 0, 0.525], 81:[0.13889, 0.61111, 0, 0, 0.525], 82:[0, 0.61111, 0, 0, 0.525], 83:[0, 0.61111, 0, 0, 0.525], 84:[0, 0.61111, 
      0, 0, 0.525], 85:[0, 0.61111, 0, 0, 0.525], 86:[0, 0.61111, 0, 0, 0.525], 87:[0, 0.61111, 0, 0, 0.525], 88:[0, 0.61111, 0, 0, 0.525], 89:[0, 0.61111, 0, 0, 0.525], 90:[0, 0.61111, 0, 0, 0.525], 91:[0.08333, 0.69444, 0, 0, 0.525], 92:[0.08333, 0.69444, 0, 0, 0.525], 93:[0.08333, 0.69444, 0, 0, 0.525], 94:[0, 0.61111, 0, 0, 0.525], 95:[0.09514, 0, 0, 0, 0.525], 96:[0, 0.61111, 0, 0, 0.525], 97:[0, 0.43056, 0, 0, 0.525], 98:[0, 0.61111, 0, 0, 0.525], 99:[0, 0.43056, 0, 0, 0.525], 100:[0, 0.61111, 
      0, 0, 0.525], 101:[0, 0.43056, 0, 0, 0.525], 102:[0, 0.61111, 0, 0, 0.525], 103:[0.22222, 0.43056, 0, 0, 0.525], 104:[0, 0.61111, 0, 0, 0.525], 105:[0, 0.61111, 0, 0, 0.525], 106:[0.22222, 0.61111, 0, 0, 0.525], 107:[0, 0.61111, 0, 0, 0.525], 108:[0, 0.61111, 0, 0, 0.525], 109:[0, 0.43056, 0, 0, 0.525], 110:[0, 0.43056, 0, 0, 0.525], 111:[0, 0.43056, 0, 0, 0.525], 112:[0.22222, 0.43056, 0, 0, 0.525], 113:[0.22222, 0.43056, 0, 0, 0.525], 114:[0, 0.43056, 0, 0, 0.525], 115:[0, 0.43056, 0, 0, 
      0.525], 116:[0, 0.55358, 0, 0, 0.525], 117:[0, 0.43056, 0, 0, 0.525], 118:[0, 0.43056, 0, 0, 0.525], 119:[0, 0.43056, 0, 0, 0.525], 120:[0, 0.43056, 0, 0, 0.525], 121:[0.22222, 0.43056, 0, 0, 0.525], 122:[0, 0.43056, 0, 0, 0.525], 123:[0.08333, 0.69444, 0, 0, 0.525], 124:[0.08333, 0.69444, 0, 0, 0.525], 125:[0.08333, 0.69444, 0, 0, 0.525], 126:[0, 0.61111, 0, 0, 0.525], 127:[0, 0.61111, 0, 0, 0.525], 160:[0, 0, 0, 0, 0.525], 176:[0, 0.61111, 0, 0, 0.525], 184:[0.19445, 0, 0, 0, 0.525], 305:[0, 
      0.43056, 0, 0, 0.525], 567:[0.22222, 0.43056, 0, 0, 0.525], 711:[0, 0.56597, 0, 0, 0.525], 713:[0, 0.56555, 0, 0, 0.525], 714:[0, 0.61111, 0, 0, 0.525], 715:[0, 0.61111, 0, 0, 0.525], 728:[0, 0.61111, 0, 0, 0.525], 730:[0, 0.61111, 0, 0, 0.525], 770:[0, 0.61111, 0, 0, 0.525], 771:[0, 0.61111, 0, 0, 0.525], 776:[0, 0.61111, 0, 0, 0.525], 915:[0, 0.61111, 0, 0, 0.525], 916:[0, 0.61111, 0, 0, 0.525], 920:[0, 0.61111, 0, 0, 0.525], 923:[0, 0.61111, 0, 0, 0.525], 926:[0, 0.61111, 0, 0, 0.525], 928:[0, 
      0.61111, 0, 0, 0.525], 931:[0, 0.61111, 0, 0, 0.525], 933:[0, 0.61111, 0, 0, 0.525], 934:[0, 0.61111, 0, 0, 0.525], 936:[0, 0.61111, 0, 0, 0.525], 937:[0, 0.61111, 0, 0, 0.525], 8216:[0, 0.61111, 0, 0, 0.525], 8217:[0, 0.61111, 0, 0, 0.525], 8242:[0, 0.61111, 0, 0, 0.525], 9251:[0.11111, 0.21944, 0, 0, 0.525]}};
      const sigmasAndXis = {slant:[0.250, 0.250, 0.250], space:[0.000, 0.000, 0.000], stretch:[0.000, 0.000, 0.000], shrink:[0.000, 0.000, 0.000], xHeight:[0.431, 0.431, 0.431], quad:[1.000, 1.171, 1.472], extraSpace:[0.000, 0.000, 0.000], num1:[0.677, 0.732, 0.925], num2:[0.394, 0.384, 0.387], num3:[0.444, 0.471, 0.504], denom1:[0.686, 0.752, 1.025], denom2:[0.345, 0.344, 0.532], sup1:[0.413, 0.503, 0.504], sup2:[0.363, 0.431, 0.404], sup3:[0.289, 0.286, 0.294], sub1:[0.150, 0.143, 0.200], sub2:[0.247, 
      0.286, 0.400], supDrop:[0.386, 0.353, 0.494], subDrop:[0.050, 0.071, 0.100], delim1:[2.390, 1.700, 1.980], delim2:[1.010, 1.157, 1.420], axisHeight:[0.250, 0.250, 0.250], defaultRuleThickness:[0.04, 0.049, 0.049], bigOpSpacing1:[0.111, 0.111, 0.111], bigOpSpacing2:[0.166, 0.166, 0.166], bigOpSpacing3:[0.2, 0.2, 0.2], bigOpSpacing4:[0.6, 0.611, 0.611], bigOpSpacing5:[0.1, 0.143, 0.143], sqrtRuleThickness:[0.04, 0.04, 0.04], ptPerEm:[10.0, 10.0, 10.0], doubleRuleSep:[0.2, 0.2, 0.2], arrayRuleWidth:[0.04, 
      0.04, 0.04], fboxsep:[0.3, 0.3, 0.3], fboxrule:[0.04, 0.04, 0.04]}, extraCharacterMap = {"Å":"A", "Ð":"D", "Þ":"o", "å":"a", "ð":"d", "þ":"o", "А":"A", "Б":"B", "В":"B", "Г":"F", "Д":"A", "Е":"E", "Ж":"K", "З":"3", "И":"N", "Й":"N", "К":"K", "Л":"N", "М":"M", "Н":"H", "О":"O", "П":"N", "Р":"P", "С":"C", "Т":"T", "У":"y", "Ф":"O", "Х":"X", "Ц":"U", "Ч":"h", "Ш":"W", "Щ":"W", "Ъ":"B", "Ы":"X", "Ь":"B", "Э":"3", "Ю":"X", "Я":"R", "а":"a", "б":"b", "в":"a", "г":"r", "д":"y", "е":"e", "ж":"m", "з":"e", 
      "и":"n", "й":"n", "к":"n", "л":"n", "м":"m", "н":"n", "о":"o", "п":"n", "р":"p", "с":"c", "т":"o", "у":"y", "ф":"b", "х":"x", "ц":"n", "ч":"n", "ш":"w", "щ":"w", "ъ":"a", "ы":"m", "ь":"a", "э":"e", "ю":"m", "я":"r"}, fontMetricsBySizeIndex = {}, sizeStyleMap = [[1, 1, 1], [2, 1, 1], [3, 1, 1], [4, 2, 1], [5, 2, 1], [6, 3, 1], [7, 4, 2], [8, 6, 3], [9, 7, 6], [10, 8, 7], [11, 10, 9]], sizeMultipliers = [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.44, 1.728, 2.074, 2.488], sizeAtStyle = function(size, 
      style) {
        return 2 > style.size ? size : sizeStyleMap[size - 1][style.size - 1];
      };
      class Options {
        constructor(data) {
          this._fontMetrics = this.minRuleThickness = this.maxSize = this.sizeMultiplier = this.fontShape = this.fontWeight = this.fontFamily = this.font = this.phantom = this.textSize = this.size = this.color = this.style = void 0;
          this.style = data.style;
          this.color = data.color;
          this.size = data.size || Options.BASESIZE;
          this.textSize = data.textSize || this.size;
          this.phantom = !!data.phantom;
          this.font = data.font || "";
          this.fontFamily = data.fontFamily || "";
          this.fontWeight = data.fontWeight || "";
          this.fontShape = data.fontShape || "";
          this.sizeMultiplier = sizeMultipliers[this.size - 1];
          this.maxSize = data.maxSize;
          this.minRuleThickness = data.minRuleThickness;
          this._fontMetrics = void 0;
        }
        extend(extension) {
          const data = {style:this.style, size:this.size, textSize:this.textSize, color:this.color, phantom:this.phantom, font:this.font, fontFamily:this.fontFamily, fontWeight:this.fontWeight, fontShape:this.fontShape, maxSize:this.maxSize, minRuleThickness:this.minRuleThickness};
          for (const key in extension) {
            extension.hasOwnProperty(key) && (data[key] = extension[key]);
          }
          return new Options(data);
        }
        havingStyle(style) {
          return this.style === style ? this : this.extend({style, size:sizeAtStyle(this.textSize, style)});
        }
        havingCrampedStyle() {
          return this.havingStyle(this.style.cramp());
        }
        havingSize(size) {
          return this.size === size && this.textSize === size ? this : this.extend({style:this.style.text(), size, textSize:size, sizeMultiplier:sizeMultipliers[size - 1]});
        }
        havingBaseStyle(style) {
          style = style || this.style.text();
          const wantSize = sizeAtStyle(Options.BASESIZE, style);
          return this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style ? this : this.extend({style, size:wantSize});
        }
        havingBaseSizing() {
          let size;
          switch(this.style.id) {
            case 4:
            case 5:
              size = 3;
              break;
            case 6:
            case 7:
              size = 1;
              break;
            default:
              size = 6;
          }
          return this.extend({style:this.style.text(), size});
        }
        withColor(color) {
          return this.extend({color});
        }
        withPhantom() {
          return this.extend({phantom:!0});
        }
        withFont(font) {
          return this.extend({font});
        }
        withTextFontFamily(fontFamily) {
          return this.extend({fontFamily, font:""});
        }
        withTextFontWeight(fontWeight) {
          return this.extend({fontWeight, font:""});
        }
        withTextFontShape(fontShape) {
          return this.extend({fontShape, font:""});
        }
        sizingClasses(oldOptions) {
          return oldOptions.size !== this.size ? ["sizing", "reset-size" + oldOptions.size, "size" + this.size] : [];
        }
        baseSizingClasses() {
          return this.size !== Options.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE] : [];
        }
        fontMetrics() {
          if (!this._fontMetrics) {
            var size = this.size;
            size = 5 <= size ? 0 : 3 <= size ? 1 : 2;
            if (!fontMetricsBySizeIndex[size]) {
              const metrics = fontMetricsBySizeIndex[size] = {cssEmPerMu:sigmasAndXis.quad[size] / 18};
              for (const key in sigmasAndXis) {
                sigmasAndXis.hasOwnProperty(key) && (metrics[key] = sigmasAndXis[key][size]);
              }
            }
            this._fontMetrics = fontMetricsBySizeIndex[size];
          }
          return this._fontMetrics;
        }
        getColor() {
          return this.phantom ? "transparent" : this.color;
        }
      }
      Options.BASESIZE = 6;
      var src_Options = Options;
      const ptPerUnit = {pt:1, mm:7227 / 2540, cm:7227 / 254, "in":72.27, bp:1.00375, pc:12, dd:1238 / 1157, cc:14856 / 1157, nd:685 / 642, nc:1370 / 107, sp:1 / 65536, px:1.00375}, relativeUnit = {ex:!0, em:!0, mu:!0}, validUnit = function(unit) {
        "string" !== typeof unit && (unit = unit.unit);
        return unit in ptPerUnit || unit in relativeUnit || "ex" === unit;
      }, calculateSize = function(sizeValue, options) {
        let scale;
        if (sizeValue.unit in ptPerUnit) {
          scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
        } else if ("mu" === sizeValue.unit) {
          scale = options.fontMetrics().cssEmPerMu;
        } else {
          let unitOptions;
          unitOptions = options.style.isTight() ? options.havingStyle(options.style.text()) : options;
          if ("ex" === sizeValue.unit) {
            scale = unitOptions.fontMetrics().xHeight;
          } else if ("em" === sizeValue.unit) {
            scale = unitOptions.fontMetrics().quad;
          } else {
            throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
          }
          unitOptions !== options && (scale *= unitOptions.sizeMultiplier / options.sizeMultiplier);
        }
        return Math.min(sizeValue.number * scale, options.maxSize);
      }, makeEm = function(n) {
        return +n.toFixed(4) + "em";
      }, createClass = function(classes) {
        return classes.filter(cls => cls).join(" ");
      }, initNode = function(classes, options, style) {
        this.classes = classes || [];
        this.attributes = {};
        this.maxFontSize = this.depth = this.height = 0;
        this.style = style || {};
        options && (options.style.isTight() && this.classes.push("mtight"), classes = options.getColor()) && (this.style.color = classes);
      }, toNode = function(tagName) {
        tagName = document.createElement(tagName);
        tagName.className = createClass(this.classes);
        for (var style in this.style) {
          this.style.hasOwnProperty(style) && (tagName.style[style] = this.style[style]);
        }
        for (const attr in this.attributes) {
          this.attributes.hasOwnProperty(attr) && tagName.setAttribute(attr, this.attributes[attr]);
        }
        for (style = 0; style < this.children.length; style++) {
          tagName.appendChild(this.children[style].toNode());
        }
        return tagName;
      }, toMarkup = function(tagName) {
        let markup = "\x3c" + tagName;
        this.classes.length && (markup += ' class\x3d"' + utils.escape(createClass(this.classes)) + '"');
        var styles = "";
        for (const style in this.style) {
          this.style.hasOwnProperty(style) && (styles += utils.hyphenate(style) + ":" + this.style[style] + ";");
        }
        styles && (markup += ' style\x3d"' + utils.escape(styles) + '"');
        for (const attr in this.attributes) {
          this.attributes.hasOwnProperty(attr) && (markup += " " + attr + '\x3d"' + utils.escape(this.attributes[attr]) + '"');
        }
        markup += "\x3e";
        for (styles = 0; styles < this.children.length; styles++) {
          markup += this.children[styles].toMarkup();
        }
        return markup + ("\x3c/" + tagName + "\x3e");
      };
      class Span {
        constructor(classes, children, options, style) {
          this.style = this.maxFontSize = this.width = this.depth = this.height = this.classes = this.attributes = this.children = void 0;
          initNode.call(this, classes, options, style);
          this.children = children || [];
        }
        setAttribute(attribute, value) {
          this.attributes[attribute] = value;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          return toNode.call(this, "span");
        }
        toMarkup() {
          return toMarkup.call(this, "span");
        }
      }
      class Anchor {
        constructor(href, classes, children, options) {
          this.style = this.maxFontSize = this.depth = this.height = this.classes = this.attributes = this.children = void 0;
          initNode.call(this, classes, options);
          this.children = children || [];
          this.setAttribute("href", href);
        }
        setAttribute(attribute, value) {
          this.attributes[attribute] = value;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          return toNode.call(this, "a");
        }
        toMarkup() {
          return toMarkup.call(this, "a");
        }
      }
      class Img {
        constructor(src, alt, style) {
          this.style = this.maxFontSize = this.depth = this.height = this.classes = this.alt = this.src = void 0;
          this.alt = alt;
          this.src = src;
          this.classes = ["mord"];
          this.style = style;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          const node = document.createElement("img");
          node.src = this.src;
          node.alt = this.alt;
          node.className = "mord";
          for (const style in this.style) {
            this.style.hasOwnProperty(style) && (node.style[style] = this.style[style]);
          }
          return node;
        }
        toMarkup() {
          let markup = '\x3cimg src\x3d"' + utils.escape(this.src) + '" alt\x3d"' + (utils.escape(this.alt) + '"'), styles = "";
          for (const style in this.style) {
            this.style.hasOwnProperty(style) && (styles += utils.hyphenate(style) + ":" + this.style[style] + ";");
          }
          styles && (markup += ' style\x3d"' + utils.escape(styles) + '"');
          return markup + "'/\x3e";
        }
      }
      const iCombinations = {"î":"ı̂", "ï":"ı̈", "í":"ı́", "ì":"ı̀"};
      class SymbolNode {
        constructor(text, height, depth, italic, skew, width, classes, style) {
          this.style = this.classes = this.maxFontSize = this.width = this.skew = this.italic = this.depth = this.height = this.text = void 0;
          this.text = text;
          this.height = height || 0;
          this.depth = depth || 0;
          this.italic = italic || 0;
          this.skew = skew || 0;
          this.width = width || 0;
          this.classes = classes || [];
          this.style = style || {};
          this.maxFontSize = 0;
          a: {
            text = this.text.charCodeAt(0);
            for (height = 0; height < scriptData.length; height++) {
              for (depth = scriptData[height], italic = 0; italic < depth.blocks.length; italic++) {
                if (skew = depth.blocks[italic], text >= skew[0] && text <= skew[1]) {
                  text = depth.name;
                  break a;
                }
              }
            }
            text = null;
          }
          text && this.classes.push(text + "_fallback");
          /[îïíì]/.test(this.text) && (this.text = iCombinations[this.text]);
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          const node = document.createTextNode(this.text);
          let span = null;
          0 < this.italic && (span = document.createElement("span"), span.style.marginRight = makeEm(this.italic));
          0 < this.classes.length && (span = span || document.createElement("span"), span.className = createClass(this.classes));
          for (const style in this.style) {
            this.style.hasOwnProperty(style) && (span = span || document.createElement("span"), span.style[style] = this.style[style]);
          }
          return span ? (span.appendChild(node), span) : node;
        }
        toMarkup() {
          let needsSpan = !1, markup = "\x3cspan";
          this.classes.length && (needsSpan = !0, markup = markup + ' class\x3d"' + utils.escape(createClass(this.classes)), markup += '"');
          var styles = "";
          0 < this.italic && (styles += "margin-right:" + this.italic + "em;");
          for (const style in this.style) {
            this.style.hasOwnProperty(style) && (styles += utils.hyphenate(style) + ":" + this.style[style] + ";");
          }
          styles && (needsSpan = !0, markup += ' style\x3d"' + utils.escape(styles) + '"');
          styles = utils.escape(this.text);
          return needsSpan ? markup + "\x3e" + styles + "\x3c/span\x3e" : styles;
        }
      }
      class SvgNode {
        constructor(children, attributes) {
          this.attributes = this.children = void 0;
          this.children = children || [];
          this.attributes = attributes || {};
        }
        toNode() {
          const node = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          for (var attr in this.attributes) {
            Object.prototype.hasOwnProperty.call(this.attributes, attr) && node.setAttribute(attr, this.attributes[attr]);
          }
          for (attr = 0; attr < this.children.length; attr++) {
            node.appendChild(this.children[attr].toNode());
          }
          return node;
        }
        toMarkup() {
          let markup = '\x3csvg xmlns\x3d"http://www.w3.org/2000/svg"';
          for (var attr in this.attributes) {
            Object.prototype.hasOwnProperty.call(this.attributes, attr) && (markup += " " + attr + '\x3d"' + utils.escape(this.attributes[attr]) + '"');
          }
          markup += "\x3e";
          for (attr = 0; attr < this.children.length; attr++) {
            markup += this.children[attr].toMarkup();
          }
          return markup + "\x3c/svg\x3e";
        }
      }
      class PathNode {
        constructor(pathName, alternate) {
          this.alternate = this.pathName = void 0;
          this.pathName = pathName;
          this.alternate = alternate;
        }
        toNode() {
          const node = document.createElementNS("http://www.w3.org/2000/svg", "path");
          this.alternate ? node.setAttribute("d", this.alternate) : node.setAttribute("d", path[this.pathName]);
          return node;
        }
        toMarkup() {
          return this.alternate ? '\x3cpath d\x3d"' + utils.escape(this.alternate) + '"/\x3e' : '\x3cpath d\x3d"' + utils.escape(path[this.pathName]) + '"/\x3e';
        }
      }
      class LineNode {
        constructor(attributes) {
          this.attributes = void 0;
          this.attributes = attributes || {};
        }
        toNode() {
          const node = document.createElementNS("http://www.w3.org/2000/svg", "line");
          for (const attr in this.attributes) {
            Object.prototype.hasOwnProperty.call(this.attributes, attr) && node.setAttribute(attr, this.attributes[attr]);
          }
          return node;
        }
        toMarkup() {
          let markup = "\x3cline";
          for (const attr in this.attributes) {
            Object.prototype.hasOwnProperty.call(this.attributes, attr) && (markup += " " + attr + '\x3d"' + utils.escape(this.attributes[attr]) + '"');
          }
          return markup + "/\x3e";
        }
      }
      const ATOMS = {bin:1, close:1, inner:1, open:1, punct:1, rel:1}, NON_ATOMS = {"accent-token":1, mathord:1, "op-token":1, spacing:1, textord:1}, symbols = {math:{}, text:{}};
      var src_symbols = symbols;
      defineSymbol("math", "main", "rel", "≡", "\\equiv", !0);
      defineSymbol("math", "main", "rel", "≺", "\\prec", !0);
      defineSymbol("math", "main", "rel", "≻", "\\succ", !0);
      defineSymbol("math", "main", "rel", "∼", "\\sim", !0);
      defineSymbol("math", "main", "rel", "⊥", "\\perp");
      defineSymbol("math", "main", "rel", "⪯", "\\preceq", !0);
      defineSymbol("math", "main", "rel", "⪰", "\\succeq", !0);
      defineSymbol("math", "main", "rel", "≃", "\\simeq", !0);
      defineSymbol("math", "main", "rel", "∣", "\\mid", !0);
      defineSymbol("math", "main", "rel", "≪", "\\ll", !0);
      defineSymbol("math", "main", "rel", "≫", "\\gg", !0);
      defineSymbol("math", "main", "rel", "≍", "\\asymp", !0);
      defineSymbol("math", "main", "rel", "∥", "\\parallel");
      defineSymbol("math", "main", "rel", "⋈", "\\bowtie", !0);
      defineSymbol("math", "main", "rel", "⌣", "\\smile", !0);
      defineSymbol("math", "main", "rel", "⊑", "\\sqsubseteq", !0);
      defineSymbol("math", "main", "rel", "⊒", "\\sqsupseteq", !0);
      defineSymbol("math", "main", "rel", "≐", "\\doteq", !0);
      defineSymbol("math", "main", "rel", "⌢", "\\frown", !0);
      defineSymbol("math", "main", "rel", "∋", "\\ni", !0);
      defineSymbol("math", "main", "rel", "∝", "\\propto", !0);
      defineSymbol("math", "main", "rel", "⊢", "\\vdash", !0);
      defineSymbol("math", "main", "rel", "⊣", "\\dashv", !0);
      defineSymbol("math", "main", "rel", "∋", "\\owns");
      defineSymbol("math", "main", "punct", ".", "\\ldotp");
      defineSymbol("math", "main", "punct", "⋅", "\\cdotp");
      defineSymbol("math", "main", "textord", "#", "\\#");
      defineSymbol("text", "main", "textord", "#", "\\#");
      defineSymbol("math", "main", "textord", "\x26", "\\\x26");
      defineSymbol("text", "main", "textord", "\x26", "\\\x26");
      defineSymbol("math", "main", "textord", "ℵ", "\\aleph", !0);
      defineSymbol("math", "main", "textord", "∀", "\\forall", !0);
      defineSymbol("math", "main", "textord", "ℏ", "\\hbar", !0);
      defineSymbol("math", "main", "textord", "∃", "\\exists", !0);
      defineSymbol("math", "main", "textord", "∇", "\\nabla", !0);
      defineSymbol("math", "main", "textord", "♭", "\\flat", !0);
      defineSymbol("math", "main", "textord", "ℓ", "\\ell", !0);
      defineSymbol("math", "main", "textord", "♮", "\\natural", !0);
      defineSymbol("math", "main", "textord", "♣", "\\clubsuit", !0);
      defineSymbol("math", "main", "textord", "℘", "\\wp", !0);
      defineSymbol("math", "main", "textord", "♯", "\\sharp", !0);
      defineSymbol("math", "main", "textord", "♢", "\\diamondsuit", !0);
      defineSymbol("math", "main", "textord", "ℜ", "\\Re", !0);
      defineSymbol("math", "main", "textord", "♡", "\\heartsuit", !0);
      defineSymbol("math", "main", "textord", "ℑ", "\\Im", !0);
      defineSymbol("math", "main", "textord", "♠", "\\spadesuit", !0);
      defineSymbol("math", "main", "textord", "§", "\\S", !0);
      defineSymbol("text", "main", "textord", "§", "\\S");
      defineSymbol("math", "main", "textord", "¶", "\\P", !0);
      defineSymbol("text", "main", "textord", "¶", "\\P");
      defineSymbol("math", "main", "textord", "†", "\\dag");
      defineSymbol("text", "main", "textord", "†", "\\dag");
      defineSymbol("text", "main", "textord", "†", "\\textdagger");
      defineSymbol("math", "main", "textord", "‡", "\\ddag");
      defineSymbol("text", "main", "textord", "‡", "\\ddag");
      defineSymbol("text", "main", "textord", "‡", "\\textdaggerdbl");
      defineSymbol("math", "main", "close", "⎱", "\\rmoustache", !0);
      defineSymbol("math", "main", "open", "⎰", "\\lmoustache", !0);
      defineSymbol("math", "main", "close", "⟯", "\\rgroup", !0);
      defineSymbol("math", "main", "open", "⟮", "\\lgroup", !0);
      defineSymbol("math", "main", "bin", "∓", "\\mp", !0);
      defineSymbol("math", "main", "bin", "⊖", "\\ominus", !0);
      defineSymbol("math", "main", "bin", "⊎", "\\uplus", !0);
      defineSymbol("math", "main", "bin", "⊓", "\\sqcap", !0);
      defineSymbol("math", "main", "bin", "∗", "\\ast");
      defineSymbol("math", "main", "bin", "⊔", "\\sqcup", !0);
      defineSymbol("math", "main", "bin", "◯", "\\bigcirc", !0);
      defineSymbol("math", "main", "bin", "∙", "\\bullet", !0);
      defineSymbol("math", "main", "bin", "‡", "\\ddagger");
      defineSymbol("math", "main", "bin", "≀", "\\wr", !0);
      defineSymbol("math", "main", "bin", "⨿", "\\amalg");
      defineSymbol("math", "main", "bin", "\x26", "\\And");
      defineSymbol("math", "main", "rel", "⟵", "\\longleftarrow", !0);
      defineSymbol("math", "main", "rel", "⇐", "\\Leftarrow", !0);
      defineSymbol("math", "main", "rel", "⟸", "\\Longleftarrow", !0);
      defineSymbol("math", "main", "rel", "⟶", "\\longrightarrow", !0);
      defineSymbol("math", "main", "rel", "⇒", "\\Rightarrow", !0);
      defineSymbol("math", "main", "rel", "⟹", "\\Longrightarrow", !0);
      defineSymbol("math", "main", "rel", "↔", "\\leftrightarrow", !0);
      defineSymbol("math", "main", "rel", "⟷", "\\longleftrightarrow", !0);
      defineSymbol("math", "main", "rel", "⇔", "\\Leftrightarrow", !0);
      defineSymbol("math", "main", "rel", "⟺", "\\Longleftrightarrow", !0);
      defineSymbol("math", "main", "rel", "↦", "\\mapsto", !0);
      defineSymbol("math", "main", "rel", "⟼", "\\longmapsto", !0);
      defineSymbol("math", "main", "rel", "↗", "\\nearrow", !0);
      defineSymbol("math", "main", "rel", "↩", "\\hookleftarrow", !0);
      defineSymbol("math", "main", "rel", "↪", "\\hookrightarrow", !0);
      defineSymbol("math", "main", "rel", "↘", "\\searrow", !0);
      defineSymbol("math", "main", "rel", "↼", "\\leftharpoonup", !0);
      defineSymbol("math", "main", "rel", "⇀", "\\rightharpoonup", !0);
      defineSymbol("math", "main", "rel", "↙", "\\swarrow", !0);
      defineSymbol("math", "main", "rel", "↽", "\\leftharpoondown", !0);
      defineSymbol("math", "main", "rel", "⇁", "\\rightharpoondown", !0);
      defineSymbol("math", "main", "rel", "↖", "\\nwarrow", !0);
      defineSymbol("math", "main", "rel", "⇌", "\\rightleftharpoons", !0);
      defineSymbol("math", "ams", "rel", "≮", "\\nless", !0);
      defineSymbol("math", "ams", "rel", "", "\\@nleqslant");
      defineSymbol("math", "ams", "rel", "", "\\@nleqq");
      defineSymbol("math", "ams", "rel", "⪇", "\\lneq", !0);
      defineSymbol("math", "ams", "rel", "≨", "\\lneqq", !0);
      defineSymbol("math", "ams", "rel", "", "\\@lvertneqq");
      defineSymbol("math", "ams", "rel", "⋦", "\\lnsim", !0);
      defineSymbol("math", "ams", "rel", "⪉", "\\lnapprox", !0);
      defineSymbol("math", "ams", "rel", "⊀", "\\nprec", !0);
      defineSymbol("math", "ams", "rel", "⋠", "\\npreceq", !0);
      defineSymbol("math", "ams", "rel", "⋨", "\\precnsim", !0);
      defineSymbol("math", "ams", "rel", "⪹", "\\precnapprox", !0);
      defineSymbol("math", "ams", "rel", "≁", "\\nsim", !0);
      defineSymbol("math", "ams", "rel", "", "\\@nshortmid");
      defineSymbol("math", "ams", "rel", "∤", "\\nmid", !0);
      defineSymbol("math", "ams", "rel", "⊬", "\\nvdash", !0);
      defineSymbol("math", "ams", "rel", "⊭", "\\nvDash", !0);
      defineSymbol("math", "ams", "rel", "⋪", "\\ntriangleleft");
      defineSymbol("math", "ams", "rel", "⋬", "\\ntrianglelefteq", !0);
      defineSymbol("math", "ams", "rel", "⊊", "\\subsetneq", !0);
      defineSymbol("math", "ams", "rel", "", "\\@varsubsetneq");
      defineSymbol("math", "ams", "rel", "⫋", "\\subsetneqq", !0);
      defineSymbol("math", "ams", "rel", "", "\\@varsubsetneqq");
      defineSymbol("math", "ams", "rel", "≯", "\\ngtr", !0);
      defineSymbol("math", "ams", "rel", "", "\\@ngeqslant");
      defineSymbol("math", "ams", "rel", "", "\\@ngeqq");
      defineSymbol("math", "ams", "rel", "⪈", "\\gneq", !0);
      defineSymbol("math", "ams", "rel", "≩", "\\gneqq", !0);
      defineSymbol("math", "ams", "rel", "", "\\@gvertneqq");
      defineSymbol("math", "ams", "rel", "⋧", "\\gnsim", !0);
      defineSymbol("math", "ams", "rel", "⪊", "\\gnapprox", !0);
      defineSymbol("math", "ams", "rel", "⊁", "\\nsucc", !0);
      defineSymbol("math", "ams", "rel", "⋡", "\\nsucceq", !0);
      defineSymbol("math", "ams", "rel", "⋩", "\\succnsim", !0);
      defineSymbol("math", "ams", "rel", "⪺", "\\succnapprox", !0);
      defineSymbol("math", "ams", "rel", "≆", "\\ncong", !0);
      defineSymbol("math", "ams", "rel", "", "\\@nshortparallel");
      defineSymbol("math", "ams", "rel", "∦", "\\nparallel", !0);
      defineSymbol("math", "ams", "rel", "⊯", "\\nVDash", !0);
      defineSymbol("math", "ams", "rel", "⋫", "\\ntriangleright");
      defineSymbol("math", "ams", "rel", "⋭", "\\ntrianglerighteq", !0);
      defineSymbol("math", "ams", "rel", "", "\\@nsupseteqq");
      defineSymbol("math", "ams", "rel", "⊋", "\\supsetneq", !0);
      defineSymbol("math", "ams", "rel", "", "\\@varsupsetneq");
      defineSymbol("math", "ams", "rel", "⫌", "\\supsetneqq", !0);
      defineSymbol("math", "ams", "rel", "", "\\@varsupsetneqq");
      defineSymbol("math", "ams", "rel", "⊮", "\\nVdash", !0);
      defineSymbol("math", "ams", "rel", "⪵", "\\precneqq", !0);
      defineSymbol("math", "ams", "rel", "⪶", "\\succneqq", !0);
      defineSymbol("math", "ams", "rel", "", "\\@nsubseteqq");
      defineSymbol("math", "ams", "bin", "⊴", "\\unlhd");
      defineSymbol("math", "ams", "bin", "⊵", "\\unrhd");
      defineSymbol("math", "ams", "rel", "↚", "\\nleftarrow", !0);
      defineSymbol("math", "ams", "rel", "↛", "\\nrightarrow", !0);
      defineSymbol("math", "ams", "rel", "⇍", "\\nLeftarrow", !0);
      defineSymbol("math", "ams", "rel", "⇏", "\\nRightarrow", !0);
      defineSymbol("math", "ams", "rel", "↮", "\\nleftrightarrow", !0);
      defineSymbol("math", "ams", "rel", "⇎", "\\nLeftrightarrow", !0);
      defineSymbol("math", "ams", "rel", "△", "\\vartriangle");
      defineSymbol("math", "ams", "textord", "ℏ", "\\hslash");
      defineSymbol("math", "ams", "textord", "▽", "\\triangledown");
      defineSymbol("math", "ams", "textord", "◊", "\\lozenge");
      defineSymbol("math", "ams", "textord", "Ⓢ", "\\circledS");
      defineSymbol("math", "ams", "textord", "®", "\\circledR");
      defineSymbol("text", "ams", "textord", "®", "\\circledR");
      defineSymbol("math", "ams", "textord", "∡", "\\measuredangle", !0);
      defineSymbol("math", "ams", "textord", "∄", "\\nexists");
      defineSymbol("math", "ams", "textord", "℧", "\\mho");
      defineSymbol("math", "ams", "textord", "Ⅎ", "\\Finv", !0);
      defineSymbol("math", "ams", "textord", "⅁", "\\Game", !0);
      defineSymbol("math", "ams", "textord", "‵", "\\backprime");
      defineSymbol("math", "ams", "textord", "▲", "\\blacktriangle");
      defineSymbol("math", "ams", "textord", "▼", "\\blacktriangledown");
      defineSymbol("math", "ams", "textord", "■", "\\blacksquare");
      defineSymbol("math", "ams", "textord", "⧫", "\\blacklozenge");
      defineSymbol("math", "ams", "textord", "★", "\\bigstar");
      defineSymbol("math", "ams", "textord", "∢", "\\sphericalangle", !0);
      defineSymbol("math", "ams", "textord", "∁", "\\complement", !0);
      defineSymbol("math", "ams", "textord", "ð", "\\eth", !0);
      defineSymbol("text", "main", "textord", "ð", "ð");
      defineSymbol("math", "ams", "textord", "╱", "\\diagup");
      defineSymbol("math", "ams", "textord", "╲", "\\diagdown");
      defineSymbol("math", "ams", "textord", "□", "\\square");
      defineSymbol("math", "ams", "textord", "□", "\\Box");
      defineSymbol("math", "ams", "textord", "◊", "\\Diamond");
      defineSymbol("math", "ams", "textord", "¥", "\\yen", !0);
      defineSymbol("text", "ams", "textord", "¥", "\\yen", !0);
      defineSymbol("math", "ams", "textord", "✓", "\\checkmark", !0);
      defineSymbol("text", "ams", "textord", "✓", "\\checkmark");
      defineSymbol("math", "ams", "textord", "ℶ", "\\beth", !0);
      defineSymbol("math", "ams", "textord", "ℸ", "\\daleth", !0);
      defineSymbol("math", "ams", "textord", "ℷ", "\\gimel", !0);
      defineSymbol("math", "ams", "textord", "ϝ", "\\digamma", !0);
      defineSymbol("math", "ams", "textord", "ϰ", "\\varkappa");
      defineSymbol("math", "ams", "open", "┌", "\\@ulcorner", !0);
      defineSymbol("math", "ams", "close", "┐", "\\@urcorner", !0);
      defineSymbol("math", "ams", "open", "└", "\\@llcorner", !0);
      defineSymbol("math", "ams", "close", "┘", "\\@lrcorner", !0);
      defineSymbol("math", "ams", "rel", "≦", "\\leqq", !0);
      defineSymbol("math", "ams", "rel", "⩽", "\\leqslant", !0);
      defineSymbol("math", "ams", "rel", "⪕", "\\eqslantless", !0);
      defineSymbol("math", "ams", "rel", "≲", "\\lesssim", !0);
      defineSymbol("math", "ams", "rel", "⪅", "\\lessapprox", !0);
      defineSymbol("math", "ams", "rel", "≊", "\\approxeq", !0);
      defineSymbol("math", "ams", "bin", "⋖", "\\lessdot");
      defineSymbol("math", "ams", "rel", "⋘", "\\lll", !0);
      defineSymbol("math", "ams", "rel", "≶", "\\lessgtr", !0);
      defineSymbol("math", "ams", "rel", "⋚", "\\lesseqgtr", !0);
      defineSymbol("math", "ams", "rel", "⪋", "\\lesseqqgtr", !0);
      defineSymbol("math", "ams", "rel", "≑", "\\doteqdot");
      defineSymbol("math", "ams", "rel", "≓", "\\risingdotseq", !0);
      defineSymbol("math", "ams", "rel", "≒", "\\fallingdotseq", !0);
      defineSymbol("math", "ams", "rel", "∽", "\\backsim", !0);
      defineSymbol("math", "ams", "rel", "⋍", "\\backsimeq", !0);
      defineSymbol("math", "ams", "rel", "⫅", "\\subseteqq", !0);
      defineSymbol("math", "ams", "rel", "⋐", "\\Subset", !0);
      defineSymbol("math", "ams", "rel", "⊏", "\\sqsubset", !0);
      defineSymbol("math", "ams", "rel", "≼", "\\preccurlyeq", !0);
      defineSymbol("math", "ams", "rel", "⋞", "\\curlyeqprec", !0);
      defineSymbol("math", "ams", "rel", "≾", "\\precsim", !0);
      defineSymbol("math", "ams", "rel", "⪷", "\\precapprox", !0);
      defineSymbol("math", "ams", "rel", "⊲", "\\vartriangleleft");
      defineSymbol("math", "ams", "rel", "⊴", "\\trianglelefteq");
      defineSymbol("math", "ams", "rel", "⊨", "\\vDash", !0);
      defineSymbol("math", "ams", "rel", "⊪", "\\Vvdash", !0);
      defineSymbol("math", "ams", "rel", "⌣", "\\smallsmile");
      defineSymbol("math", "ams", "rel", "⌢", "\\smallfrown");
      defineSymbol("math", "ams", "rel", "≏", "\\bumpeq", !0);
      defineSymbol("math", "ams", "rel", "≎", "\\Bumpeq", !0);
      defineSymbol("math", "ams", "rel", "≧", "\\geqq", !0);
      defineSymbol("math", "ams", "rel", "⩾", "\\geqslant", !0);
      defineSymbol("math", "ams", "rel", "⪖", "\\eqslantgtr", !0);
      defineSymbol("math", "ams", "rel", "≳", "\\gtrsim", !0);
      defineSymbol("math", "ams", "rel", "⪆", "\\gtrapprox", !0);
      defineSymbol("math", "ams", "bin", "⋗", "\\gtrdot");
      defineSymbol("math", "ams", "rel", "⋙", "\\ggg", !0);
      defineSymbol("math", "ams", "rel", "≷", "\\gtrless", !0);
      defineSymbol("math", "ams", "rel", "⋛", "\\gtreqless", !0);
      defineSymbol("math", "ams", "rel", "⪌", "\\gtreqqless", !0);
      defineSymbol("math", "ams", "rel", "≖", "\\eqcirc", !0);
      defineSymbol("math", "ams", "rel", "≗", "\\circeq", !0);
      defineSymbol("math", "ams", "rel", "≜", "\\triangleq", !0);
      defineSymbol("math", "ams", "rel", "∼", "\\thicksim");
      defineSymbol("math", "ams", "rel", "≈", "\\thickapprox");
      defineSymbol("math", "ams", "rel", "⫆", "\\supseteqq", !0);
      defineSymbol("math", "ams", "rel", "⋑", "\\Supset", !0);
      defineSymbol("math", "ams", "rel", "⊐", "\\sqsupset", !0);
      defineSymbol("math", "ams", "rel", "≽", "\\succcurlyeq", !0);
      defineSymbol("math", "ams", "rel", "⋟", "\\curlyeqsucc", !0);
      defineSymbol("math", "ams", "rel", "≿", "\\succsim", !0);
      defineSymbol("math", "ams", "rel", "⪸", "\\succapprox", !0);
      defineSymbol("math", "ams", "rel", "⊳", "\\vartriangleright");
      defineSymbol("math", "ams", "rel", "⊵", "\\trianglerighteq");
      defineSymbol("math", "ams", "rel", "⊩", "\\Vdash", !0);
      defineSymbol("math", "ams", "rel", "∣", "\\shortmid");
      defineSymbol("math", "ams", "rel", "∥", "\\shortparallel");
      defineSymbol("math", "ams", "rel", "≬", "\\between", !0);
      defineSymbol("math", "ams", "rel", "⋔", "\\pitchfork", !0);
      defineSymbol("math", "ams", "rel", "∝", "\\varpropto");
      defineSymbol("math", "ams", "rel", "◀", "\\blacktriangleleft");
      defineSymbol("math", "ams", "rel", "∴", "\\therefore", !0);
      defineSymbol("math", "ams", "rel", "∍", "\\backepsilon");
      defineSymbol("math", "ams", "rel", "▶", "\\blacktriangleright");
      defineSymbol("math", "ams", "rel", "∵", "\\because", !0);
      defineSymbol("math", "ams", "rel", "⋘", "\\llless");
      defineSymbol("math", "ams", "rel", "⋙", "\\gggtr");
      defineSymbol("math", "ams", "bin", "⊲", "\\lhd");
      defineSymbol("math", "ams", "bin", "⊳", "\\rhd");
      defineSymbol("math", "ams", "rel", "≂", "\\eqsim", !0);
      defineSymbol("math", "main", "rel", "⋈", "\\Join");
      defineSymbol("math", "ams", "rel", "≑", "\\Doteq", !0);
      defineSymbol("math", "ams", "bin", "∔", "\\dotplus", !0);
      defineSymbol("math", "ams", "bin", "∖", "\\smallsetminus");
      defineSymbol("math", "ams", "bin", "⋒", "\\Cap", !0);
      defineSymbol("math", "ams", "bin", "⋓", "\\Cup", !0);
      defineSymbol("math", "ams", "bin", "⩞", "\\doublebarwedge", !0);
      defineSymbol("math", "ams", "bin", "⊟", "\\boxminus", !0);
      defineSymbol("math", "ams", "bin", "⊞", "\\boxplus", !0);
      defineSymbol("math", "ams", "bin", "⋇", "\\divideontimes", !0);
      defineSymbol("math", "ams", "bin", "⋉", "\\ltimes", !0);
      defineSymbol("math", "ams", "bin", "⋊", "\\rtimes", !0);
      defineSymbol("math", "ams", "bin", "⋋", "\\leftthreetimes", !0);
      defineSymbol("math", "ams", "bin", "⋌", "\\rightthreetimes", !0);
      defineSymbol("math", "ams", "bin", "⋏", "\\curlywedge", !0);
      defineSymbol("math", "ams", "bin", "⋎", "\\curlyvee", !0);
      defineSymbol("math", "ams", "bin", "⊝", "\\circleddash", !0);
      defineSymbol("math", "ams", "bin", "⊛", "\\circledast", !0);
      defineSymbol("math", "ams", "bin", "⋅", "\\centerdot");
      defineSymbol("math", "ams", "bin", "⊺", "\\intercal", !0);
      defineSymbol("math", "ams", "bin", "⋒", "\\doublecap");
      defineSymbol("math", "ams", "bin", "⋓", "\\doublecup");
      defineSymbol("math", "ams", "bin", "⊠", "\\boxtimes", !0);
      defineSymbol("math", "ams", "rel", "⇢", "\\dashrightarrow", !0);
      defineSymbol("math", "ams", "rel", "⇠", "\\dashleftarrow", !0);
      defineSymbol("math", "ams", "rel", "⇇", "\\leftleftarrows", !0);
      defineSymbol("math", "ams", "rel", "⇆", "\\leftrightarrows", !0);
      defineSymbol("math", "ams", "rel", "⇚", "\\Lleftarrow", !0);
      defineSymbol("math", "ams", "rel", "↞", "\\twoheadleftarrow", !0);
      defineSymbol("math", "ams", "rel", "↢", "\\leftarrowtail", !0);
      defineSymbol("math", "ams", "rel", "↫", "\\looparrowleft", !0);
      defineSymbol("math", "ams", "rel", "⇋", "\\leftrightharpoons", !0);
      defineSymbol("math", "ams", "rel", "↶", "\\curvearrowleft", !0);
      defineSymbol("math", "ams", "rel", "↺", "\\circlearrowleft", !0);
      defineSymbol("math", "ams", "rel", "↰", "\\Lsh", !0);
      defineSymbol("math", "ams", "rel", "⇈", "\\upuparrows", !0);
      defineSymbol("math", "ams", "rel", "↿", "\\upharpoonleft", !0);
      defineSymbol("math", "ams", "rel", "⇃", "\\downharpoonleft", !0);
      defineSymbol("math", "main", "rel", "⊶", "\\origof", !0);
      defineSymbol("math", "main", "rel", "⊷", "\\imageof", !0);
      defineSymbol("math", "ams", "rel", "⊸", "\\multimap", !0);
      defineSymbol("math", "ams", "rel", "↭", "\\leftrightsquigarrow", !0);
      defineSymbol("math", "ams", "rel", "⇉", "\\rightrightarrows", !0);
      defineSymbol("math", "ams", "rel", "⇄", "\\rightleftarrows", !0);
      defineSymbol("math", "ams", "rel", "↠", "\\twoheadrightarrow", !0);
      defineSymbol("math", "ams", "rel", "↣", "\\rightarrowtail", !0);
      defineSymbol("math", "ams", "rel", "↬", "\\looparrowright", !0);
      defineSymbol("math", "ams", "rel", "↷", "\\curvearrowright", !0);
      defineSymbol("math", "ams", "rel", "↻", "\\circlearrowright", !0);
      defineSymbol("math", "ams", "rel", "↱", "\\Rsh", !0);
      defineSymbol("math", "ams", "rel", "⇊", "\\downdownarrows", !0);
      defineSymbol("math", "ams", "rel", "↾", "\\upharpoonright", !0);
      defineSymbol("math", "ams", "rel", "⇂", "\\downharpoonright", !0);
      defineSymbol("math", "ams", "rel", "⇝", "\\rightsquigarrow", !0);
      defineSymbol("math", "ams", "rel", "⇝", "\\leadsto");
      defineSymbol("math", "ams", "rel", "⇛", "\\Rrightarrow", !0);
      defineSymbol("math", "ams", "rel", "↾", "\\restriction");
      defineSymbol("math", "main", "textord", "‘", "`");
      defineSymbol("math", "main", "textord", "$", "\\$");
      defineSymbol("text", "main", "textord", "$", "\\$");
      defineSymbol("text", "main", "textord", "$", "\\textdollar");
      defineSymbol("math", "main", "textord", "%", "\\%");
      defineSymbol("text", "main", "textord", "%", "\\%");
      defineSymbol("math", "main", "textord", "_", "\\_");
      defineSymbol("text", "main", "textord", "_", "\\_");
      defineSymbol("text", "main", "textord", "_", "\\textunderscore");
      defineSymbol("math", "main", "textord", "∠", "\\angle", !0);
      defineSymbol("math", "main", "textord", "∞", "\\infty", !0);
      defineSymbol("math", "main", "textord", "′", "\\prime");
      defineSymbol("math", "main", "textord", "△", "\\triangle");
      defineSymbol("math", "main", "textord", "Γ", "\\Gamma", !0);
      defineSymbol("math", "main", "textord", "Δ", "\\Delta", !0);
      defineSymbol("math", "main", "textord", "Θ", "\\Theta", !0);
      defineSymbol("math", "main", "textord", "Λ", "\\Lambda", !0);
      defineSymbol("math", "main", "textord", "Ξ", "\\Xi", !0);
      defineSymbol("math", "main", "textord", "Π", "\\Pi", !0);
      defineSymbol("math", "main", "textord", "Σ", "\\Sigma", !0);
      defineSymbol("math", "main", "textord", "Υ", "\\Upsilon", !0);
      defineSymbol("math", "main", "textord", "Φ", "\\Phi", !0);
      defineSymbol("math", "main", "textord", "Ψ", "\\Psi", !0);
      defineSymbol("math", "main", "textord", "Ω", "\\Omega", !0);
      defineSymbol("math", "main", "textord", "A", "Α");
      defineSymbol("math", "main", "textord", "B", "Β");
      defineSymbol("math", "main", "textord", "E", "Ε");
      defineSymbol("math", "main", "textord", "Z", "Ζ");
      defineSymbol("math", "main", "textord", "H", "Η");
      defineSymbol("math", "main", "textord", "I", "Ι");
      defineSymbol("math", "main", "textord", "K", "Κ");
      defineSymbol("math", "main", "textord", "M", "Μ");
      defineSymbol("math", "main", "textord", "N", "Ν");
      defineSymbol("math", "main", "textord", "O", "Ο");
      defineSymbol("math", "main", "textord", "P", "Ρ");
      defineSymbol("math", "main", "textord", "T", "Τ");
      defineSymbol("math", "main", "textord", "X", "Χ");
      defineSymbol("math", "main", "textord", "¬", "\\neg", !0);
      defineSymbol("math", "main", "textord", "¬", "\\lnot");
      defineSymbol("math", "main", "textord", "⊤", "\\top");
      defineSymbol("math", "main", "textord", "⊥", "\\bot");
      defineSymbol("math", "main", "textord", "∅", "\\emptyset");
      defineSymbol("math", "ams", "textord", "∅", "\\varnothing");
      defineSymbol("math", "main", "mathord", "α", "\\alpha", !0);
      defineSymbol("math", "main", "mathord", "β", "\\beta", !0);
      defineSymbol("math", "main", "mathord", "γ", "\\gamma", !0);
      defineSymbol("math", "main", "mathord", "δ", "\\delta", !0);
      defineSymbol("math", "main", "mathord", "ϵ", "\\epsilon", !0);
      defineSymbol("math", "main", "mathord", "ζ", "\\zeta", !0);
      defineSymbol("math", "main", "mathord", "η", "\\eta", !0);
      defineSymbol("math", "main", "mathord", "θ", "\\theta", !0);
      defineSymbol("math", "main", "mathord", "ι", "\\iota", !0);
      defineSymbol("math", "main", "mathord", "κ", "\\kappa", !0);
      defineSymbol("math", "main", "mathord", "λ", "\\lambda", !0);
      defineSymbol("math", "main", "mathord", "μ", "\\mu", !0);
      defineSymbol("math", "main", "mathord", "ν", "\\nu", !0);
      defineSymbol("math", "main", "mathord", "ξ", "\\xi", !0);
      defineSymbol("math", "main", "mathord", "ο", "\\omicron", !0);
      defineSymbol("math", "main", "mathord", "π", "\\pi", !0);
      defineSymbol("math", "main", "mathord", "ρ", "\\rho", !0);
      defineSymbol("math", "main", "mathord", "σ", "\\sigma", !0);
      defineSymbol("math", "main", "mathord", "τ", "\\tau", !0);
      defineSymbol("math", "main", "mathord", "υ", "\\upsilon", !0);
      defineSymbol("math", "main", "mathord", "ϕ", "\\phi", !0);
      defineSymbol("math", "main", "mathord", "χ", "\\chi", !0);
      defineSymbol("math", "main", "mathord", "ψ", "\\psi", !0);
      defineSymbol("math", "main", "mathord", "ω", "\\omega", !0);
      defineSymbol("math", "main", "mathord", "ε", "\\varepsilon", !0);
      defineSymbol("math", "main", "mathord", "ϑ", "\\vartheta", !0);
      defineSymbol("math", "main", "mathord", "ϖ", "\\varpi", !0);
      defineSymbol("math", "main", "mathord", "ϱ", "\\varrho", !0);
      defineSymbol("math", "main", "mathord", "ς", "\\varsigma", !0);
      defineSymbol("math", "main", "mathord", "φ", "\\varphi", !0);
      defineSymbol("math", "main", "bin", "∗", "*", !0);
      defineSymbol("math", "main", "bin", "+", "+");
      defineSymbol("math", "main", "bin", "−", "-", !0);
      defineSymbol("math", "main", "bin", "⋅", "\\cdot", !0);
      defineSymbol("math", "main", "bin", "∘", "\\circ", !0);
      defineSymbol("math", "main", "bin", "÷", "\\div", !0);
      defineSymbol("math", "main", "bin", "±", "\\pm", !0);
      defineSymbol("math", "main", "bin", "×", "\\times", !0);
      defineSymbol("math", "main", "bin", "∩", "\\cap", !0);
      defineSymbol("math", "main", "bin", "∪", "\\cup", !0);
      defineSymbol("math", "main", "bin", "∖", "\\setminus", !0);
      defineSymbol("math", "main", "bin", "∧", "\\land");
      defineSymbol("math", "main", "bin", "∨", "\\lor");
      defineSymbol("math", "main", "bin", "∧", "\\wedge", !0);
      defineSymbol("math", "main", "bin", "∨", "\\vee", !0);
      defineSymbol("math", "main", "textord", "√", "\\surd");
      defineSymbol("math", "main", "open", "⟨", "\\langle", !0);
      defineSymbol("math", "main", "open", "∣", "\\lvert");
      defineSymbol("math", "main", "open", "∥", "\\lVert");
      defineSymbol("math", "main", "close", "?", "?");
      defineSymbol("math", "main", "close", "!", "!");
      defineSymbol("math", "main", "close", "⟩", "\\rangle", !0);
      defineSymbol("math", "main", "close", "∣", "\\rvert");
      defineSymbol("math", "main", "close", "∥", "\\rVert");
      defineSymbol("math", "main", "rel", "\x3d", "\x3d");
      defineSymbol("math", "main", "rel", ":", ":");
      defineSymbol("math", "main", "rel", "≈", "\\approx", !0);
      defineSymbol("math", "main", "rel", "≅", "\\cong", !0);
      defineSymbol("math", "main", "rel", "≥", "\\ge");
      defineSymbol("math", "main", "rel", "≥", "\\geq", !0);
      defineSymbol("math", "main", "rel", "←", "\\gets");
      defineSymbol("math", "main", "rel", "\x3e", "\\gt", !0);
      defineSymbol("math", "main", "rel", "∈", "\\in", !0);
      defineSymbol("math", "main", "rel", "", "\\@not");
      defineSymbol("math", "main", "rel", "⊂", "\\subset", !0);
      defineSymbol("math", "main", "rel", "⊃", "\\supset", !0);
      defineSymbol("math", "main", "rel", "⊆", "\\subseteq", !0);
      defineSymbol("math", "main", "rel", "⊇", "\\supseteq", !0);
      defineSymbol("math", "ams", "rel", "⊈", "\\nsubseteq", !0);
      defineSymbol("math", "ams", "rel", "⊉", "\\nsupseteq", !0);
      defineSymbol("math", "main", "rel", "⊨", "\\models");
      defineSymbol("math", "main", "rel", "←", "\\leftarrow", !0);
      defineSymbol("math", "main", "rel", "≤", "\\le");
      defineSymbol("math", "main", "rel", "≤", "\\leq", !0);
      defineSymbol("math", "main", "rel", "\x3c", "\\lt", !0);
      defineSymbol("math", "main", "rel", "→", "\\rightarrow", !0);
      defineSymbol("math", "main", "rel", "→", "\\to");
      defineSymbol("math", "ams", "rel", "≱", "\\ngeq", !0);
      defineSymbol("math", "ams", "rel", "≰", "\\nleq", !0);
      defineSymbol("math", "main", "spacing", " ", "\\ ");
      defineSymbol("math", "main", "spacing", " ", "\\space");
      defineSymbol("math", "main", "spacing", " ", "\\nobreakspace");
      defineSymbol("text", "main", "spacing", " ", "\\ ");
      defineSymbol("text", "main", "spacing", " ", " ");
      defineSymbol("text", "main", "spacing", " ", "\\space");
      defineSymbol("text", "main", "spacing", " ", "\\nobreakspace");
      defineSymbol("math", "main", "spacing", null, "\\nobreak");
      defineSymbol("math", "main", "spacing", null, "\\allowbreak");
      defineSymbol("math", "main", "punct", ",", ",");
      defineSymbol("math", "main", "punct", ";", ";");
      defineSymbol("math", "ams", "bin", "⊼", "\\barwedge", !0);
      defineSymbol("math", "ams", "bin", "⊻", "\\veebar", !0);
      defineSymbol("math", "main", "bin", "⊙", "\\odot", !0);
      defineSymbol("math", "main", "bin", "⊕", "\\oplus", !0);
      defineSymbol("math", "main", "bin", "⊗", "\\otimes", !0);
      defineSymbol("math", "main", "textord", "∂", "\\partial", !0);
      defineSymbol("math", "main", "bin", "⊘", "\\oslash", !0);
      defineSymbol("math", "ams", "bin", "⊚", "\\circledcirc", !0);
      defineSymbol("math", "ams", "bin", "⊡", "\\boxdot", !0);
      defineSymbol("math", "main", "bin", "△", "\\bigtriangleup");
      defineSymbol("math", "main", "bin", "▽", "\\bigtriangledown");
      defineSymbol("math", "main", "bin", "†", "\\dagger");
      defineSymbol("math", "main", "bin", "⋄", "\\diamond");
      defineSymbol("math", "main", "bin", "⋆", "\\star");
      defineSymbol("math", "main", "bin", "◃", "\\triangleleft");
      defineSymbol("math", "main", "bin", "▹", "\\triangleright");
      defineSymbol("math", "main", "open", "{", "\\{");
      defineSymbol("text", "main", "textord", "{", "\\{");
      defineSymbol("text", "main", "textord", "{", "\\textbraceleft");
      defineSymbol("math", "main", "close", "}", "\\}");
      defineSymbol("text", "main", "textord", "}", "\\}");
      defineSymbol("text", "main", "textord", "}", "\\textbraceright");
      defineSymbol("math", "main", "open", "{", "\\lbrace");
      defineSymbol("math", "main", "close", "}", "\\rbrace");
      defineSymbol("math", "main", "open", "[", "\\lbrack", !0);
      defineSymbol("text", "main", "textord", "[", "\\lbrack", !0);
      defineSymbol("math", "main", "close", "]", "\\rbrack", !0);
      defineSymbol("text", "main", "textord", "]", "\\rbrack", !0);
      defineSymbol("math", "main", "open", "(", "\\lparen", !0);
      defineSymbol("math", "main", "close", ")", "\\rparen", !0);
      defineSymbol("text", "main", "textord", "\x3c", "\\textless", !0);
      defineSymbol("text", "main", "textord", "\x3e", "\\textgreater", !0);
      defineSymbol("math", "main", "open", "⌊", "\\lfloor", !0);
      defineSymbol("math", "main", "close", "⌋", "\\rfloor", !0);
      defineSymbol("math", "main", "open", "⌈", "\\lceil", !0);
      defineSymbol("math", "main", "close", "⌉", "\\rceil", !0);
      defineSymbol("math", "main", "textord", "\\", "\\backslash");
      defineSymbol("math", "main", "textord", "∣", "|");
      defineSymbol("math", "main", "textord", "∣", "\\vert");
      defineSymbol("text", "main", "textord", "|", "\\textbar", !0);
      defineSymbol("math", "main", "textord", "∥", "\\|");
      defineSymbol("math", "main", "textord", "∥", "\\Vert");
      defineSymbol("text", "main", "textord", "∥", "\\textbardbl");
      defineSymbol("text", "main", "textord", "~", "\\textasciitilde");
      defineSymbol("text", "main", "textord", "\\", "\\textbackslash");
      defineSymbol("text", "main", "textord", "^", "\\textasciicircum");
      defineSymbol("math", "main", "rel", "↑", "\\uparrow", !0);
      defineSymbol("math", "main", "rel", "⇑", "\\Uparrow", !0);
      defineSymbol("math", "main", "rel", "↓", "\\downarrow", !0);
      defineSymbol("math", "main", "rel", "⇓", "\\Downarrow", !0);
      defineSymbol("math", "main", "rel", "↕", "\\updownarrow", !0);
      defineSymbol("math", "main", "rel", "⇕", "\\Updownarrow", !0);
      defineSymbol("math", "main", "op-token", "∐", "\\coprod");
      defineSymbol("math", "main", "op-token", "⋁", "\\bigvee");
      defineSymbol("math", "main", "op-token", "⋀", "\\bigwedge");
      defineSymbol("math", "main", "op-token", "⨄", "\\biguplus");
      defineSymbol("math", "main", "op-token", "⋂", "\\bigcap");
      defineSymbol("math", "main", "op-token", "⋃", "\\bigcup");
      defineSymbol("math", "main", "op-token", "∫", "\\int");
      defineSymbol("math", "main", "op-token", "∫", "\\intop");
      defineSymbol("math", "main", "op-token", "∬", "\\iint");
      defineSymbol("math", "main", "op-token", "∭", "\\iiint");
      defineSymbol("math", "main", "op-token", "∏", "\\prod");
      defineSymbol("math", "main", "op-token", "∑", "\\sum");
      defineSymbol("math", "main", "op-token", "⨂", "\\bigotimes");
      defineSymbol("math", "main", "op-token", "⨁", "\\bigoplus");
      defineSymbol("math", "main", "op-token", "⨀", "\\bigodot");
      defineSymbol("math", "main", "op-token", "∮", "\\oint");
      defineSymbol("math", "main", "op-token", "∯", "\\oiint");
      defineSymbol("math", "main", "op-token", "∰", "\\oiiint");
      defineSymbol("math", "main", "op-token", "⨆", "\\bigsqcup");
      defineSymbol("math", "main", "op-token", "∫", "\\smallint");
      defineSymbol("text", "main", "inner", "…", "\\textellipsis");
      defineSymbol("math", "main", "inner", "…", "\\mathellipsis");
      defineSymbol("text", "main", "inner", "…", "\\ldots", !0);
      defineSymbol("math", "main", "inner", "…", "\\ldots", !0);
      defineSymbol("math", "main", "inner", "⋯", "\\@cdots", !0);
      defineSymbol("math", "main", "inner", "⋱", "\\ddots", !0);
      defineSymbol("math", "main", "textord", "⋮", "\\varvdots");
      defineSymbol("text", "main", "textord", "⋮", "\\varvdots");
      defineSymbol("math", "main", "accent-token", "ˊ", "\\acute");
      defineSymbol("math", "main", "accent-token", "ˋ", "\\grave");
      defineSymbol("math", "main", "accent-token", "¨", "\\ddot");
      defineSymbol("math", "main", "accent-token", "~", "\\tilde");
      defineSymbol("math", "main", "accent-token", "ˉ", "\\bar");
      defineSymbol("math", "main", "accent-token", "˘", "\\breve");
      defineSymbol("math", "main", "accent-token", "ˇ", "\\check");
      defineSymbol("math", "main", "accent-token", "^", "\\hat");
      defineSymbol("math", "main", "accent-token", "⃗", "\\vec");
      defineSymbol("math", "main", "accent-token", "˙", "\\dot");
      defineSymbol("math", "main", "accent-token", "˚", "\\mathring");
      defineSymbol("math", "main", "mathord", "", "\\@imath");
      defineSymbol("math", "main", "mathord", "", "\\@jmath");
      defineSymbol("math", "main", "textord", "ı", "ı");
      defineSymbol("math", "main", "textord", "ȷ", "ȷ");
      defineSymbol("text", "main", "textord", "ı", "\\i", !0);
      defineSymbol("text", "main", "textord", "ȷ", "\\j", !0);
      defineSymbol("text", "main", "textord", "ß", "\\ss", !0);
      defineSymbol("text", "main", "textord", "æ", "\\ae", !0);
      defineSymbol("text", "main", "textord", "œ", "\\oe", !0);
      defineSymbol("text", "main", "textord", "ø", "\\o", !0);
      defineSymbol("text", "main", "textord", "Æ", "\\AE", !0);
      defineSymbol("text", "main", "textord", "Œ", "\\OE", !0);
      defineSymbol("text", "main", "textord", "Ø", "\\O", !0);
      defineSymbol("text", "main", "accent-token", "ˊ", "\\'");
      defineSymbol("text", "main", "accent-token", "ˋ", "\\`");
      defineSymbol("text", "main", "accent-token", "ˆ", "\\^");
      defineSymbol("text", "main", "accent-token", "˜", "\\~");
      defineSymbol("text", "main", "accent-token", "ˉ", "\\\x3d");
      defineSymbol("text", "main", "accent-token", "˘", "\\u");
      defineSymbol("text", "main", "accent-token", "˙", "\\.");
      defineSymbol("text", "main", "accent-token", "¸", "\\c");
      defineSymbol("text", "main", "accent-token", "˚", "\\r");
      defineSymbol("text", "main", "accent-token", "ˇ", "\\v");
      defineSymbol("text", "main", "accent-token", "¨", '\\"');
      defineSymbol("text", "main", "accent-token", "˝", "\\H");
      defineSymbol("text", "main", "accent-token", "◯", "\\textcircled");
      const ligatures = {"--":!0, "---":!0, "``":!0, "''":!0};
      defineSymbol("text", "main", "textord", "–", "--", !0);
      defineSymbol("text", "main", "textord", "–", "\\textendash");
      defineSymbol("text", "main", "textord", "—", "---", !0);
      defineSymbol("text", "main", "textord", "—", "\\textemdash");
      defineSymbol("text", "main", "textord", "‘", "`", !0);
      defineSymbol("text", "main", "textord", "‘", "\\textquoteleft");
      defineSymbol("text", "main", "textord", "’", "'", !0);
      defineSymbol("text", "main", "textord", "’", "\\textquoteright");
      defineSymbol("text", "main", "textord", "“", "``", !0);
      defineSymbol("text", "main", "textord", "“", "\\textquotedblleft");
      defineSymbol("text", "main", "textord", "”", "''", !0);
      defineSymbol("text", "main", "textord", "”", "\\textquotedblright");
      defineSymbol("math", "main", "textord", "°", "\\degree", !0);
      defineSymbol("text", "main", "textord", "°", "\\degree");
      defineSymbol("text", "main", "textord", "°", "\\textdegree", !0);
      defineSymbol("math", "main", "textord", "£", "\\pounds");
      defineSymbol("math", "main", "textord", "£", "\\mathsterling", !0);
      defineSymbol("text", "main", "textord", "£", "\\pounds");
      defineSymbol("text", "main", "textord", "£", "\\textsterling", !0);
      defineSymbol("math", "ams", "textord", "✠", "\\maltese");
      defineSymbol("text", "ams", "textord", "✠", "\\maltese");
      for (let i = 0; 14 > i; i++) {
        const ch = '0123456789/@."'.charAt(i);
        defineSymbol("math", "main", "textord", ch, ch);
      }
      for (let i = 0; 25 > i; i++) {
        const ch = '0123456789!@*()-\x3d+";:?/.,'.charAt(i);
        defineSymbol("text", "main", "textord", ch, ch);
      }
      for (let i = 0; 52 > i; i++) {
        const ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".charAt(i);
        defineSymbol("math", "main", "mathord", ch, ch);
        defineSymbol("text", "main", "textord", ch, ch);
      }
      defineSymbol("math", "ams", "textord", "C", "ℂ");
      defineSymbol("text", "ams", "textord", "C", "ℂ");
      defineSymbol("math", "ams", "textord", "H", "ℍ");
      defineSymbol("text", "ams", "textord", "H", "ℍ");
      defineSymbol("math", "ams", "textord", "N", "ℕ");
      defineSymbol("text", "ams", "textord", "N", "ℕ");
      defineSymbol("math", "ams", "textord", "P", "ℙ");
      defineSymbol("text", "ams", "textord", "P", "ℙ");
      defineSymbol("math", "ams", "textord", "Q", "ℚ");
      defineSymbol("text", "ams", "textord", "Q", "ℚ");
      defineSymbol("math", "ams", "textord", "R", "ℝ");
      defineSymbol("text", "ams", "textord", "R", "ℝ");
      defineSymbol("math", "ams", "textord", "Z", "ℤ");
      defineSymbol("text", "ams", "textord", "Z", "ℤ");
      defineSymbol("math", "main", "mathord", "h", "ℎ");
      defineSymbol("text", "main", "mathord", "h", "ℎ");
      let wideChar = "";
      for (let i = 0; 52 > i; i++) {
        const ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".charAt(i);
        wideChar = String.fromCharCode(55349, 56320 + i);
        defineSymbol("math", "main", "mathord", ch, wideChar);
        defineSymbol("text", "main", "textord", ch, wideChar);
        wideChar = String.fromCharCode(55349, 56372 + i);
        defineSymbol("math", "main", "mathord", ch, wideChar);
        defineSymbol("text", "main", "textord", ch, wideChar);
        wideChar = String.fromCharCode(55349, 56424 + i);
        defineSymbol("math", "main", "mathord", ch, wideChar);
        defineSymbol("text", "main", "textord", ch, wideChar);
        wideChar = String.fromCharCode(55349, 56580 + i);
        defineSymbol("math", "main", "mathord", ch, wideChar);
        defineSymbol("text", "main", "textord", ch, wideChar);
        wideChar = String.fromCharCode(55349, 56684 + i);
        defineSymbol("math", "main", "mathord", ch, wideChar);
        defineSymbol("text", "main", "textord", ch, wideChar);
        wideChar = String.fromCharCode(55349, 56736 + i);
        defineSymbol("math", "main", "mathord", ch, wideChar);
        defineSymbol("text", "main", "textord", ch, wideChar);
        wideChar = String.fromCharCode(55349, 56788 + i);
        defineSymbol("math", "main", "mathord", ch, wideChar);
        defineSymbol("text", "main", "textord", ch, wideChar);
        wideChar = String.fromCharCode(55349, 56840 + i);
        defineSymbol("math", "main", "mathord", ch, wideChar);
        defineSymbol("text", "main", "textord", ch, wideChar);
        wideChar = String.fromCharCode(55349, 56944 + i);
        defineSymbol("math", "main", "mathord", ch, wideChar);
        defineSymbol("text", "main", "textord", ch, wideChar);
        26 > i && (wideChar = String.fromCharCode(55349, 56632 + i), defineSymbol("math", "main", "mathord", ch, wideChar), defineSymbol("text", "main", "textord", ch, wideChar), wideChar = String.fromCharCode(55349, 56476 + i), defineSymbol("math", "main", "mathord", ch, wideChar), defineSymbol("text", "main", "textord", ch, wideChar));
      }
      wideChar = String.fromCharCode(55349, 56668);
      defineSymbol("math", "main", "mathord", "k", wideChar);
      defineSymbol("text", "main", "textord", "k", wideChar);
      for (let i = 0; 10 > i; i++) {
        const ch = i.toString();
        wideChar = String.fromCharCode(55349, 57294 + i);
        defineSymbol("math", "main", "mathord", ch, wideChar);
        defineSymbol("text", "main", "textord", ch, wideChar);
        wideChar = String.fromCharCode(55349, 57314 + i);
        defineSymbol("math", "main", "mathord", ch, wideChar);
        defineSymbol("text", "main", "textord", ch, wideChar);
        wideChar = String.fromCharCode(55349, 57324 + i);
        defineSymbol("math", "main", "mathord", ch, wideChar);
        defineSymbol("text", "main", "textord", ch, wideChar);
        wideChar = String.fromCharCode(55349, 57334 + i);
        defineSymbol("math", "main", "mathord", ch, wideChar);
        defineSymbol("text", "main", "textord", ch, wideChar);
      }
      for (let i = 0; 3 > i; i++) {
        const ch = "ÐÞþ".charAt(i);
        defineSymbol("math", "main", "mathord", ch, ch);
        defineSymbol("text", "main", "textord", ch, ch);
      }
      const wideLatinLetterData = [["mathbf", "textbf", "Main-Bold"], ["mathbf", "textbf", "Main-Bold"], ["mathnormal", "textit", "Math-Italic"], ["mathnormal", "textit", "Math-Italic"], ["boldsymbol", "boldsymbol", "Main-BoldItalic"], ["boldsymbol", "boldsymbol", "Main-BoldItalic"], ["mathscr", "textscr", "Script-Regular"], ["", "", ""], ["", "", ""], ["", "", ""], ["mathfrak", "textfrak", "Fraktur-Regular"], ["mathfrak", "textfrak", "Fraktur-Regular"], ["mathbb", "textbb", "AMS-Regular"], ["mathbb", 
      "textbb", "AMS-Regular"], ["mathboldfrak", "textboldfrak", "Fraktur-Regular"], ["mathboldfrak", "textboldfrak", "Fraktur-Regular"], ["mathsf", "textsf", "SansSerif-Regular"], ["mathsf", "textsf", "SansSerif-Regular"], ["mathboldsf", "textboldsf", "SansSerif-Bold"], ["mathboldsf", "textboldsf", "SansSerif-Bold"], ["mathitsf", "textitsf", "SansSerif-Italic"], ["mathitsf", "textitsf", "SansSerif-Italic"], ["", "", ""], ["", "", ""], ["mathtt", "texttt", "Typewriter-Regular"], ["mathtt", "texttt", 
      "Typewriter-Regular"]], wideNumeralData = [["mathbf", "textbf", "Main-Bold"], ["", "", ""], ["mathsf", "textsf", "SansSerif-Regular"], ["mathboldsf", "textboldsf", "SansSerif-Bold"], ["mathtt", "texttt", "Typewriter-Regular"]], wideCharacterFont = function(wideChar, mode) {
        var H = wideChar.charCodeAt(0);
        const L = wideChar.charCodeAt(1);
        H = 1024 * (H - 55296) + (L - 56320) + 65536;
        mode = "math" === mode ? 0 : 1;
        if (119808 <= H && 120484 > H) {
          return wideChar = Math.floor((H - 119808) / 26), [wideLatinLetterData[wideChar][2], wideLatinLetterData[wideChar][mode]];
        }
        if (120782 <= H && 120831 >= H) {
          return wideChar = Math.floor((H - 120782) / 10), [wideNumeralData[wideChar][2], wideNumeralData[wideChar][mode]];
        }
        if (120485 === H || 120486 === H) {
          return [wideLatinLetterData[0][2], wideLatinLetterData[0][mode]];
        }
        if (120486 < H && 120782 > H) {
          return ["", ""];
        }
        throw new src_ParseError("Unsupported character: " + wideChar);
      }, lookupSymbol = function(value, fontName, mode) {
        src_symbols[mode][value] && src_symbols[mode][value].replace && (value = src_symbols[mode][value].replace);
        return {value, metrics:getCharacterMetrics(value, fontName, mode)};
      }, makeSymbol = function(value, fontName, mode, options, classes) {
        value = lookupSymbol(value, fontName, mode);
        const metrics = value.metrics;
        value = value.value;
        if (metrics) {
          fontName = metrics.italic;
          if ("text" === mode || options && "mathit" === options.font) {
            fontName = 0;
          }
          mode = new SymbolNode(value, metrics.height, metrics.depth, fontName, metrics.skew, metrics.width, classes);
        } else {
          "undefined" !== typeof console && console.warn("No character metrics for '" + (value + "' in style '" + fontName + "' and mode '" + mode + "'")), mode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
        }
        options && (mode.maxFontSize = options.sizeMultiplier, options.style.isTight() && mode.classes.push("mtight"), options = options.getColor()) && (mode.style.color = options);
        return mode;
      }, canCombine = (prev, next) => {
        if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
          return !1;
        }
        if (1 === prev.classes.length) {
          const cls = prev.classes[0];
          if ("mbin" === cls || "mord" === cls) {
            return !1;
          }
        }
        for (const style in prev.style) {
          if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
            return !1;
          }
        }
        for (const style in next.style) {
          if (next.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
            return !1;
          }
        }
        return !0;
      }, sizeElementFromChildren = function(elem) {
        let height = 0, depth = 0, maxFontSize = 0;
        for (let i = 0; i < elem.children.length; i++) {
          const child = elem.children[i];
          child.height > height && (height = child.height);
          child.depth > depth && (depth = child.depth);
          child.maxFontSize > maxFontSize && (maxFontSize = child.maxFontSize);
        }
        elem.height = height;
        elem.depth = depth;
        elem.maxFontSize = maxFontSize;
      }, makeSpan = function(classes, children, options, style) {
        classes = new Span(classes, children, options, style);
        sizeElementFromChildren(classes);
        return classes;
      }, makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style), makeFragment = function(children) {
        children = new DocumentFragment(children);
        sizeElementFromChildren(children);
        return children;
      }, retrieveTextFontName = function(fontFamily, fontWeight, fontShape) {
        switch(fontFamily) {
          case "amsrm":
            fontFamily = "AMS";
            break;
          case "textrm":
            fontFamily = "Main";
            break;
          case "textsf":
            fontFamily = "SansSerif";
            break;
          case "texttt":
            fontFamily = "Typewriter";
        }
        return fontFamily + "-" + ("textbf" === fontWeight && "textit" === fontShape ? "BoldItalic" : "textbf" === fontWeight ? "Bold" : "textit" === fontWeight ? "Italic" : "Regular");
      }, fontMap = {mathbf:{variant:"bold", fontName:"Main-Bold"}, mathrm:{variant:"normal", fontName:"Main-Regular"}, textit:{variant:"italic", fontName:"Main-Italic"}, mathit:{variant:"italic", fontName:"Main-Italic"}, mathnormal:{variant:"italic", fontName:"Math-Italic"}, mathsfit:{variant:"sans-serif-italic", fontName:"SansSerif-Italic"}, mathbb:{variant:"double-struck", fontName:"AMS-Regular"}, mathcal:{variant:"script", fontName:"Caligraphic-Regular"}, mathfrak:{variant:"fraktur", fontName:"Fraktur-Regular"}, 
      mathscr:{variant:"script", fontName:"Script-Regular"}, mathsf:{variant:"sans-serif", fontName:"SansSerif-Regular"}, mathtt:{variant:"monospace", fontName:"Typewriter-Regular"}}, svgData = {vec:["vec", 0.471, 0.714], oiintSize1:["oiintSize1", 0.957, 0.499], oiintSize2:["oiintSize2", 1.472, 0.659], oiiintSize1:["oiiintSize1", 1.304, 0.499], oiiintSize2:["oiiintSize2", 1.98, 0.659]};
      var buildCommon = {fontMap, makeSymbol, mathsym:function(value, mode, options, classes) {
        void 0 === classes && (classes = []);
        return "boldsymbol" === options.font && lookupSymbol(value, "Main-Bold", mode).metrics ? makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"])) : "\\" === value || "main" === src_symbols[mode][value].font ? makeSymbol(value, "Main-Regular", mode, options, classes) : makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
      }, makeSpan, makeSvgSpan, makeLineSpan:function(className, options, thickness) {
        className = makeSpan([className], [], options);
        className.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
        className.style.borderBottomWidth = makeEm(className.height);
        className.maxFontSize = 1.0;
        return className;
      }, makeAnchor:function(href, classes, children, options) {
        href = new Anchor(href, classes, children, options);
        sizeElementFromChildren(href);
        return href;
      }, makeFragment, wrapFragment:function(group, options) {
        return group instanceof DocumentFragment ? makeSpan([], [group], options) : group;
      }, makeVList:function(params, options) {
        if ("individualShift" === params.positionType) {
          params = params.children;
          options = [params[0]];
          var depth = -params[0].shift - params[0].elem.depth, currPos = depth;
          for (var i = 1; i < params.length; i++) {
            var diff = -params[i].shift - currPos - params[i].elem.depth, size = diff - (params[i - 1].elem.height + params[i - 1].elem.depth);
            currPos += diff;
            options.push({type:"kern", size});
            options.push(params[i]);
          }
          params = {children:options, depth};
        } else {
          if ("top" === params.positionType) {
            for (options = params.positionData, depth = 0; depth < params.children.length; depth++) {
              currPos = params.children[depth], options -= "kern" === currPos.type ? currPos.size : currPos.elem.height + currPos.elem.depth;
            }
          } else if ("bottom" === params.positionType) {
            options = -params.positionData;
          } else {
            options = params.children[0];
            if ("elem" !== options.type) {
              throw Error('First child must have type "elem".');
            }
            if ("shift" === params.positionType) {
              options = -options.elem.depth - params.positionData;
            } else if ("firstBaseline" === params.positionType) {
              options = -options.elem.depth;
            } else {
              throw Error("Invalid positionType " + params.positionType + ".");
            }
          }
          params = {children:params.children, depth:options};
        }
        const {children, depth:depth$jscomp$0} = params;
        depth = 0;
        for (params = 0; params < children.length; params++) {
          options = children[params], "elem" === options.type && (options = options.elem, depth = Math.max(depth, options.maxFontSize, options.height));
        }
        depth += 2;
        currPos = makeSpan(["pstrut"], []);
        currPos.style.height = makeEm(depth);
        i = [];
        diff = options = params = depth$jscomp$0;
        for (size = 0; size < children.length; size++) {
          const child = children[size];
          if ("kern" === child.type) {
            diff += child.size;
          } else {
            const elem = child.elem, childWrap = makeSpan(child.wrapperClasses || [], [currPos, elem], void 0, child.wrapperStyle || {});
            childWrap.style.top = makeEm(-depth - diff - elem.depth);
            child.marginLeft && (childWrap.style.marginLeft = child.marginLeft);
            child.marginRight && (childWrap.style.marginRight = child.marginRight);
            i.push(childWrap);
            diff += elem.height + elem.depth;
          }
          params = Math.min(params, diff);
          options = Math.max(options, diff);
        }
        depth = makeSpan(["vlist"], i);
        depth.style.height = makeEm(options);
        0 > params ? (currPos = makeSpan([], []), currPos = makeSpan(["vlist"], [currPos]), currPos.style.height = makeEm(-params), i = makeSpan(["vlist-s"], [new SymbolNode("​")]), depth = [makeSpan(["vlist-r"], [depth, i]), makeSpan(["vlist-r"], [currPos])]) : depth = [makeSpan(["vlist-r"], [depth])];
        currPos = makeSpan(["vlist-t"], depth);
        2 === depth.length && currPos.classes.push("vlist-t2");
        currPos.height = options;
        currPos.depth = -params;
        return currPos;
      }, makeOrd:function(group, options, type) {
        const mode = group.mode;
        group = group.text;
        const classes = ["mord"];
        var isFont = "math" === mode || "text" === mode && options.font, fontOrFamily = isFont ? options.font : options.fontFamily, wideFontName = "";
        let wideFontClass = "";
        55349 === group.charCodeAt(0) && ([wideFontName, wideFontClass] = wideCharacterFont(group, mode));
        if (0 < wideFontName.length) {
          return makeSymbol(group, wideFontName, mode, options, classes.concat(wideFontClass));
        }
        if (fontOrFamily) {
          "boldsymbol" === fontOrFamily ? (fontOrFamily = "textord" !== type && lookupSymbol(group, "Math-BoldItalic", mode).metrics ? {fontName:"Math-BoldItalic", fontClass:"boldsymbol"} : {fontName:"Main-Bold", fontClass:"mathbf"}, isFont = fontOrFamily.fontName, fontOrFamily = [fontOrFamily.fontClass]) : isFont ? (isFont = fontMap[fontOrFamily].fontName, fontOrFamily = [fontOrFamily]) : (isFont = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape), fontOrFamily = [fontOrFamily, 
          options.fontWeight, options.fontShape]);
          if (lookupSymbol(group, isFont, mode).metrics) {
            return makeSymbol(group, isFont, mode, options, classes.concat(fontOrFamily));
          }
          if (ligatures.hasOwnProperty(group) && "Typewriter" === isFont.slice(0, 10)) {
            type = [];
            for (wideFontName = 0; wideFontName < group.length; wideFontName++) {
              type.push(makeSymbol(group[wideFontName], isFont, mode, options, classes.concat(fontOrFamily)));
            }
            return makeFragment(type);
          }
        }
        if ("mathord" === type) {
          return makeSymbol(group, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
        }
        if ("textord" === type) {
          type = src_symbols[mode][group] && src_symbols[mode][group].font;
          if ("ams" === type) {
            return type = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape), makeSymbol(group, type, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
          }
          if ("main" !== type && type) {
            return type = retrieveTextFontName(type, options.fontWeight, options.fontShape), makeSymbol(group, type, mode, options, classes.concat(type, options.fontWeight, options.fontShape));
          }
          type = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
          return makeSymbol(group, type, mode, options, classes.concat(options.fontWeight, options.fontShape));
        }
        throw Error("unexpected type: " + type + " in makeOrd");
      }, makeGlue:(measurement, options) => {
        const rule = makeSpan(["mspace"], [], options);
        measurement = calculateSize(measurement, options);
        rule.style.marginRight = makeEm(measurement);
        return rule;
      }, staticSvg:function(value, options) {
        const [pathName, width, height] = svgData[value];
        value = new PathNode(pathName);
        value = new SvgNode([value], {width:makeEm(width), height:makeEm(height), style:"width:" + makeEm(width), viewBox:"0 0 " + 1000 * width + " " + 1000 * height, preserveAspectRatio:"xMinYMin"});
        options = makeSvgSpan(["overlay"], [value], options);
        options.height = height;
        options.style.height = makeEm(height);
        options.style.width = makeEm(width);
        return options;
      }, svgData, tryCombineChars:chars => {
        for (let i = 0; i < chars.length - 1; i++) {
          const prev = chars[i], next = chars[i + 1];
          prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next) && (prev.text += next.text, prev.height = Math.max(prev.height, next.height), prev.depth = Math.max(prev.depth, next.depth), prev.italic = next.italic, chars.splice(i + 1, 1), i--);
        }
        return chars;
      }};
      const thinspace = {number:3, unit:"mu"}, mediumspace = {number:4, unit:"mu"}, thickspace = {number:5, unit:"mu"}, spacings = {mord:{mop:thinspace, mbin:mediumspace, mrel:thickspace, minner:thinspace}, mop:{mord:thinspace, mop:thinspace, mrel:thickspace, minner:thinspace}, mbin:{mord:mediumspace, mop:mediumspace, mopen:mediumspace, minner:mediumspace}, mrel:{mord:thickspace, mop:thickspace, mopen:thickspace, minner:thickspace}, mopen:{}, mclose:{mop:thinspace, mbin:mediumspace, mrel:thickspace, 
      minner:thinspace}, mpunct:{mord:thinspace, mop:thinspace, mrel:thickspace, mopen:thinspace, mclose:thinspace, mpunct:thinspace, minner:thinspace}, minner:{mord:thinspace, mop:thinspace, mbin:mediumspace, mrel:thickspace, mopen:thinspace, mpunct:thinspace, minner:thinspace}}, tightSpacings = {mord:{mop:thinspace}, mop:{mord:thinspace, mop:thinspace}, mbin:{}, mrel:{}, mopen:{}, mclose:{mop:thinspace}, mpunct:{}, minner:{mop:thinspace}}, _functions = {}, _htmlGroupBuilders = {}, _mathmlGroupBuilders = 
      {}, normalizeArgument = function(arg) {
        return "ordgroup" === arg.type && 1 === arg.body.length ? arg.body[0] : arg;
      }, ordargument = function(arg) {
        return "ordgroup" === arg.type ? arg.body : [arg];
      }, buildHTML_makeSpan = buildCommon.makeSpan, binLeftCanceller = "leftmost mbin mopen mrel mop mpunct".split(" "), binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"], styleMap = {display:JSCompiler_object_inline_DISPLAY_2534, text:JSCompiler_object_inline_TEXT_2535, script:JSCompiler_object_inline_SCRIPT_2536, scriptscript:JSCompiler_object_inline_SCRIPTSCRIPT_2537}, DomEnum = {mord:"mord", mop:"mop", mbin:"mbin", mrel:"mrel", mopen:"mopen", mclose:"mclose", mpunct:"mpunct", minner:"minner"}, 
      buildExpression = function(expression, options, isRealGroup, surrounding) {
        void 0 === surrounding && (surrounding = [null, null]);
        const groups = [];
        for (let i = 0; i < expression.length; i++) {
          const output = buildGroup(expression[i], options);
          output instanceof DocumentFragment ? groups.push(...output.children) : groups.push(output);
        }
        buildCommon.tryCombineChars(groups);
        if (!isRealGroup) {
          return groups;
        }
        let glueOptions = options;
        1 === expression.length && (expression = expression[0], "sizing" === expression.type ? glueOptions = options.havingSize(expression.size) : "styling" === expression.type && (glueOptions = options.havingStyle(styleMap[expression.style])));
        expression = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
        options = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options);
        isRealGroup = "root" === isRealGroup;
        traverseNonSpaceNodes(groups, (node, prev) => {
          const prevType = prev.classes[0], type = node.classes[0];
          "mbin" === prevType && utils.contains(binRightCanceller, type) ? prev.classes[0] = "mord" : "mbin" === type && utils.contains(binLeftCanceller, prevType) && (node.classes[0] = "mord");
        }, {node:expression}, options, isRealGroup);
        traverseNonSpaceNodes(groups, (node, prev) => {
          prev = getTypeOfDomTree(prev);
          const type = getTypeOfDomTree(node);
          if (node = prev && type ? node.hasClass("mtight") ? tightSpacings[prev][type] : spacings[prev][type] : null) {
            return buildCommon.makeGlue(node, glueOptions);
          }
        }, {node:expression}, options, isRealGroup);
        return groups;
      }, traverseNonSpaceNodes = function(nodes, callback, prev, next, isRoot) {
        next && nodes.push(next);
        let i = 0;
        for (; i < nodes.length; i++) {
          const node = nodes[i];
          var partialGroup = checkPartialGroup(node);
          if (partialGroup) {
            traverseNonSpaceNodes(partialGroup.children, callback, prev, null, isRoot);
          } else {
            if (partialGroup = !node.hasClass("mspace")) {
              const result = callback(node, prev.node);
              result && (prev.insertAfter ? prev.insertAfter(result) : (nodes.unshift(result), i++));
            }
            partialGroup ? prev.node = node : isRoot && node.hasClass("newline") && (prev.node = buildHTML_makeSpan(["leftmost"]));
            prev.insertAfter = (index => n => {
              nodes.splice(index + 1, 0, n);
              i++;
            })(i);
          }
        }
        next && nodes.pop();
      }, checkPartialGroup = function(node) {
        return node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing") ? node : null;
      }, getOutermostNode = function(node, side) {
        var partialGroup = checkPartialGroup(node);
        if (partialGroup && (partialGroup = partialGroup.children, partialGroup.length)) {
          if ("right" === side) {
            return getOutermostNode(partialGroup[partialGroup.length - 1], "right");
          }
          if ("left" === side) {
            return getOutermostNode(partialGroup[0], "left");
          }
        }
        return node;
      }, getTypeOfDomTree = function(node, side) {
        if (!node) {
          return null;
        }
        side && (node = getOutermostNode(node, side));
        return DomEnum[node.classes[0]] || null;
      }, makeNullDelimiter = function(options, classes) {
        options = ["nulldelimiter"].concat(options.baseSizingClasses());
        return buildHTML_makeSpan(classes.concat(options));
      }, buildGroup = function(group, options, baseOptions) {
        if (!group) {
          return buildHTML_makeSpan();
        }
        if (_htmlGroupBuilders[group.type]) {
          return group = _htmlGroupBuilders[group.type](group, options), baseOptions && options.size !== baseOptions.size && (group = buildHTML_makeSpan(options.sizingClasses(baseOptions), [group], options), options = options.sizeMultiplier / baseOptions.sizeMultiplier, group.height *= options, group.depth *= options), group;
        }
        throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
      };
      class MathNode {
        constructor(type, children, classes) {
          this.classes = this.children = this.attributes = this.type = void 0;
          this.type = type;
          this.attributes = {};
          this.children = children || [];
          this.classes = classes || [];
        }
        setAttribute(name, value) {
          this.attributes[name] = value;
        }
        getAttribute(name) {
          return this.attributes[name];
        }
        toNode() {
          const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
          for (var attr in this.attributes) {
            Object.prototype.hasOwnProperty.call(this.attributes, attr) && node.setAttribute(attr, this.attributes[attr]);
          }
          0 < this.classes.length && (node.className = createClass(this.classes));
          for (attr = 0; attr < this.children.length; attr++) {
            if (this.children[attr] instanceof TextNode && this.children[attr + 1] instanceof TextNode) {
              let text = this.children[attr].toText() + this.children[++attr].toText();
              for (; this.children[attr + 1] instanceof TextNode;) {
                text += this.children[++attr].toText();
              }
              node.appendChild((new TextNode(text)).toNode());
            } else {
              node.appendChild(this.children[attr].toNode());
            }
          }
          return node;
        }
        toMarkup() {
          let markup = "\x3c" + this.type;
          for (var attr in this.attributes) {
            Object.prototype.hasOwnProperty.call(this.attributes, attr) && (markup += " " + attr + '\x3d"', markup += utils.escape(this.attributes[attr]), markup += '"');
          }
          0 < this.classes.length && (markup += ' class \x3d"' + utils.escape(createClass(this.classes)) + '"');
          markup += "\x3e";
          for (attr = 0; attr < this.children.length; attr++) {
            markup += this.children[attr].toMarkup();
          }
          return markup += "\x3c/" + this.type + "\x3e";
        }
        toText() {
          return this.children.map(child => child.toText()).join("");
        }
      }
      class TextNode {
        constructor(text) {
          this.text = void 0;
          this.text = text;
        }
        toNode() {
          return document.createTextNode(this.text);
        }
        toMarkup() {
          return utils.escape(this.toText());
        }
        toText() {
          return this.text;
        }
      }
      class SpaceNode {
        constructor(width) {
          this.character = this.width = void 0;
          this.width = width;
          this.character = 0.05555 <= width && 0.05556 >= width ? " " : 0.1666 <= width && 0.1667 >= width ? " " : 0.2222 <= width && 0.2223 >= width ? " " : 0.2777 <= width && 0.2778 >= width ? "  " : -0.05556 <= width && -0.05555 >= width ? " ⁣" : -0.1667 <= width && -0.1666 >= width ? " ⁣" : -0.2223 <= width && -0.2222 >= width ? " ⁣" : -0.2778 <= width && -0.2777 >= width ? " ⁣" : null;
        }
        toNode() {
          if (this.character) {
            return document.createTextNode(this.character);
          }
          const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
          node.setAttribute("width", makeEm(this.width));
          return node;
        }
        toMarkup() {
          return this.character ? "\x3cmtext\x3e" + this.character + "\x3c/mtext\x3e" : '\x3cmspace width\x3d"' + makeEm(this.width) + '"/\x3e';
        }
        toText() {
          return this.character ? this.character : " ";
        }
      }
      var mathMLTree = {MathNode, TextNode, SpaceNode, newDocumentFragment};
      const makeText = function(text, mode, options) {
        !src_symbols[mode][text] || !src_symbols[mode][text].replace || 55349 === text.charCodeAt(0) || ligatures.hasOwnProperty(text) && options && (options.fontFamily && "tt" === options.fontFamily.slice(4, 6) || options.font && "tt" === options.font.slice(4, 6)) || (text = src_symbols[mode][text].replace);
        return new mathMLTree.TextNode(text);
      }, makeRow = function(body) {
        return 1 === body.length ? body[0] : new mathMLTree.MathNode("mrow", body);
      }, getVariant = function(group, options) {
        if ("texttt" === options.fontFamily) {
          return "monospace";
        }
        if ("textsf" === options.fontFamily) {
          return "textit" === options.fontShape && "textbf" === options.fontWeight ? "sans-serif-bold-italic" : "textit" === options.fontShape ? "sans-serif-italic" : "textbf" === options.fontWeight ? "bold-sans-serif" : "sans-serif";
        }
        if ("textit" === options.fontShape && "textbf" === options.fontWeight) {
          return "bold-italic";
        }
        if ("textit" === options.fontShape) {
          return "italic";
        }
        if ("textbf" === options.fontWeight) {
          return "bold";
        }
        options = options.font;
        if (!options || "mathnormal" === options) {
          return null;
        }
        const mode = group.mode;
        if ("mathit" === options) {
          return "italic";
        }
        if ("boldsymbol" === options) {
          return "textord" === group.type ? "bold" : "bold-italic";
        }
        if ("mathbf" === options) {
          return "bold";
        }
        if ("mathbb" === options) {
          return "double-struck";
        }
        if ("mathsfit" === options) {
          return "sans-serif-italic";
        }
        if ("mathfrak" === options) {
          return "fraktur";
        }
        if ("mathscr" === options || "mathcal" === options) {
          return "script";
        }
        if ("mathsf" === options) {
          return "sans-serif";
        }
        if ("mathtt" === options) {
          return "monospace";
        }
        group = group.text;
        if (utils.contains(["\\imath", "\\jmath"], group)) {
          return null;
        }
        src_symbols[mode][group] && src_symbols[mode][group].replace && (group = src_symbols[mode][group].replace);
        return getCharacterMetrics(group, buildCommon.fontMap[options].fontName, mode) ? buildCommon.fontMap[options].variant : null;
      }, buildMathML_buildExpression = function(expression, options, isOrdgroup) {
        if (1 === expression.length) {
          return expression = buildMathML_buildGroup(expression[0], options), isOrdgroup && expression instanceof MathNode && "mo" === expression.type && (expression.setAttribute("lspace", "0em"), expression.setAttribute("rspace", "0em")), [expression];
        }
        isOrdgroup = [];
        for (let i = 0; i < expression.length; i++) {
          const group = buildMathML_buildGroup(expression[i], options);
          if (group instanceof MathNode && lastGroup instanceof MathNode) {
            if ("mtext" === group.type && "mtext" === lastGroup.type && group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
              lastGroup.children.push(...group.children);
              continue;
            } else if ("mn" === group.type && "mn" === lastGroup.type) {
              lastGroup.children.push(...group.children);
              continue;
            } else if (isNumberPunctuation(group) && "mn" === lastGroup.type) {
              lastGroup.children.push(...group.children);
              continue;
            } else if ("mn" === group.type && isNumberPunctuation(lastGroup)) {
              group.children = [...lastGroup.children, ...group.children], isOrdgroup.pop();
            } else if (("msup" === group.type || "msub" === group.type) && 1 <= group.children.length && ("mn" === lastGroup.type || isNumberPunctuation(lastGroup))) {
              const base = group.children[0];
              base instanceof MathNode && "mn" === base.type && (base.children = [...lastGroup.children, ...base.children], isOrdgroup.pop());
            } else if ("mi" === lastGroup.type && 1 === lastGroup.children.length) {
              var lastGroup = lastGroup.children[0];
              lastGroup instanceof TextNode && "̸" === lastGroup.text && ("mo" === group.type || "mi" === group.type || "mn" === group.type) && (lastGroup = group.children[0], lastGroup instanceof TextNode && 0 < lastGroup.text.length && (lastGroup.text = lastGroup.text.slice(0, 1) + "̸" + lastGroup.text.slice(1), isOrdgroup.pop()));
            }
          }
          isOrdgroup.push(group);
          lastGroup = group;
        }
        return isOrdgroup;
      }, buildMathML_buildGroup = function(group, options) {
        if (!group) {
          return new mathMLTree.MathNode("mrow");
        }
        if (_mathmlGroupBuilders[group.type]) {
          return _mathmlGroupBuilders[group.type](group, options);
        }
        throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
      }, optionsFromSettings = function(settings) {
        return new src_Options({style:settings.displayMode ? JSCompiler_object_inline_DISPLAY_2534 : JSCompiler_object_inline_TEXT_2535, maxSize:settings.maxSize, minRuleThickness:settings.minRuleThickness});
      }, displayWrap = function(node, settings) {
        if (settings.displayMode) {
          const classes = ["katex-display"];
          settings.leqno && classes.push("leqno");
          settings.fleqn && classes.push("fleqn");
          node = buildCommon.makeSpan(classes, [node]);
        }
        return node;
      }, stretchyCodePoint = {widehat:"^", widecheck:"ˇ", widetilde:"~", utilde:"~", overleftarrow:"←", underleftarrow:"←", xleftarrow:"←", overrightarrow:"→", underrightarrow:"→", xrightarrow:"→", underbrace:"⏟", overbrace:"⏞", overgroup:"⏠", undergroup:"⏡", overleftrightarrow:"↔", underleftrightarrow:"↔", xleftrightarrow:"↔", Overrightarrow:"⇒", xRightarrow:"⇒", overleftharpoon:"↼", xleftharpoonup:"↼", overrightharpoon:"⇀", xrightharpoonup:"⇀", xLeftarrow:"⇐", xLeftrightarrow:"⇔", xhookleftarrow:"↩", 
      xhookrightarrow:"↪", xmapsto:"↦", xrightharpoondown:"⇁", xleftharpoondown:"↽", xrightleftharpoons:"⇌", xleftrightharpoons:"⇋", xtwoheadleftarrow:"↞", xtwoheadrightarrow:"↠", xlongequal:"\x3d", xtofrom:"⇄", xrightleftarrows:"⇄", xrightequilibrium:"⇌", xleftequilibrium:"⇋", "\\cdrightarrow":"→", "\\cdleftarrow":"←", "\\cdlongequal":"\x3d"}, katexImagesData = {overrightarrow:[["rightarrow"], 0.888, 522, "xMaxYMin"], overleftarrow:[["leftarrow"], 0.888, 522, "xMinYMin"], underrightarrow:[["rightarrow"], 
      0.888, 522, "xMaxYMin"], underleftarrow:[["leftarrow"], 0.888, 522, "xMinYMin"], xrightarrow:[["rightarrow"], 1.469, 522, "xMaxYMin"], "\\cdrightarrow":[["rightarrow"], 3.0, 522, "xMaxYMin"], xleftarrow:[["leftarrow"], 1.469, 522, "xMinYMin"], "\\cdleftarrow":[["leftarrow"], 3.0, 522, "xMinYMin"], Overrightarrow:[["doublerightarrow"], 0.888, 560, "xMaxYMin"], xRightarrow:[["doublerightarrow"], 1.526, 560, "xMaxYMin"], xLeftarrow:[["doubleleftarrow"], 1.526, 560, "xMinYMin"], overleftharpoon:[["leftharpoon"], 
      0.888, 522, "xMinYMin"], xleftharpoonup:[["leftharpoon"], 0.888, 522, "xMinYMin"], xleftharpoondown:[["leftharpoondown"], 0.888, 522, "xMinYMin"], overrightharpoon:[["rightharpoon"], 0.888, 522, "xMaxYMin"], xrightharpoonup:[["rightharpoon"], 0.888, 522, "xMaxYMin"], xrightharpoondown:[["rightharpoondown"], 0.888, 522, "xMaxYMin"], xlongequal:[["longequal"], 0.888, 334, "xMinYMin"], "\\cdlongequal":[["longequal"], 3.0, 334, "xMinYMin"], xtwoheadleftarrow:[["twoheadleftarrow"], 0.888, 334, "xMinYMin"], 
      xtwoheadrightarrow:[["twoheadrightarrow"], 0.888, 334, "xMaxYMin"], overleftrightarrow:[["leftarrow", "rightarrow"], 0.888, 522], overbrace:[["leftbrace", "midbrace", "rightbrace"], 1.6, 548], underbrace:[["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548], underleftrightarrow:[["leftarrow", "rightarrow"], 0.888, 522], xleftrightarrow:[["leftarrow", "rightarrow"], 1.75, 522], xLeftrightarrow:[["doubleleftarrow", "doublerightarrow"], 1.75, 560], xrightleftharpoons:[["leftharpoondownplus", 
      "rightharpoonplus"], 1.75, 716], xleftrightharpoons:[["leftharpoonplus", "rightharpoondownplus"], 1.75, 716], xhookleftarrow:[["leftarrow", "righthook"], 1.08, 522], xhookrightarrow:[["lefthook", "rightarrow"], 1.08, 522], overlinesegment:[["leftlinesegment", "rightlinesegment"], 0.888, 522], underlinesegment:[["leftlinesegment", "rightlinesegment"], 0.888, 522], overgroup:[["leftgroup", "rightgroup"], 0.888, 342], undergroup:[["leftgroupunder", "rightgroupunder"], 0.888, 342], xmapsto:[["leftmapsto", 
      "rightarrow"], 1.5, 522], xtofrom:[["leftToFrom", "rightToFrom"], 1.75, 528], xrightleftarrows:[["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901], xrightequilibrium:[["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716], xleftequilibrium:[["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]};
      var stretchy = {encloseSpan:function(inner, label, topPad, bottomPad, options) {
        inner = inner.height + inner.depth + topPad + bottomPad;
        if (/fbox|color|angl/.test(label)) {
          if (topPad = buildCommon.makeSpan(["stretchy", label], [], options), "fbox" === label && (options = options.color && options.getColor())) {
            topPad.style.borderColor = options;
          }
        } else {
          topPad = [], /^[bx]cancel$/.test(label) && topPad.push(new LineNode({x1:"0", y1:"0", x2:"100%", y2:"100%", "stroke-width":"0.046em"})), /^x?cancel$/.test(label) && topPad.push(new LineNode({x1:"0", y1:"100%", x2:"100%", y2:"0", "stroke-width":"0.046em"})), label = new SvgNode(topPad, {width:"100%", height:makeEm(inner)}), topPad = buildCommon.makeSvgSpan([], [label], options);
        }
        topPad.height = inner;
        topPad.style.height = makeEm(inner);
        return topPad;
      }, mathMLnode:function(label) {
        label = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
        label.setAttribute("stretchy", "true");
        return label;
      }, svgSpan:function(group, options) {
        const {span, minWidth, height} = function() {
          var viewBoxWidth = 400000, label = group.label.slice(1);
          if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
            viewBoxWidth = group.base;
            viewBoxWidth = "ordgroup" === viewBoxWidth.type ? viewBoxWidth.body.length : 1;
            if (5 < viewBoxWidth) {
              if ("widehat" === label || "widecheck" === label) {
                var viewBoxHeight = 420;
                viewBoxWidth = 2364;
                var height = 0.42;
                label += "4";
              } else {
                viewBoxHeight = 312, viewBoxWidth = 2340, height = 0.34, label = "tilde4";
              }
            } else {
              var imgIndex = [1, 1, 2, 2, 3, 3][viewBoxWidth];
              "widehat" === label || "widecheck" === label ? (viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex], viewBoxHeight = [0, 239, 300, 360, 420][imgIndex], height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex], label += imgIndex) : (viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex], viewBoxHeight = [0, 260, 286, 306, 312][imgIndex], height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex], label = "tilde" + imgIndex);
            }
            label = new PathNode(label);
            viewBoxWidth = new SvgNode([label], {width:"100%", height:makeEm(height), viewBox:"0 0 " + viewBoxWidth + " " + viewBoxHeight, preserveAspectRatio:"none"});
            return {span:buildCommon.makeSvgSpan([], [viewBoxWidth], options), minWidth:0, height};
          }
          height = [];
          imgIndex = katexImagesData[label];
          const [paths, minWidth, viewBoxHeight$jscomp$0] = imgIndex;
          label = viewBoxHeight$jscomp$0 / 1000;
          viewBoxHeight = paths.length;
          if (1 === viewBoxHeight) {
            var aligns = imgIndex[3];
            imgIndex = ["hide-tail"];
            aligns = [aligns];
          } else if (2 === viewBoxHeight) {
            imgIndex = ["halfarrow-left", "halfarrow-right"], aligns = ["xMinYMin", "xMaxYMin"];
          } else if (3 === viewBoxHeight) {
            imgIndex = ["brace-left", "brace-center", "brace-right"], aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
          } else {
            throw Error("Correct katexImagesData or update code here to support\n                    " + viewBoxHeight + " children.");
          }
          for (let i = 0; i < viewBoxHeight; i++) {
            var path = new PathNode(paths[i]);
            path = new SvgNode([path], {width:"400em", height:makeEm(label), viewBox:"0 0 " + viewBoxWidth + " " + viewBoxHeight$jscomp$0, preserveAspectRatio:aligns[i] + " slice"});
            path = buildCommon.makeSvgSpan([imgIndex[i]], [path], options);
            if (1 === viewBoxHeight) {
              return {span:path, minWidth, height:label};
            }
            path.style.height = makeEm(label);
            height.push(path);
          }
          return {span:buildCommon.makeSpan(["stretchy"], height, options), minWidth, height:label};
        }();
        span.height = height;
        span.style.height = makeEm(height);
        0 < minWidth && (span.style.minWidth = makeEm(minWidth));
        return span;
      }};
      const htmlBuilder = (grp, options) => {
        let group;
        if (grp && "supsub" === grp.type) {
          group = assertNodeType(grp.base, "accent");
          var base = group.base;
          grp.base = base;
          var supSubGroup = buildGroup(grp, options);
          if (!(supSubGroup instanceof Span)) {
            throw Error("Expected span\x3cHtmlDomNode\x3e but got " + String(supSubGroup) + ".");
          }
          grp.base = group;
        } else {
          group = assertNodeType(grp, "accent"), base = group.base;
        }
        grp = buildGroup(base, options.havingCrampedStyle());
        var skew = 0;
        group.isShifty && utils.isCharacterBox(base) && (skew = utils.getBaseElem(base), skew = buildGroup(skew, options.havingCrampedStyle()), skew = assertSymbolDomNode(skew).skew);
        var accentBelow = "\\c" === group.label;
        base = accentBelow ? grp.height + grp.depth : Math.min(grp.height, options.fontMetrics().xHeight);
        if (group.isStretchy) {
          accentBelow = stretchy.svgSpan(group, options), accentBelow = buildCommon.makeVList({positionType:"firstBaseline", children:[{type:"elem", elem:grp}, {type:"elem", elem:accentBelow, wrapperClasses:["svg-align"], wrapperStyle:0 < skew ? {width:"calc(100% - " + makeEm(2 * skew) + ")", marginLeft:makeEm(2 * skew)} : void 0}]}, options);
        } else {
          let width;
          if ("\\vec" === group.label) {
            var accent = buildCommon.staticSvg("vec", options);
            width = buildCommon.svgData.vec[1];
          } else {
            accent = buildCommon.makeOrd({mode:group.mode, text:group.label}, options, "textord"), accent = assertSymbolDomNode(accent), accent.italic = 0, width = accent.width, accentBelow && (base += accent.depth);
          }
          accentBelow = buildCommon.makeSpan(["accent-body"], [accent]);
          if (accent = "\\textcircled" === group.label) {
            accentBelow.classes.push("accent-full"), base = grp.height;
          }
          accent || (skew -= width / 2);
          accentBelow.style.left = makeEm(skew);
          "\\textcircled" === group.label && (accentBelow.style.top = ".2em");
          accentBelow = buildCommon.makeVList({positionType:"firstBaseline", children:[{type:"elem", elem:grp}, {type:"kern", size:-base}, {type:"elem", elem:accentBelow}]}, options);
        }
        options = buildCommon.makeSpan(["mord", "accent"], [accentBelow], options);
        return supSubGroup ? (supSubGroup.children[0] = options, supSubGroup.height = Math.max(options.height, supSubGroup.height), supSubGroup.classes[0] = "mord", supSubGroup) : options;
      }, mathmlBuilder = (group, options) => {
        const accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
        group = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
        group.setAttribute("accent", "true");
        return group;
      }, NON_STRETCHY_ACCENT_REGEX = new RegExp("\\acute \\grave \\ddot \\tilde \\bar \\breve \\check \\hat \\vec \\dot \\mathring".split(" ").map(accent => "\\" + accent).join("|"));
      defineFunction({type:"accent", names:"\\acute \\grave \\ddot \\tilde \\bar \\breve \\check \\hat \\vec \\dot \\mathring \\widecheck \\widehat \\widetilde \\overrightarrow \\overleftarrow \\Overrightarrow \\overleftrightarrow \\overgroup \\overlinesegment \\overleftharpoon \\overrightharpoon".split(" "), props:{numArgs:1}, handler:(context, args) => {
        args = normalizeArgument(args[0]);
        const isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
        return {type:"accent", mode:context.parser.mode, label:context.funcName, isStretchy, isShifty:!isStretchy || "\\widehat" === context.funcName || "\\widetilde" === context.funcName || "\\widecheck" === context.funcName, base:args};
      }, htmlBuilder, mathmlBuilder});
      defineFunction({type:"accent", names:"\\' \\` \\^ \\~ \\\x3d \\u \\. \\\" \\c \\r \\H \\v \\textcircled".split(" "), props:{numArgs:1, allowedInText:!0, allowedInMath:!0, argTypes:["primitive"]}, handler:(context, args) => {
        args = args[0];
        let mode = context.parser.mode;
        "math" === mode && (context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode"), mode = "text");
        return {type:"accent", mode, label:context.funcName, isStretchy:!1, isShifty:!0, base:args};
      }, htmlBuilder, mathmlBuilder});
      defineFunction({type:"accentUnder", names:"\\underleftarrow \\underrightarrow \\underleftrightarrow \\undergroup \\underlinesegment \\utilde".split(" "), props:{numArgs:1}, handler:(_ref, args) => {
        let {parser, funcName} = _ref;
        return {type:"accentUnder", mode:parser.mode, label:funcName, base:args[0]};
      }, htmlBuilder:(group, options) => {
        const innerGroup = buildGroup(group.base, options), accentBody = stretchy.svgSpan(group, options);
        group = buildCommon.makeVList({positionType:"top", positionData:innerGroup.height, children:[{type:"elem", elem:accentBody, wrapperClasses:["svg-align"]}, {type:"kern", size:"\\utilde" === group.label ? 0.12 : 0}, {type:"elem", elem:innerGroup}]}, options);
        return buildCommon.makeSpan(["mord", "accentunder"], [group], options);
      }, mathmlBuilder:(group, options) => {
        const accentNode = stretchy.mathMLnode(group.label);
        group = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
        group.setAttribute("accentunder", "true");
        return group;
      }});
      const paddedNode = group => {
        group = new mathMLTree.MathNode("mpadded", group ? [group] : []);
        group.setAttribute("width", "+0.6em");
        group.setAttribute("lspace", "0.3em");
        return group;
      };
      defineFunction({type:"xArrow", names:"\\xleftarrow \\xrightarrow \\xLeftarrow \\xRightarrow \\xleftrightarrow \\xLeftrightarrow \\xhookleftarrow \\xhookrightarrow \\xmapsto \\xrightharpoondown \\xrightharpoonup \\xleftharpoondown \\xleftharpoonup \\xrightleftharpoons \\xleftrightharpoons \\xlongequal \\xtwoheadrightarrow \\xtwoheadleftarrow \\xtofrom \\xrightleftarrows \\xrightequilibrium \\xleftequilibrium \\\\cdrightarrow \\\\cdleftarrow \\\\cdlongequal".split(" "), props:{numArgs:1, numOptionalArgs:1}, 
      handler(_ref, args, optArgs) {
        let {parser, funcName} = _ref;
        return {type:"xArrow", mode:parser.mode, label:funcName, body:args[0], below:optArgs[0]};
      }, htmlBuilder(group, options) {
        var style = options.style, newOptions = options.havingStyle(style.sup()), upperGroup = buildCommon.wrapFragment(buildGroup(group.body, newOptions, options), options), arrowPrefix = "\\x" === group.label.slice(0, 2) ? "x" : "cd";
        upperGroup.classes.push(arrowPrefix + "-arrow-pad");
        let lowerGroup;
        group.below && (newOptions = options.havingStyle(style.sub()), lowerGroup = buildCommon.wrapFragment(buildGroup(group.below, newOptions, options), options), lowerGroup.classes.push(arrowPrefix + "-arrow-pad"));
        style = stretchy.svgSpan(group, options);
        newOptions = -options.fontMetrics().axisHeight + 0.5 * style.height;
        arrowPrefix = -options.fontMetrics().axisHeight - 0.5 * style.height - 0.111;
        if (0.25 < upperGroup.depth || "\\xleftequilibrium" === group.label) {
          arrowPrefix -= upperGroup.depth;
        }
        lowerGroup ? (group = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * style.height + 0.111, upperGroup = buildCommon.makeVList({positionType:"individualShift", children:[{type:"elem", elem:upperGroup, shift:arrowPrefix}, {type:"elem", elem:style, shift:newOptions}, {type:"elem", elem:lowerGroup, shift:group}]}, options)) : upperGroup = buildCommon.makeVList({positionType:"individualShift", children:[{type:"elem", elem:upperGroup, shift:arrowPrefix}, {type:"elem", elem:style, 
        shift:newOptions}]}, options);
        upperGroup.children[0].children[0].children[1].classes.push("svg-align");
        return buildCommon.makeSpan(["mrel", "x-arrow"], [upperGroup], options);
      }, mathmlBuilder(group, options) {
        const arrowNode = stretchy.mathMLnode(group.label);
        arrowNode.setAttribute("minsize", "x" === group.label.charAt(0) ? "1.75em" : "3.0em");
        if (group.body) {
          var node = paddedNode(buildMathML_buildGroup(group.body, options));
          group.below ? (group = paddedNode(buildMathML_buildGroup(group.below, options)), node = new mathMLTree.MathNode("munderover", [arrowNode, group, node])) : node = new mathMLTree.MathNode("mover", [arrowNode, node]);
        } else {
          group.below ? (node = paddedNode(buildMathML_buildGroup(group.below, options)), node = new mathMLTree.MathNode("munder", [arrowNode, node])) : (node = paddedNode(), node = new mathMLTree.MathNode("mover", [arrowNode, node]));
        }
        return node;
      }});
      const mclass_makeSpan = buildCommon.makeSpan;
      defineFunction({type:"mclass", names:"\\mathord \\mathbin \\mathrel \\mathopen \\mathclose \\mathpunct \\mathinner".split(" "), props:{numArgs:1, primitive:!0}, handler(_ref, args) {
        let {parser, funcName} = _ref;
        _ref = args[0];
        return {type:"mclass", mode:parser.mode, mclass:"m" + funcName.slice(5), body:ordargument(_ref), isCharacterBox:utils.isCharacterBox(_ref)};
      }, htmlBuilder:mclass_htmlBuilder, mathmlBuilder:mclass_mathmlBuilder});
      const binrelClass = arg => {
        arg = "ordgroup" === arg.type && arg.body.length ? arg.body[0] : arg;
        return "atom" !== arg.type || "bin" !== arg.family && "rel" !== arg.family ? "mord" : "m" + arg.family;
      };
      defineFunction({type:"mclass", names:["\\@binrel"], props:{numArgs:2}, handler(_ref2, args) {
        ({parser:_ref2} = _ref2);
        return {type:"mclass", mode:_ref2.mode, mclass:binrelClass(args[0]), body:ordargument(args[1]), isCharacterBox:utils.isCharacterBox(args[1])};
      }});
      defineFunction({type:"mclass", names:["\\stackrel", "\\overset", "\\underset"], props:{numArgs:2}, handler(_ref3, args) {
        let {parser, funcName} = _ref3;
        _ref3 = args[1];
        const shiftedArg = args[0];
        args = "\\stackrel" !== funcName ? binrelClass(_ref3) : "mrel";
        _ref3 = {type:"op", mode:_ref3.mode, limits:!0, alwaysHandleSupSub:!0, parentIsSupSub:!1, symbol:!1, suppressBaseShift:"\\stackrel" !== funcName, body:ordargument(_ref3)};
        _ref3 = {type:"supsub", mode:shiftedArg.mode, base:_ref3, sup:"\\underset" === funcName ? null : shiftedArg, sub:"\\underset" === funcName ? shiftedArg : null};
        return {type:"mclass", mode:parser.mode, mclass:args, body:[_ref3], isCharacterBox:utils.isCharacterBox(_ref3)};
      }, htmlBuilder:mclass_htmlBuilder, mathmlBuilder:mclass_mathmlBuilder});
      defineFunction({type:"pmb", names:["\\pmb"], props:{numArgs:1, allowedInText:!0}, handler(_ref, args) {
        ({parser:_ref} = _ref);
        return {type:"pmb", mode:_ref.mode, mclass:binrelClass(args[0]), body:ordargument(args[0])};
      }, htmlBuilder(group, options) {
        const elements = buildExpression(group.body, options, !0);
        group = buildCommon.makeSpan([group.mclass], elements, options);
        group.style.textShadow = "0.02em 0.01em 0.04px";
        return group;
      }, mathmlBuilder(group, style) {
        group = buildMathML_buildExpression(group.body, style);
        group = new mathMLTree.MathNode("mstyle", group);
        group.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
        return group;
      }});
      const cdArrowFunctionName = {"\x3e":"\\\\cdrightarrow", "\x3c":"\\\\cdleftarrow", "\x3d":"\\\\cdlongequal", A:"\\uparrow", V:"\\downarrow", "|":"\\Vert", ".":"no arrow"}, newCell = () => ({type:"styling", body:[], mode:"math", style:"display"}), isStartOfArrow = node => "textord" === node.type && "@" === node.text;
      defineFunction({type:"cdlabel", names:["\\\\cdleft", "\\\\cdright"], props:{numArgs:1}, handler(_ref, args) {
        let {parser, funcName} = _ref;
        return {type:"cdlabel", mode:parser.mode, side:funcName.slice(4), label:args[0]};
      }, htmlBuilder(group, options) {
        const newOptions = options.havingStyle(options.style.sup());
        options = buildCommon.wrapFragment(buildGroup(group.label, newOptions, options), options);
        options.classes.push("cd-label-" + group.side);
        options.style.bottom = makeEm(0.8 - options.depth);
        options.height = 0;
        options.depth = 0;
        return options;
      }, mathmlBuilder(group, options) {
        options = new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.label, options)]);
        options = new mathMLTree.MathNode("mpadded", [options]);
        options.setAttribute("width", "0");
        "left" === group.side && options.setAttribute("lspace", "-1width");
        options.setAttribute("voffset", "0.7em");
        options = new mathMLTree.MathNode("mstyle", [options]);
        options.setAttribute("displaystyle", "false");
        options.setAttribute("scriptlevel", "1");
        return options;
      }});
      defineFunction({type:"cdlabelparent", names:["\\\\cdparent"], props:{numArgs:1}, handler(_ref2, args) {
        ({parser:_ref2} = _ref2);
        return {type:"cdlabelparent", mode:_ref2.mode, fragment:args[0]};
      }, htmlBuilder(group, options) {
        group = buildCommon.wrapFragment(buildGroup(group.fragment, options), options);
        group.classes.push("cd-vert-arrow");
        return group;
      }, mathmlBuilder(group, options) {
        return new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.fragment, options)]);
      }});
      defineFunction({type:"textord", names:["\\@char"], props:{numArgs:1, allowedInText:!0}, handler(_ref, args) {
        ({parser:_ref} = _ref);
        var group = assertNodeType(args[0], "ordgroup").body;
        args = "";
        for (let i = 0; i < group.length; i++) {
          const node = assertNodeType(group[i], "textord");
          args += node.text;
        }
        group = parseInt(args);
        if (isNaN(group)) {
          throw new src_ParseError("\\@char has non-numeric argument " + args);
        }
        if (0 > group || 1114111 <= group) {
          throw new src_ParseError("\\@char with invalid code point " + args);
        }
        65535 >= group ? args = String.fromCharCode(group) : (group -= 65536, args = String.fromCharCode((group >> 10) + 55296, (group & 1023) + 56320));
        return {type:"textord", mode:_ref.mode, text:args};
      }});
      const color_htmlBuilder = (group, options) => {
        group = buildExpression(group.body, options.withColor(group.color), !1);
        return buildCommon.makeFragment(group);
      }, color_mathmlBuilder = (group, options) => {
        options = buildMathML_buildExpression(group.body, options.withColor(group.color));
        options = new mathMLTree.MathNode("mstyle", options);
        options.setAttribute("mathcolor", group.color);
        return options;
      };
      defineFunction({type:"color", names:["\\textcolor"], props:{numArgs:2, allowedInText:!0, argTypes:["color", "original"]}, handler(_ref, args) {
        ({parser:_ref} = _ref);
        const color = assertNodeType(args[0], "color-token").color;
        return {type:"color", mode:_ref.mode, color, body:ordargument(args[1])};
      }, htmlBuilder:color_htmlBuilder, mathmlBuilder:color_mathmlBuilder});
      defineFunction({type:"color", names:["\\color"], props:{numArgs:1, allowedInText:!0, argTypes:["color"]}, handler(_ref2, args) {
        let {parser, breakOnTokenText} = _ref2;
        _ref2 = assertNodeType(args[0], "color-token").color;
        parser.gullet.macros.set("\\current@color", _ref2);
        args = parser.parseExpression(!0, breakOnTokenText);
        return {type:"color", mode:parser.mode, color:_ref2, body:args};
      }, htmlBuilder:color_htmlBuilder, mathmlBuilder:color_mathmlBuilder});
      defineFunction({type:"cr", names:["\\\\"], props:{numArgs:0, numOptionalArgs:0, allowedInText:!0}, handler(_ref, args, optArgs) {
        ({parser:_ref} = _ref);
        args = "[" === _ref.gullet.future().text ? _ref.parseSizeGroup(!0) : null;
        optArgs = !_ref.settings.displayMode || !_ref.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
        return {type:"cr", mode:_ref.mode, newLine:optArgs, size:args && assertNodeType(args, "size").value};
      }, htmlBuilder(group, options) {
        const span = buildCommon.makeSpan(["mspace"], [], options);
        group.newLine && (span.classes.push("newline"), group.size && (span.style.marginTop = makeEm(calculateSize(group.size, options))));
        return span;
      }, mathmlBuilder(group, options) {
        const node = new mathMLTree.MathNode("mspace");
        group.newLine && (node.setAttribute("linebreak", "newline"), group.size && node.setAttribute("height", makeEm(calculateSize(group.size, options))));
        return node;
      }});
      const globalMap = {"\\global":"\\global", "\\long":"\\\\globallong", "\\\\globallong":"\\\\globallong", "\\def":"\\gdef", "\\gdef":"\\gdef", "\\edef":"\\xdef", "\\xdef":"\\xdef", "\\let":"\\\\globallet", "\\futurelet":"\\\\globalfuture"}, checkControlSequence = tok => {
        const name = tok.text;
        if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
          throw new src_ParseError("Expected a control sequence", tok);
        }
        return name;
      }, letCommand = (parser, name, tok, global) => {
        let macro = parser.gullet.macros.get(tok.text);
        null == macro && (tok.noexpand = !0, macro = {tokens:[tok], numArgs:0, unexpandable:!parser.gullet.isExpandable(tok.text)});
        parser.gullet.macros.set(name, macro, global);
      };
      defineFunction({type:"internal", names:["\\global", "\\long", "\\\\globallong"], props:{numArgs:0, allowedInText:!0}, handler(_ref) {
        let {parser, funcName} = _ref;
        parser.consumeSpaces();
        _ref = parser.fetch();
        if (globalMap[_ref.text]) {
          if ("\\global" === funcName || "\\\\globallong" === funcName) {
            _ref.text = globalMap[_ref.text];
          }
          return assertNodeType(parser.parseFunction(), "internal");
        }
        throw new src_ParseError("Invalid token after macro prefix", _ref);
      }});
      defineFunction({type:"internal", names:["\\def", "\\gdef", "\\edef", "\\xdef"], props:{numArgs:0, allowedInText:!0, primitive:!0}, handler(_ref2) {
        let {parser, funcName} = _ref2;
        var tok = parser.gullet.popToken();
        _ref2 = tok.text;
        if (/^(?:[\\{}$&#^_]|EOF)$/.test(_ref2)) {
          throw new src_ParseError("Expected a control sequence", tok);
        }
        let numArgs = 0, insert;
        const delimiters = [[]];
        for (; "{" !== parser.gullet.future().text;) {
          if (tok = parser.gullet.popToken(), "#" === tok.text) {
            if ("{" === parser.gullet.future().text) {
              insert = parser.gullet.future();
              delimiters[numArgs].push("{");
              break;
            }
            tok = parser.gullet.popToken();
            if (!/^[1-9]$/.test(tok.text)) {
              throw new src_ParseError('Invalid argument number "' + tok.text + '"');
            }
            if (parseInt(tok.text) !== numArgs + 1) {
              throw new src_ParseError('Argument number "' + tok.text + '" out of order');
            }
            numArgs++;
            delimiters.push([]);
          } else {
            if ("EOF" === tok.text) {
              throw new src_ParseError("Expected a macro definition");
            }
            delimiters[numArgs].push(tok.text);
          }
        }
        ({tokens:tok} = parser.gullet.consumeArg());
        insert && tok.unshift(insert);
        if ("\\edef" === funcName || "\\xdef" === funcName) {
          tok = parser.gullet.expandTokens(tok), tok.reverse();
        }
        parser.gullet.macros.set(_ref2, {tokens:tok, numArgs, delimiters}, funcName === globalMap[funcName]);
        return {type:"internal", mode:parser.mode};
      }});
      defineFunction({type:"internal", names:["\\let", "\\\\globallet"], props:{numArgs:0, allowedInText:!0, primitive:!0}, handler(_ref3) {
        let {parser, funcName} = _ref3;
        _ref3 = checkControlSequence(parser.gullet.popToken());
        parser.gullet.consumeSpaces();
        let tok = parser.gullet.popToken();
        "\x3d" === tok.text && (tok = parser.gullet.popToken(), " " === tok.text && (tok = parser.gullet.popToken()));
        letCommand(parser, _ref3, tok, "\\\\globallet" === funcName);
        return {type:"internal", mode:parser.mode};
      }});
      defineFunction({type:"internal", names:["\\futurelet", "\\\\globalfuture"], props:{numArgs:0, allowedInText:!0, primitive:!0}, handler(_ref4) {
        let {parser, funcName} = _ref4;
        _ref4 = checkControlSequence(parser.gullet.popToken());
        const middle = parser.gullet.popToken(), tok = parser.gullet.popToken();
        letCommand(parser, _ref4, tok, "\\\\globalfuture" === funcName);
        parser.gullet.pushToken(tok);
        parser.gullet.pushToken(middle);
        return {type:"internal", mode:parser.mode};
      }});
      const getMetrics = function(symbol, font, mode) {
        mode = getCharacterMetrics(src_symbols.math[symbol] && src_symbols.math[symbol].replace || symbol, font, mode);
        if (!mode) {
          throw Error("Unsupported symbol " + symbol + " and font size " + font + ".");
        }
        return mode;
      }, styleWrap = function(delim, toStyle, options, classes) {
        toStyle = options.havingBaseStyle(toStyle);
        delim = buildCommon.makeSpan(classes.concat(toStyle.sizingClasses(options)), [delim], options);
        options = toStyle.sizeMultiplier / options.sizeMultiplier;
        delim.height *= options;
        delim.depth *= options;
        delim.maxFontSize = toStyle.sizeMultiplier;
        return delim;
      }, centerSpan = function(span, options, style) {
        style = options.havingBaseStyle(style);
        options = (1 - options.sizeMultiplier / style.sizeMultiplier) * options.fontMetrics().axisHeight;
        span.classes.push("delimcenter");
        span.style.top = makeEm(options);
        span.height -= options;
        span.depth += options;
      }, makeLargeDelim = function(delim, size, center, options, mode, classes) {
        delim = buildCommon.makeSymbol(delim, "Size" + size + "-Regular", mode, options);
        size = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [delim], options), JSCompiler_object_inline_TEXT_2535, options, classes);
        center && centerSpan(size, options, JSCompiler_object_inline_TEXT_2535);
        return size;
      }, makeGlyphSpan = function(symbol, font, mode) {
        return {type:"elem", elem:buildCommon.makeSpan(["delimsizinginner", "Size1-Regular" === font ? "delim-size1" : "delim-size4"], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])])};
      }, makeInner = function(ch, height, options) {
        const width = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
        ch = new PathNode("inner", innerPath(ch, Math.round(1000 * height)));
        ch = new SvgNode([ch], {width:makeEm(width), height:makeEm(height), style:"width:" + makeEm(width), viewBox:"0 0 " + 1000 * width + " " + Math.round(1000 * height), preserveAspectRatio:"xMinYMin"});
        options = buildCommon.makeSvgSpan([], [ch], options);
        options.height = height;
        options.style.height = makeEm(height);
        options.style.width = makeEm(width);
        return {type:"elem", elem:options};
      }, lap = {type:"kern", size:-.008}, verts = ["|", "\\lvert", "\\rvert", "\\vert"], doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"], makeStackedDelim = function(delim, heightTotal, center, options, mode, classes) {
        let repeat, bottom;
        var svgLabel = "", viewBoxWidth = 0;
        var top = repeat = bottom = delim;
        var middle = null;
        let font = "Size1-Regular";
        if ("\\uparrow" === delim) {
          repeat = bottom = "⏐";
        } else if ("\\Uparrow" === delim) {
          repeat = bottom = "‖";
        } else if ("\\downarrow" === delim) {
          top = repeat = "⏐";
        } else if ("\\Downarrow" === delim) {
          top = repeat = "‖";
        } else if ("\\updownarrow" === delim) {
          top = "\\uparrow", repeat = "⏐", bottom = "\\downarrow";
        } else if ("\\Updownarrow" === delim) {
          top = "\\Uparrow", repeat = "‖", bottom = "\\Downarrow";
        } else if (utils.contains(verts, delim)) {
          repeat = "∣", svgLabel = "vert", viewBoxWidth = 333;
        } else if (utils.contains(doubleVerts, delim)) {
          repeat = "∥", svgLabel = "doublevert", viewBoxWidth = 556;
        } else if ("[" === delim || "\\lbrack" === delim) {
          top = "⎡", repeat = "⎢", bottom = "⎣", font = "Size4-Regular", svgLabel = "lbrack", viewBoxWidth = 667;
        } else if ("]" === delim || "\\rbrack" === delim) {
          top = "⎤", repeat = "⎥", bottom = "⎦", font = "Size4-Regular", svgLabel = "rbrack", viewBoxWidth = 667;
        } else if ("\\lfloor" === delim || "⌊" === delim) {
          repeat = top = "⎢", bottom = "⎣", font = "Size4-Regular", svgLabel = "lfloor", viewBoxWidth = 667;
        } else if ("\\lceil" === delim || "⌈" === delim) {
          top = "⎡", repeat = bottom = "⎢", font = "Size4-Regular", svgLabel = "lceil", viewBoxWidth = 667;
        } else if ("\\rfloor" === delim || "⌋" === delim) {
          repeat = top = "⎥", bottom = "⎦", font = "Size4-Regular", svgLabel = "rfloor", viewBoxWidth = 667;
        } else if ("\\rceil" === delim || "⌉" === delim) {
          top = "⎤", repeat = bottom = "⎥", font = "Size4-Regular", svgLabel = "rceil", viewBoxWidth = 667;
        } else if ("(" === delim || "\\lparen" === delim) {
          top = "⎛", repeat = "⎜", bottom = "⎝", font = "Size4-Regular", svgLabel = "lparen", viewBoxWidth = 875;
        } else if (")" === delim || "\\rparen" === delim) {
          top = "⎞", repeat = "⎟", bottom = "⎠", font = "Size4-Regular", svgLabel = "rparen", viewBoxWidth = 875;
        } else if ("\\{" === delim || "\\lbrace" === delim) {
          top = "⎧", middle = "⎨", bottom = "⎩", repeat = "⎪", font = "Size4-Regular";
        } else if ("\\}" === delim || "\\rbrace" === delim) {
          top = "⎫", middle = "⎬", bottom = "⎭", repeat = "⎪", font = "Size4-Regular";
        } else if ("\\lgroup" === delim || "⟮" === delim) {
          top = "⎧", bottom = "⎩", repeat = "⎪", font = "Size4-Regular";
        } else if ("\\rgroup" === delim || "⟯" === delim) {
          top = "⎫", bottom = "⎭", repeat = "⎪", font = "Size4-Regular";
        } else if ("\\lmoustache" === delim || "⎰" === delim) {
          top = "⎧", bottom = "⎭", repeat = "⎪", font = "Size4-Regular";
        } else if ("\\rmoustache" === delim || "⎱" === delim) {
          top = "⎫", bottom = "⎩", repeat = "⎪", font = "Size4-Regular";
        }
        delim = getMetrics(top, font, mode);
        delim = delim.height + delim.depth;
        var repeatMetrics = getMetrics(repeat, font, mode), repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
        repeatMetrics = getMetrics(bottom, font, mode);
        repeatMetrics = repeatMetrics.height + repeatMetrics.depth;
        var middleHeightTotal = 0;
        let middleFactor = 1;
        null !== middle && (middleHeightTotal = getMetrics(middle, font, mode), middleHeightTotal = middleHeightTotal.height + middleHeightTotal.depth, middleFactor = 2);
        const minHeight = delim + repeatMetrics + middleHeightTotal;
        repeatHeightTotal = minHeight + Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal))) * middleFactor * repeatHeightTotal;
        heightTotal = options.fontMetrics().axisHeight;
        center && (heightTotal *= options.sizeMultiplier);
        center = repeatHeightTotal / 2 - heightTotal;
        heightTotal = [];
        0 < svgLabel.length ? (mode = Math.round(1000 * repeatHeightTotal), top = tallDelim(svgLabel, Math.round(1000 * (repeatHeightTotal - delim - repeatMetrics))), middle = new PathNode(svgLabel, top), svgLabel = (viewBoxWidth / 1000).toFixed(3) + "em", top = (mode / 1000).toFixed(3) + "em", viewBoxWidth = new SvgNode([middle], {width:svgLabel, height:top, viewBox:"0 0 " + viewBoxWidth + " " + mode}), viewBoxWidth = buildCommon.makeSvgSpan([], [viewBoxWidth], options), viewBoxWidth.height = mode / 
        1000, viewBoxWidth.style.width = svgLabel, viewBoxWidth.style.height = top, heightTotal.push({type:"elem", elem:viewBoxWidth})) : (heightTotal.push(makeGlyphSpan(bottom, font, mode)), heightTotal.push(lap), null === middle ? heightTotal.push(makeInner(repeat, repeatHeightTotal - delim - repeatMetrics + .016, options)) : (viewBoxWidth = (repeatHeightTotal - delim - repeatMetrics - middleHeightTotal) / 2 + .016, heightTotal.push(makeInner(repeat, viewBoxWidth, options)), heightTotal.push(lap), 
        heightTotal.push(makeGlyphSpan(middle, font, mode)), heightTotal.push(lap), heightTotal.push(makeInner(repeat, viewBoxWidth, options))), heightTotal.push(lap), heightTotal.push(makeGlyphSpan(top, font, mode)));
        viewBoxWidth = options.havingBaseStyle(JSCompiler_object_inline_TEXT_2535);
        svgLabel = buildCommon.makeVList({positionType:"bottom", positionData:center, children:heightTotal}, viewBoxWidth);
        return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [svgLabel], viewBoxWidth), JSCompiler_object_inline_TEXT_2535, options, classes);
      }, sqrtSvg = function(sqrtName, height, viewBoxHeight, extraVinculum, options) {
        extraVinculum *= 1000;
        let path = "";
        switch(sqrtName) {
          case "sqrtMain":
            path = "M95," + (622 + extraVinculum + 80) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + 
            (834 + extraVinculum) + " 80h400000v" + (40 + extraVinculum) + "h-400000z";
            break;
          case "sqrtSize1":
            path = "M263," + (601 + extraVinculum + 80) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + 
            (1001 + extraVinculum) + " 80h400000v" + (40 + extraVinculum) + "h-400000z";
            break;
          case "sqrtSize2":
            path = "M983 " + (10 + extraVinculum + 80) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + 
            (1001 + extraVinculum) + " 80h400000v" + (40 + extraVinculum) + "h-400000z";
            break;
          case "sqrtSize3":
            path = "M424," + (2398 + extraVinculum + 80) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + 
            (1001 + extraVinculum) + " 80\nh400000v" + (40 + extraVinculum) + "h-400000z";
            break;
          case "sqrtSize4":
            path = "M473," + (2713 + extraVinculum + 80) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + 
            (1001 + extraVinculum) + " 80h400000v" + (40 + extraVinculum) + "H1017.7z";
            break;
          case "sqrtTall":
            path = "M702 " + (extraVinculum + 80) + "H400000" + (40 + extraVinculum) + "\nH742v" + (viewBoxHeight - 54 - 80 - extraVinculum) + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 80H400000v" + (40 + extraVinculum) + "H742z";
        }
        sqrtName = new PathNode(sqrtName, path);
        height = new SvgNode([sqrtName], {width:"400em", height:makeEm(height), viewBox:"0 0 400000 " + viewBoxHeight, preserveAspectRatio:"xMinYMin slice"});
        return buildCommon.makeSvgSpan(["hide-tail"], [height], options);
      }, stackLargeDelimiters = "( \\lparen ) \\rparen [ \\lbrack ] \\rbrack \\{ \\lbrace \\} \\rbrace \\lfloor \\rfloor ⌊ ⌋ \\lceil \\rceil ⌈ ⌉ \\surd".split(" "), stackAlwaysDelimiters = "\\uparrow \\downarrow \\updownarrow \\Uparrow \\Downarrow \\Updownarrow | \\| \\vert \\Vert \\lvert \\rvert \\lVert \\rVert \\lgroup \\rgroup ⟮ ⟯ \\lmoustache \\rmoustache ⎰ ⎱".split(" "), stackNeverDelimiters = "\x3c \x3e \\langle \\rangle / \\backslash \\lt \\gt".split(" "), sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 
      3.0], stackNeverDelimiterSequence = [{type:"small", style:JSCompiler_object_inline_SCRIPTSCRIPT_2537}, {type:"small", style:JSCompiler_object_inline_SCRIPT_2536}, {type:"small", style:JSCompiler_object_inline_TEXT_2535}, {type:"large", size:1}, {type:"large", size:2}, {type:"large", size:3}, {type:"large", size:4}], stackAlwaysDelimiterSequence = [{type:"small", style:JSCompiler_object_inline_SCRIPTSCRIPT_2537}, {type:"small", style:JSCompiler_object_inline_SCRIPT_2536}, {type:"small", style:JSCompiler_object_inline_TEXT_2535}, 
      {type:"stack"}], stackLargeDelimiterSequence = [{type:"small", style:JSCompiler_object_inline_SCRIPTSCRIPT_2537}, {type:"small", style:JSCompiler_object_inline_SCRIPT_2536}, {type:"small", style:JSCompiler_object_inline_TEXT_2535}, {type:"large", size:1}, {type:"large", size:2}, {type:"large", size:3}, {type:"large", size:4}, {type:"stack"}], traverseSequence = function(delim, height, sequence, options) {
        for (var start = Math.min(2, 3 - options.style.size); start < sequence.length && "stack" !== sequence[start].type; start++) {
          var JSCompiler_inline_result = sequence[start];
          if ("small" === JSCompiler_inline_result.type) {
            JSCompiler_inline_result = "Main-Regular";
          } else if ("large" === JSCompiler_inline_result.type) {
            JSCompiler_inline_result = "Size" + JSCompiler_inline_result.size + "-Regular";
          } else if ("stack" === JSCompiler_inline_result.type) {
            JSCompiler_inline_result = "Size4-Regular";
          } else {
            throw Error("Add support for delim type '" + JSCompiler_inline_result.type + "' here.");
          }
          JSCompiler_inline_result = getMetrics(delim, JSCompiler_inline_result, "math");
          JSCompiler_inline_result = JSCompiler_inline_result.height + JSCompiler_inline_result.depth;
          if ("small" === sequence[start].type) {
            const newOptions = options.havingBaseStyle(sequence[start].style);
            JSCompiler_inline_result *= newOptions.sizeMultiplier;
          }
          if (JSCompiler_inline_result > height) {
            return sequence[start];
          }
        }
        return sequence[sequence.length - 1];
      }, makeCustomSizedDelim = function(delim, height, center, options, mode, classes) {
        if ("\x3c" === delim || "\\lt" === delim || "⟨" === delim) {
          delim = "\\langle";
        } else if ("\x3e" === delim || "\\gt" === delim || "⟩" === delim) {
          delim = "\\rangle";
        }
        var sequence = utils.contains(stackNeverDelimiters, delim) ? stackNeverDelimiterSequence : utils.contains(stackLargeDelimiters, delim) ? stackLargeDelimiterSequence : stackAlwaysDelimiterSequence;
        sequence = traverseSequence(delim, height, sequence, options);
        return "small" === sequence.type ? (height = sequence.style, delim = buildCommon.makeSymbol(delim, "Main-Regular", mode, options), classes = styleWrap(delim, height, options, classes), center && centerSpan(classes, options, height), classes) : "large" === sequence.type ? makeLargeDelim(delim, sequence.size, center, options, mode, classes) : makeStackedDelim(delim, height, center, options, mode, classes);
      };
      var delimiter = {sqrtImage:function(height, options) {
        var newOptions = options.havingBaseSizing(), delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
        newOptions = newOptions.sizeMultiplier;
        const extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
        let spanHeight, texHeight;
        "small" === delim.type ? (1.0 > height ? newOptions = 1.0 : 1.4 > height && (newOptions = 0.7), spanHeight = (1.0 + extraVinculum + 0.08) / newOptions, texHeight = (1.00 + extraVinculum) / newOptions, delim = sqrtSvg("sqrtMain", spanHeight, 1000 * extraVinculum + 1080, extraVinculum, options), delim.style.minWidth = "0.853em", height = 0.833 / newOptions) : "large" === delim.type ? (height = 1080 * sizeToMaxHeight[delim.size], texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / newOptions, 
        spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + 0.08) / newOptions, delim = sqrtSvg("sqrtSize" + delim.size, spanHeight, height, extraVinculum, options), delim.style.minWidth = "1.02em", height = 1.0 / newOptions) : (spanHeight = height + extraVinculum + 0.08, texHeight = height + extraVinculum, height = Math.floor(1000 * height + extraVinculum) + 80, delim = sqrtSvg("sqrtTall", spanHeight, height, extraVinculum, options), delim.style.minWidth = "0.742em", height = 1.056);
        delim.height = texHeight;
        delim.style.height = makeEm(spanHeight);
        return {span:delim, advanceWidth:height, ruleWidth:(options.fontMetrics().sqrtRuleThickness + extraVinculum) * newOptions};
      }, sizedDelim:function(delim, size, options, mode, classes) {
        if ("\x3c" === delim || "\\lt" === delim || "⟨" === delim) {
          delim = "\\langle";
        } else if ("\x3e" === delim || "\\gt" === delim || "⟩" === delim) {
          delim = "\\rangle";
        }
        if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
          return makeLargeDelim(delim, size, !1, options, mode, classes);
        }
        if (utils.contains(stackAlwaysDelimiters, delim)) {
          return makeStackedDelim(delim, sizeToMaxHeight[size], !1, options, mode, classes);
        }
        throw new src_ParseError("Illegal delimiter: '" + delim + "'");
      }, sizeToMaxHeight, customSizedDelim:makeCustomSizedDelim, leftRightDelim:function(delim, height, depth, options, mode, classes) {
        const axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier, delimiterExtend = 5.0 / options.fontMetrics().ptPerEm;
        height = Math.max(height - axisHeight, depth + axisHeight);
        return makeCustomSizedDelim(delim, Math.max(height / 500 * 901, 2 * height - delimiterExtend), !0, options, mode, classes);
      }};
      const delimiterSizes = {"\\bigl":{mclass:"mopen", size:1}, "\\Bigl":{mclass:"mopen", size:2}, "\\biggl":{mclass:"mopen", size:3}, "\\Biggl":{mclass:"mopen", size:4}, "\\bigr":{mclass:"mclose", size:1}, "\\Bigr":{mclass:"mclose", size:2}, "\\biggr":{mclass:"mclose", size:3}, "\\Biggr":{mclass:"mclose", size:4}, "\\bigm":{mclass:"mrel", size:1}, "\\Bigm":{mclass:"mrel", size:2}, "\\biggm":{mclass:"mrel", size:3}, "\\Biggm":{mclass:"mrel", size:4}, "\\big":{mclass:"mord", size:1}, "\\Big":{mclass:"mord", 
      size:2}, "\\bigg":{mclass:"mord", size:3}, "\\Bigg":{mclass:"mord", size:4}}, delimiters = "( \\lparen ) \\rparen [ \\lbrack ] \\rbrack \\{ \\lbrace \\} \\rbrace \\lfloor \\rfloor ⌊ ⌋ \\lceil \\rceil ⌈ ⌉ \x3c \x3e \\langle ⟨ \\rangle ⟩ \\lt \\gt \\lvert \\rvert \\lVert \\rVert \\lgroup \\rgroup ⟮ ⟯ \\lmoustache \\rmoustache ⎰ ⎱ / \\backslash | \\vert \\| \\Vert \\uparrow \\Uparrow \\downarrow \\Downarrow \\updownarrow \\Updownarrow .".split(" ");
      defineFunction({type:"delimsizing", names:"\\bigl \\Bigl \\biggl \\Biggl \\bigr \\Bigr \\biggr \\Biggr \\bigm \\Bigm \\biggm \\Biggm \\big \\Big \\bigg \\Bigg".split(" "), props:{numArgs:1, argTypes:["primitive"]}, handler:(context, args) => {
        args = checkDelimiter(args[0], context);
        return {type:"delimsizing", mode:context.parser.mode, size:delimiterSizes[context.funcName].size, mclass:delimiterSizes[context.funcName].mclass, delim:args.text};
      }, htmlBuilder:(group, options) => "." === group.delim ? buildCommon.makeSpan([group.mclass]) : delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]), mathmlBuilder:group => {
        var children = [];
        "." !== group.delim && children.push(makeText(group.delim, group.mode));
        children = new mathMLTree.MathNode("mo", children);
        "mopen" === group.mclass || "mclose" === group.mclass ? children.setAttribute("fence", "true") : children.setAttribute("fence", "false");
        children.setAttribute("stretchy", "true");
        group = makeEm(delimiter.sizeToMaxHeight[group.size]);
        children.setAttribute("minsize", group);
        children.setAttribute("maxsize", group);
        return children;
      }});
      defineFunction({type:"leftright-right", names:["\\right"], props:{numArgs:1, primitive:!0}, handler:(context, args) => {
        const color = context.parser.gullet.macros.get("\\current@color");
        if (color && "string" !== typeof color) {
          throw new src_ParseError("\\current@color set to non-string in \\right");
        }
        return {type:"leftright-right", mode:context.parser.mode, delim:checkDelimiter(args[0], context).text, color};
      }});
      defineFunction({type:"leftright", names:["\\left"], props:{numArgs:1, primitive:!0}, handler:(context, args) => {
        args = checkDelimiter(args[0], context);
        context = context.parser;
        ++context.leftrightDepth;
        const body = context.parseExpression(!1);
        --context.leftrightDepth;
        context.expect("\\right", !1);
        const right = assertNodeType(context.parseFunction(), "leftright-right");
        return {type:"leftright", mode:context.mode, body, left:args.text, right:right.delim, rightColor:right.color};
      }, htmlBuilder:(group, options) => {
        assertParsed(group);
        const inner = buildExpression(group.body, options, !0, ["mopen", "mclose"]);
        let innerHeight = 0, innerDepth = 0;
        var hadMiddle = !1;
        for (var i = 0; i < inner.length; i++) {
          inner[i].isMiddle ? hadMiddle = !0 : (innerHeight = Math.max(inner[i].height, innerHeight), innerDepth = Math.max(inner[i].depth, innerDepth));
        }
        innerHeight *= options.sizeMultiplier;
        innerDepth *= options.sizeMultiplier;
        i = "." === group.left ? makeNullDelimiter(options, ["mopen"]) : delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
        inner.unshift(i);
        if (hadMiddle) {
          for (hadMiddle = 1; hadMiddle < inner.length; hadMiddle++) {
            (i = inner[hadMiddle].isMiddle) && (inner[hadMiddle] = delimiter.leftRightDelim(i.delim, innerHeight, innerDepth, i.options, group.mode, []));
          }
        }
        "." === group.right ? group = makeNullDelimiter(options, ["mclose"]) : (hadMiddle = group.rightColor ? options.withColor(group.rightColor) : options, group = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, hadMiddle, group.mode, ["mclose"]));
        inner.push(group);
        return buildCommon.makeSpan(["minner"], inner, options);
      }, mathmlBuilder:(group, options) => {
        assertParsed(group);
        options = buildMathML_buildExpression(group.body, options);
        if ("." !== group.left) {
          var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
          leftNode.setAttribute("fence", "true");
          options.unshift(leftNode);
        }
        "." !== group.right && (leftNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]), leftNode.setAttribute("fence", "true"), group.rightColor && leftNode.setAttribute("mathcolor", group.rightColor), options.push(leftNode));
        return makeRow(options);
      }});
      defineFunction({type:"middle", names:["\\middle"], props:{numArgs:1, primitive:!0}, handler:(context, args) => {
        args = checkDelimiter(args[0], context);
        if (!context.parser.leftrightDepth) {
          throw new src_ParseError("\\middle without preceding \\left", args);
        }
        return {type:"middle", mode:context.parser.mode, delim:args.text};
      }, htmlBuilder:(group, options) => {
        let middleDelim;
        "." === group.delim ? middleDelim = makeNullDelimiter(options, []) : (middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []), middleDelim.isMiddle = {delim:group.delim, options});
        return middleDelim;
      }, mathmlBuilder:(group, options) => {
        group = "\\vert" === group.delim || "|" === group.delim ? makeText("|", "text") : makeText(group.delim, group.mode);
        group = new mathMLTree.MathNode("mo", [group]);
        group.setAttribute("fence", "true");
        group.setAttribute("lspace", "0.05em");
        group.setAttribute("rspace", "0.05em");
        return group;
      }});
      const enclose_htmlBuilder = (group, options) => {
        const inner = buildCommon.wrapFragment(buildGroup(group.body, options), options), label = group.label.slice(1);
        let scale = options.sizeMultiplier;
        const isSingleChar = utils.isCharacterBox(group.body);
        if ("sout" === label) {
          var img = buildCommon.makeSpan(["stretchy", "sout"]);
          img.height = options.fontMetrics().defaultRuleThickness / scale;
          var imgShift = -0.5 * options.fontMetrics().xHeight;
        } else if ("phase" === label) {
          imgShift = calculateSize({number:0.6, unit:"pt"}, options);
          var clearance = calculateSize({number:0.35, unit:"ex"}, options);
          img = options.havingBaseSizing();
          scale /= img.sizeMultiplier;
          const angleHeight = inner.height + inner.depth + imgShift + clearance;
          inner.style.paddingLeft = makeEm(angleHeight / 2 + imgShift);
          img = Math.floor(1000 * angleHeight * scale);
          img = new SvgNode([new PathNode("phase", "M400000 " + img + " H0 L" + img / 2 + " 0 l65 45 L145 " + (img - 80) + " H400000z")], {width:"400em", height:makeEm(img / 1000), viewBox:"0 0 400000 " + img, preserveAspectRatio:"xMinYMin slice"});
          img = buildCommon.makeSvgSpan(["hide-tail"], [img], options);
          img.style.height = makeEm(angleHeight);
          imgShift = inner.depth + imgShift + clearance;
        } else {
          /cancel/.test(label) ? isSingleChar || inner.classes.push("cancel-pad") : "angl" === label ? inner.classes.push("anglpad") : inner.classes.push("boxpad"), clearance = 0, /box/.test(label) ? (clearance = Math.max(options.fontMetrics().fboxrule, options.minRuleThickness), imgShift = img = options.fontMetrics().fboxsep + ("colorbox" === label ? 0 : clearance)) : "angl" === label ? (clearance = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness), img = 4 * clearance, 
          imgShift = Math.max(0, 0.25 - inner.depth)) : imgShift = img = isSingleChar ? 0.2 : 0, img = stretchy.encloseSpan(inner, label, img, imgShift, options), /fbox|boxed|fcolorbox/.test(label) ? (img.style.borderStyle = "solid", img.style.borderWidth = makeEm(clearance)) : "angl" === label && 0.049 !== clearance && (img.style.borderTopWidth = makeEm(clearance), img.style.borderRightWidth = makeEm(clearance)), imgShift = inner.depth + imgShift, group.backgroundColor && (img.style.backgroundColor = 
          group.backgroundColor, group.borderColor && (img.style.borderColor = group.borderColor));
        }
        group.backgroundColor ? group = buildCommon.makeVList({positionType:"individualShift", children:[{type:"elem", elem:img, shift:imgShift}, {type:"elem", elem:inner, shift:0}]}, options) : (group = /cancel|phase/.test(label) ? ["svg-align"] : [], group = buildCommon.makeVList({positionType:"individualShift", children:[{type:"elem", elem:inner, shift:0}, {type:"elem", elem:img, shift:imgShift, wrapperClasses:group}]}, options));
        /cancel/.test(label) && (group.height = inner.height, group.depth = inner.depth);
        return /cancel/.test(label) && !isSingleChar ? buildCommon.makeSpan(["mord", "cancel-lap"], [group], options) : buildCommon.makeSpan(["mord"], [group], options);
      }, enclose_mathmlBuilder = (group, options) => {
        let fboxsep;
        const node = new mathMLTree.MathNode(-1 < group.label.indexOf("colorbox") ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);
        switch(group.label) {
          case "\\cancel":
            node.setAttribute("notation", "updiagonalstrike");
            break;
          case "\\bcancel":
            node.setAttribute("notation", "downdiagonalstrike");
            break;
          case "\\phase":
            node.setAttribute("notation", "phasorangle");
            break;
          case "\\sout":
            node.setAttribute("notation", "horizontalstrike");
            break;
          case "\\fbox":
            node.setAttribute("notation", "box");
            break;
          case "\\angl":
            node.setAttribute("notation", "actuarial");
            break;
          case "\\fcolorbox":
          case "\\colorbox":
            fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
            node.setAttribute("width", "+" + 2 * fboxsep + "pt");
            node.setAttribute("height", "+" + 2 * fboxsep + "pt");
            node.setAttribute("lspace", fboxsep + "pt");
            node.setAttribute("voffset", fboxsep + "pt");
            "\\fcolorbox" === group.label && (options = Math.max(options.fontMetrics().fboxrule, options.minRuleThickness), node.setAttribute("style", "border: " + options + "em solid " + String(group.borderColor)));
            break;
          case "\\xcancel":
            node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
        }
        group.backgroundColor && node.setAttribute("mathbackground", group.backgroundColor);
        return node;
      };
      defineFunction({type:"enclose", names:["\\colorbox"], props:{numArgs:2, allowedInText:!0, argTypes:["color", "text"]}, handler(_ref, args, optArgs) {
        let {parser, funcName} = _ref;
        _ref = assertNodeType(args[0], "color-token").color;
        return {type:"enclose", mode:parser.mode, label:funcName, backgroundColor:_ref, body:args[1]};
      }, htmlBuilder:enclose_htmlBuilder, mathmlBuilder:enclose_mathmlBuilder});
      defineFunction({type:"enclose", names:["\\fcolorbox"], props:{numArgs:3, allowedInText:!0, argTypes:["color", "color", "text"]}, handler(_ref2, args, optArgs) {
        let {parser, funcName} = _ref2;
        _ref2 = assertNodeType(args[0], "color-token").color;
        optArgs = assertNodeType(args[1], "color-token").color;
        return {type:"enclose", mode:parser.mode, label:funcName, backgroundColor:optArgs, borderColor:_ref2, body:args[2]};
      }, htmlBuilder:enclose_htmlBuilder, mathmlBuilder:enclose_mathmlBuilder});
      defineFunction({type:"enclose", names:["\\fbox"], props:{numArgs:1, argTypes:["hbox"], allowedInText:!0}, handler(_ref3, args) {
        ({parser:_ref3} = _ref3);
        return {type:"enclose", mode:_ref3.mode, label:"\\fbox", body:args[0]};
      }});
      defineFunction({type:"enclose", names:["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"], props:{numArgs:1}, handler(_ref4, args) {
        let {parser, funcName} = _ref4;
        return {type:"enclose", mode:parser.mode, label:funcName, body:args[0]};
      }, htmlBuilder:enclose_htmlBuilder, mathmlBuilder:enclose_mathmlBuilder});
      defineFunction({type:"enclose", names:["\\angl"], props:{numArgs:1, argTypes:["hbox"], allowedInText:!1}, handler(_ref5, args) {
        ({parser:_ref5} = _ref5);
        return {type:"enclose", mode:_ref5.mode, label:"\\angl", body:args[0]};
      }});
      const _environments = {}, _macros = {};
      class SourceLocation {
        constructor(lexer, start, end) {
          this.end = this.start = this.lexer = void 0;
          this.lexer = lexer;
          this.start = start;
          this.end = end;
        }
        static range(first, second) {
          return second ? first && first.loc && second.loc && first.loc.lexer === second.loc.lexer ? new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end) : null : first && first.loc;
        }
      }
      class Token {
        constructor(text, loc) {
          this.treatAsRelax = this.noexpand = this.loc = this.text = void 0;
          this.text = text;
          this.loc = loc;
        }
        range(endToken, text) {
          return new Token(text, SourceLocation.range(this, endToken));
        }
      }
      const validateAmsEnvironmentContext = context => {
        if (!context.parser.settings.displayMode) {
          throw new src_ParseError("{" + context.envName + "} can be used only in display mode.");
        }
      }, array_htmlBuilder = function(group, options) {
        function setHLinePos(hlinesInGap) {
          for (let i = 0; i < hlinesInGap.length; ++i) {
            0 < i && (totalHeight += 0.25), hlines.push({pos:totalHeight, isDashed:hlinesInGap[i]});
          }
        }
        var nr = group.body.length, hLinesBeforeRow = group.hLinesBeforeRow, nc = 0, body = Array(nr);
        const hlines = [];
        var ruleThickness = Math.max(options.fontMetrics().arrayRuleWidth, options.minRuleThickness);
        var c = 1 / options.fontMetrics().ptPerEm;
        let arraycolsep = 5 * c;
        group.colSeparationType && "small" === group.colSeparationType && (arraycolsep = 0.2778 * (options.havingStyle(JSCompiler_object_inline_SCRIPT_2536).sizeMultiplier / options.sizeMultiplier));
        var r = "CD" === group.colSeparationType ? calculateSize({number:3, unit:"ex"}, options) : 12 * c;
        var jot = 3 * c;
        r *= group.arraystretch;
        var arstrutHeight = 0.7 * r, arstrutDepth = 0.3 * r;
        let totalHeight = 0;
        setHLinePos(hLinesBeforeRow[0]);
        for (r = 0; r < group.body.length; ++r) {
          var inrow = group.body[r], height = arstrutHeight, depth = arstrutDepth;
          nc < inrow.length && (nc = inrow.length);
          var outrow = Array(inrow.length);
          for (c = 0; c < inrow.length; ++c) {
            var elt = buildGroup(inrow[c], options);
            depth < elt.depth && (depth = elt.depth);
            height < elt.height && (height = elt.height);
            outrow[c] = elt;
          }
          c = group.rowGaps[r];
          inrow = 0;
          c && (inrow = calculateSize(c, options), 0 < inrow && (inrow += arstrutDepth, depth < inrow && (depth = inrow), inrow = 0));
          group.addJot && (depth += jot);
          outrow.height = height;
          outrow.depth = depth;
          totalHeight += height;
          outrow.pos = totalHeight;
          totalHeight += depth + inrow;
          body[r] = outrow;
          setHLinePos(hLinesBeforeRow[r + 1]);
        }
        hLinesBeforeRow = totalHeight / 2 + options.fontMetrics().axisHeight;
        arstrutHeight = group.cols || [];
        arstrutDepth = [];
        jot = [];
        if (group.tags && group.tags.some(tag => tag)) {
          for (r = 0; r < nr; ++r) {
            c = body[r], height = c.pos - hLinesBeforeRow, depth = group.tags[r], depth = !0 === depth ? buildCommon.makeSpan(["eqn-num"], [], options) : !1 === depth ? buildCommon.makeSpan([], [], options) : buildCommon.makeSpan([], buildExpression(depth, options, !0), options), depth.depth = c.depth, depth.height = c.height, jot.push({type:"elem", elem:depth, shift:height});
          }
        }
        for (height = c = 0; c < nc || height < arstrutHeight.length; ++c, ++height) {
          depth = arstrutHeight[height] || {};
          for (r = !0; "separator" === depth.type;) {
            r || (r = buildCommon.makeSpan(["arraycolsep"], []), r.style.width = makeEm(options.fontMetrics().doubleRuleSep), arstrutDepth.push(r));
            if ("|" === depth.separator || ":" === depth.separator) {
              depth = "|" === depth.separator ? "solid" : "dashed";
              r = buildCommon.makeSpan(["vertical-separator"], [], options);
              r.style.height = makeEm(totalHeight);
              r.style.borderRightWidth = makeEm(ruleThickness);
              r.style.borderRightStyle = depth;
              r.style.margin = "0 " + makeEm(-ruleThickness / 2);
              if (depth = totalHeight - hLinesBeforeRow) {
                r.style.verticalAlign = makeEm(-depth);
              }
              arstrutDepth.push(r);
            } else {
              throw new src_ParseError("Invalid separator type: " + depth.separator);
            }
            height++;
            depth = arstrutHeight[height] || {};
            r = !1;
          }
          if (!(c >= nc)) {
            if (0 < c || group.hskipBeforeAndAfter) {
              outrow = utils.deflt(depth.pregap, arraycolsep), 0 !== outrow && (r = buildCommon.makeSpan(["arraycolsep"], []), r.style.width = makeEm(outrow), arstrutDepth.push(r));
            }
            outrow = [];
            for (r = 0; r < nr; ++r) {
              inrow = body[r];
              elt = inrow[c];
              if (!elt) {
                continue;
              }
              const shift = inrow.pos - hLinesBeforeRow;
              elt.depth = inrow.depth;
              elt.height = inrow.height;
              outrow.push({type:"elem", elem:elt, shift});
            }
            outrow = buildCommon.makeVList({positionType:"individualShift", children:outrow}, options);
            outrow = buildCommon.makeSpan(["col-align-" + (depth.align || "c")], [outrow]);
            arstrutDepth.push(outrow);
            if (c < nc - 1 || group.hskipBeforeAndAfter) {
              outrow = utils.deflt(depth.postgap, arraycolsep), 0 !== outrow && (r = buildCommon.makeSpan(["arraycolsep"], []), r.style.width = makeEm(outrow), arstrutDepth.push(r));
            }
          }
        }
        body = buildCommon.makeSpan(["mtable"], arstrutDepth);
        if (0 < hlines.length) {
          group = buildCommon.makeLineSpan("hline", options, ruleThickness);
          ruleThickness = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
          for (body = [{type:"elem", elem:body, shift:0}]; 0 < hlines.length;) {
            nr = hlines.pop(), nc = nr.pos - hLinesBeforeRow, nr.isDashed ? body.push({type:"elem", elem:ruleThickness, shift:nc}) : body.push({type:"elem", elem:group, shift:nc});
          }
          body = buildCommon.makeVList({positionType:"individualShift", children:body}, options);
        }
        if (0 === jot.length) {
          return buildCommon.makeSpan(["mord"], [body], options);
        }
        ruleThickness = buildCommon.makeVList({positionType:"individualShift", children:jot}, options);
        ruleThickness = buildCommon.makeSpan(["tag"], [ruleThickness], options);
        return buildCommon.makeFragment([body, ruleThickness]);
      }, alignMap = {c:"center ", l:"left ", r:"right "}, array_mathmlBuilder = function(group, options) {
        var tbl = [], glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]), tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
        for (var i = 0; i < group.body.length; i++) {
          var rw = group.body[i], row = [];
          for (var j = 0; j < rw.length; j++) {
            row.push(new mathMLTree.MathNode("mtd", [buildMathML_buildGroup(rw[j], options)]));
          }
          group.tags && group.tags[i] && (row.unshift(glue), row.push(glue), group.leqno ? row.unshift(tag) : row.push(tag));
          tbl.push(new mathMLTree.MathNode("mtr", row));
        }
        options = new mathMLTree.MathNode("mtable", tbl);
        options.setAttribute("rowspacing", makeEm(0.5 === group.arraystretch ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0)));
        glue = tbl = "";
        if (group.cols && 0 < group.cols.length) {
          tag = group.cols;
          i = "";
          rw = !1;
          j = 0;
          row = tag.length;
          "separator" === tag[0].type && (tbl += "top ", j = 1);
          "separator" === tag[tag.length - 1].type && (tbl += "bottom ", --row);
          for (; j < row; j++) {
            "align" === tag[j].type ? (glue += alignMap[tag[j].align], rw && (i += "none "), rw = !0) : "separator" === tag[j].type && rw && (i += "|" === tag[j].separator ? "solid " : "dashed ", rw = !1);
          }
          options.setAttribute("columnalign", glue.trim());
          /[sd]/.test(i) && options.setAttribute("columnlines", i.trim());
        }
        if ("align" === group.colSeparationType) {
          glue = group.cols || [];
          tag = "";
          for (i = 1; i < glue.length; i++) {
            tag += i % 2 ? "0em " : "1em ";
          }
          options.setAttribute("columnspacing", tag.trim());
        } else {
          "alignat" === group.colSeparationType || "gather" === group.colSeparationType ? options.setAttribute("columnspacing", "0em") : "small" === group.colSeparationType ? options.setAttribute("columnspacing", "0.2778em") : "CD" === group.colSeparationType ? options.setAttribute("columnspacing", "0.5em") : options.setAttribute("columnspacing", "1em");
        }
        glue = "";
        tag = group.hLinesBeforeRow;
        tbl += 0 < tag[0].length ? "left " : "";
        tbl += 0 < tag[tag.length - 1].length ? "right " : "";
        for (i = 1; i < tag.length - 1; i++) {
          glue += 0 === tag[i].length ? "none " : tag[i][0] ? "dashed " : "solid ";
        }
        /[sd]/.test(glue) && options.setAttribute("rowlines", glue.trim());
        "" !== tbl && (options = new mathMLTree.MathNode("menclose", [options]), options.setAttribute("notation", tbl.trim()));
        group.arraystretch && 1 > group.arraystretch && (options = new mathMLTree.MathNode("mstyle", [options]), options.setAttribute("scriptlevel", "1"));
        return options;
      }, alignedHandler = function(context, args) {
        -1 === context.envName.indexOf("ed") && validateAmsEnvironmentContext(context);
        const cols = [];
        var separationType = -1 < context.envName.indexOf("at") ? "alignat" : "align", isSplit = "split" === context.envName;
        separationType = parseArray(context.parser, {cols, addJot:!0, autoTag:isSplit ? void 0 : getAutoTag(context.envName), emptySingleRow:!0, colSeparationType:separationType, maxNumCols:isSplit ? 2 : void 0, leqno:context.parser.settings.leqno}, "display");
        let numMaths, numCols = 0;
        const emptyGroup = {type:"ordgroup", mode:context.mode, body:[]};
        if (args[0] && "ordgroup" === args[0].type) {
          context = "";
          for (isSplit = 0; isSplit < args[0].body.length; isSplit++) {
            const textord = assertNodeType(args[0].body[isSplit], "textord");
            context += textord.text;
          }
          numMaths = Number(context);
          numCols = 2 * numMaths;
        }
        const isAligned = !numCols;
        separationType.body.forEach(function(row) {
          for (var i = 1; i < row.length; i += 2) {
            const styling = assertNodeType(row[i], "styling");
            assertNodeType(styling.body[0], "ordgroup").body.unshift(emptyGroup);
          }
          if (isAligned) {
            numCols < row.length && (numCols = row.length);
          } else {
            if (i = row.length / 2, numMaths < i) {
              throw new src_ParseError("Too many math in a row: expected " + (numMaths + ", but got " + i), row[0]);
            }
          }
        });
        for (args = 0; args < numCols; ++args) {
          context = "r", isSplit = 0, 1 === args % 2 ? context = "l" : 0 < args && isAligned && (isSplit = 1), cols[args] = {type:"align", align:context, pregap:isSplit, postgap:0};
        }
        separationType.colSeparationType = isAligned ? "align" : "alignat";
        return separationType;
      };
      defineEnvironment({type:"array", names:["array", "darray"], props:{numArgs:1}, handler(context, args) {
        args = (checkSymbolNodeType(args[0]) ? [args[0]] : assertNodeType(args[0], "ordgroup").body).map(function(nde) {
          const ca = assertSymbolNodeType(nde).text;
          if (-1 !== "lcr".indexOf(ca)) {
            return {type:"align", align:ca};
          }
          if ("|" === ca) {
            return {type:"separator", separator:"|"};
          }
          if (":" === ca) {
            return {type:"separator", separator:":"};
          }
          throw new src_ParseError("Unknown column alignment: " + ca, nde);
        });
        return parseArray(context.parser, {cols:args, hskipBeforeAndAfter:!0, maxNumCols:args.length}, dCellStyle(context.envName));
      }, htmlBuilder:array_htmlBuilder, mathmlBuilder:array_mathmlBuilder});
      defineEnvironment({type:"array", names:"matrix pmatrix bmatrix Bmatrix vmatrix Vmatrix matrix* pmatrix* bmatrix* Bmatrix* vmatrix* Vmatrix*".split(" "), props:{numArgs:0}, handler(context) {
        const delimiters = {matrix:null, pmatrix:["(", ")"], bmatrix:["[", "]"], Bmatrix:["\\{", "\\}"], vmatrix:["|", "|"], Vmatrix:["\\Vert", "\\Vert"]}[context.envName.replace("*", "")];
        let colAlign = "c";
        var payload = {hskipBeforeAndAfter:!1, cols:[{type:"align", align:colAlign}]};
        if ("*" === context.envName.charAt(context.envName.length - 1)) {
          var parser = context.parser;
          parser.consumeSpaces();
          if ("[" === parser.fetch().text) {
            parser.consume();
            parser.consumeSpaces();
            colAlign = parser.fetch().text;
            if (-1 === "lcr".indexOf(colAlign)) {
              throw new src_ParseError("Expected l or c or r", parser.nextToken);
            }
            parser.consume();
            parser.consumeSpaces();
            parser.expect("]");
            parser.consume();
            payload.cols = [{type:"align", align:colAlign}];
          }
        }
        payload = parseArray(context.parser, payload, dCellStyle(context.envName));
        parser = Math.max(0, ...payload.body.map(row => row.length));
        payload.cols = Array(parser).fill({type:"align", align:colAlign});
        return delimiters ? {type:"leftright", mode:context.mode, body:[payload], left:delimiters[0], right:delimiters[1], rightColor:void 0} : payload;
      }, htmlBuilder:array_htmlBuilder, mathmlBuilder:array_mathmlBuilder});
      defineEnvironment({type:"array", names:["smallmatrix"], props:{numArgs:0}, handler(context) {
        context = parseArray(context.parser, {arraystretch:0.5}, "script");
        context.colSeparationType = "small";
        return context;
      }, htmlBuilder:array_htmlBuilder, mathmlBuilder:array_mathmlBuilder});
      defineEnvironment({type:"array", names:["subarray"], props:{numArgs:1}, handler(context, args) {
        args = (checkSymbolNodeType(args[0]) ? [args[0]] : assertNodeType(args[0], "ordgroup").body).map(function(nde) {
          const ca = assertSymbolNodeType(nde).text;
          if (-1 !== "lc".indexOf(ca)) {
            return {type:"align", align:ca};
          }
          throw new src_ParseError("Unknown column alignment: " + ca, nde);
        });
        if (1 < args.length) {
          throw new src_ParseError("{subarray} can contain only one column");
        }
        args = {cols:args, hskipBeforeAndAfter:!1, arraystretch:0.5};
        args = parseArray(context.parser, args, "script");
        if (0 < args.body.length && 1 < args.body[0].length) {
          throw new src_ParseError("{subarray} can contain only one column");
        }
        return args;
      }, htmlBuilder:array_htmlBuilder, mathmlBuilder:array_mathmlBuilder});
      defineEnvironment({type:"array", names:["cases", "dcases", "rcases", "drcases"], props:{numArgs:0}, handler(context) {
        const res = parseArray(context.parser, {arraystretch:1.2, cols:[{type:"align", align:"l", pregap:0, postgap:1.0}, {type:"align", align:"l", pregap:0, postgap:0}]}, dCellStyle(context.envName));
        return {type:"leftright", mode:context.mode, body:[res], left:-1 < context.envName.indexOf("r") ? "." : "\\{", right:-1 < context.envName.indexOf("r") ? "\\}" : ".", rightColor:void 0};
      }, htmlBuilder:array_htmlBuilder, mathmlBuilder:array_mathmlBuilder});
      defineEnvironment({type:"array", names:["align", "align*", "aligned", "split"], props:{numArgs:0}, handler:alignedHandler, htmlBuilder:array_htmlBuilder, mathmlBuilder:array_mathmlBuilder});
      defineEnvironment({type:"array", names:["gathered", "gather", "gather*"], props:{numArgs:0}, handler(context) {
        utils.contains(["gather", "gather*"], context.envName) && validateAmsEnvironmentContext(context);
        const res = {cols:[{type:"align", align:"c"}], addJot:!0, colSeparationType:"gather", autoTag:getAutoTag(context.envName), emptySingleRow:!0, leqno:context.parser.settings.leqno};
        return parseArray(context.parser, res, "display");
      }, htmlBuilder:array_htmlBuilder, mathmlBuilder:array_mathmlBuilder});
      defineEnvironment({type:"array", names:["alignat", "alignat*", "alignedat"], props:{numArgs:1}, handler:alignedHandler, htmlBuilder:array_htmlBuilder, mathmlBuilder:array_mathmlBuilder});
      defineEnvironment({type:"array", names:["equation", "equation*"], props:{numArgs:0}, handler(context) {
        validateAmsEnvironmentContext(context);
        const res = {autoTag:getAutoTag(context.envName), emptySingleRow:!0, singleRow:!0, maxNumCols:1, leqno:context.parser.settings.leqno};
        return parseArray(context.parser, res, "display");
      }, htmlBuilder:array_htmlBuilder, mathmlBuilder:array_mathmlBuilder});
      defineEnvironment({type:"array", names:["CD"], props:{numArgs:0}, handler(context) {
        validateAmsEnvironmentContext(context);
        context = context.parser;
        const parsedRows = [];
        context.gullet.beginGroup();
        context.gullet.macros.set("\\cr", "\\\\\\relax");
        for (context.gullet.beginGroup();;) {
          parsedRows.push(context.parseExpression(!1, "\\\\"));
          context.gullet.endGroup();
          context.gullet.beginGroup();
          var next = context.fetch().text;
          if ("\x26" === next || "\\\\" === next) {
            context.consume();
          } else if ("\\end" === next) {
            0 === parsedRows[parsedRows.length - 1].length && parsedRows.pop();
            break;
          } else {
            throw new src_ParseError("Expected \\\\ or \\cr or \\end", context.nextToken);
          }
        }
        let row = [];
        next = [row];
        for (let i = 0; i < parsedRows.length; i++) {
          const rowNodes = parsedRows[i];
          var cell = newCell();
          for (let j = 0; j < rowNodes.length; j++) {
            if (isStartOfArrow(rowNodes[j])) {
              row.push(cell);
              j += 1;
              const arrowChar = assertSymbolNodeType(rowNodes[j]).text, labels = Array(2);
              labels[0] = {type:"ordgroup", mode:"math", body:[]};
              labels[1] = {type:"ordgroup", mode:"math", body:[]};
              if (!(-1 < "\x3d|.".indexOf(arrowChar))) {
                if (-1 < "\x3c\x3eAV".indexOf(arrowChar)) {
                  for (let labelNum = 0; 2 > labelNum; labelNum++) {
                    let inLabel = !0;
                    for (let k = j + 1; k < rowNodes.length; k++) {
                      cell = rowNodes[k];
                      if (("mathord" === cell.type || "atom" === cell.type) && cell.text === arrowChar) {
                        inLabel = !1;
                        j = k;
                        break;
                      }
                      if (isStartOfArrow(rowNodes[k])) {
                        throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
                      }
                      labels[labelNum].body.push(rowNodes[k]);
                    }
                    if (inLabel) {
                      throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
                    }
                  }
                } else {
                  throw new src_ParseError('Expected one of "\x3c\x3eAV\x3d|." after @', rowNodes[j]);
                }
              }
              cell = {type:"styling", body:[cdArrow(arrowChar, labels, context)], mode:"math", style:"display"};
              row.push(cell);
              cell = newCell();
            } else {
              cell.body.push(rowNodes[j]);
            }
          }
          0 === i % 2 ? row.push(cell) : row.shift();
          row = [];
          next.push(row);
        }
        context.gullet.endGroup();
        context.gullet.endGroup();
        context = Array(next[0].length).fill({type:"align", align:"c", pregap:0.25, postgap:0.25});
        return {type:"array", mode:"math", body:next, arraystretch:1, addJot:!0, rowGaps:[null], cols:context, colSeparationType:"CD", hLinesBeforeRow:Array(next.length + 1).fill([])};
      }, htmlBuilder:array_htmlBuilder, mathmlBuilder:array_mathmlBuilder});
      _macros["\\nonumber"] = "\\gdef\\@eqnsw{0}";
      _macros["\\notag"] = "\\nonumber";
      defineFunction({type:"text", names:["\\hline", "\\hdashline"], props:{numArgs:0, allowedInText:!0, allowedInMath:!0}, handler(context, args) {
        throw new src_ParseError(context.funcName + " valid only within array environment");
      }});
      var src_environments = _environments;
      defineFunction({type:"environment", names:["\\begin", "\\end"], props:{numArgs:1, argTypes:["text"]}, handler(_ref, args$jscomp$0) {
        let {parser, funcName} = _ref;
        args$jscomp$0 = args$jscomp$0[0];
        if ("ordgroup" !== args$jscomp$0.type) {
          throw new src_ParseError("Invalid environment name", args$jscomp$0);
        }
        _ref = "";
        for (var i = 0; i < args$jscomp$0.body.length; ++i) {
          _ref += assertNodeType(args$jscomp$0.body[i], "textord").text;
        }
        if ("\\begin" === funcName) {
          if (!src_environments.hasOwnProperty(_ref)) {
            throw new src_ParseError("No such environment: " + _ref, args$jscomp$0);
          }
          args$jscomp$0 = src_environments[_ref];
          const {args, optArgs} = parser.parseArguments("\\begin{" + _ref + "}", args$jscomp$0);
          args$jscomp$0 = args$jscomp$0.handler({mode:parser.mode, envName:_ref, parser}, args, optArgs);
          parser.expect("\\end", !1);
          i = parser.nextToken;
          const end = assertNodeType(parser.parseFunction(), "environment");
          if (end.name !== _ref) {
            throw new src_ParseError("Mismatch: \\begin{" + _ref + "} matched by \\end{" + end.name + "}", i);
          }
          return args$jscomp$0;
        }
        return {type:"environment", mode:parser.mode, name:_ref, nameGroup:args$jscomp$0};
      }});
      const font_htmlBuilder = (group, options) => {
        options = options.withFont(group.font);
        return buildGroup(group.body, options);
      }, font_mathmlBuilder = (group, options) => {
        options = options.withFont(group.font);
        return buildMathML_buildGroup(group.body, options);
      }, fontAliases = {"\\Bbb":"\\mathbb", "\\bold":"\\mathbf", "\\frak":"\\mathfrak", "\\bm":"\\boldsymbol"};
      defineFunction({type:"font", names:"\\mathrm \\mathit \\mathbf \\mathnormal \\mathsfit \\mathbb \\mathcal \\mathfrak \\mathscr \\mathsf \\mathtt \\Bbb \\bold \\frak".split(" "), props:{numArgs:1, allowedInArgument:!0}, handler:(_ref, args) => {
        let {parser, funcName} = _ref;
        _ref = normalizeArgument(args[0]);
        args = funcName;
        args in fontAliases && (args = fontAliases[args]);
        return {type:"font", mode:parser.mode, font:args.slice(1), body:_ref};
      }, htmlBuilder:font_htmlBuilder, mathmlBuilder:font_mathmlBuilder});
      defineFunction({type:"mclass", names:["\\boldsymbol", "\\bm"], props:{numArgs:1}, handler:(_ref2, args) => {
        ({parser:_ref2} = _ref2);
        args = args[0];
        const isCharacterBox = utils.isCharacterBox(args);
        return {type:"mclass", mode:_ref2.mode, mclass:binrelClass(args), body:[{type:"font", mode:_ref2.mode, font:"boldsymbol", body:args}], isCharacterBox};
      }});
      defineFunction({type:"font", names:"\\rm \\sf \\tt \\bf \\it \\cal".split(" "), props:{numArgs:0, allowedInText:!0}, handler:(_ref3, args) => {
        let {parser, funcName, breakOnTokenText} = _ref3;
        ({mode:_ref3} = parser);
        args = parser.parseExpression(!0, breakOnTokenText);
        const style = "math" + funcName.slice(1);
        return {type:"font", mode:_ref3, font:style, body:{type:"ordgroup", mode:parser.mode, body:args}};
      }, htmlBuilder:font_htmlBuilder, mathmlBuilder:font_mathmlBuilder});
      const adjustStyle = (size, originalStyle) => {
        "display" === size ? originalStyle = originalStyle.id >= JSCompiler_object_inline_SCRIPT_2536.id ? originalStyle.text() : JSCompiler_object_inline_DISPLAY_2534 : "text" === size && originalStyle.size === JSCompiler_object_inline_DISPLAY_2534.size ? originalStyle = JSCompiler_object_inline_TEXT_2535 : "script" === size ? originalStyle = JSCompiler_object_inline_SCRIPT_2536 : "scriptscript" === size && (originalStyle = JSCompiler_object_inline_SCRIPTSCRIPT_2537);
        return originalStyle;
      }, genfrac_htmlBuilder = (group, options) => {
        const style = adjustStyle(group.size, options.style);
        var nstyle = style.fracNum(), dstyle = style.fracDen();
        var newOptions = options.havingStyle(nstyle);
        nstyle = buildGroup(group.numer, newOptions, options);
        if (group.continued) {
          newOptions = 8.5 / options.fontMetrics().ptPerEm;
          var dStrut = 3.5 / options.fontMetrics().ptPerEm;
          nstyle.height = nstyle.height < newOptions ? newOptions : nstyle.height;
          nstyle.depth = nstyle.depth < dStrut ? dStrut : nstyle.depth;
        }
        newOptions = options.havingStyle(dstyle);
        newOptions = buildGroup(group.denom, newOptions, options);
        let ruleWidth;
        if (group.hasBarLine) {
          group.barSize ? (ruleWidth = calculateSize(group.barSize, options), dStrut = buildCommon.makeLineSpan("frac-line", options, ruleWidth)) : dStrut = buildCommon.makeLineSpan("frac-line", options);
          var ruleSpacing = ruleWidth = dStrut.height;
        } else {
          dStrut = null, ruleWidth = 0, ruleSpacing = options.fontMetrics().defaultRuleThickness;
        }
        let denomShift;
        style.size === JSCompiler_object_inline_DISPLAY_2534.size || "display" === group.size ? (dstyle = options.fontMetrics().num1, ruleSpacing = 0 < ruleWidth ? 3 * ruleSpacing : 7 * ruleSpacing, denomShift = options.fontMetrics().denom1) : (0 < ruleWidth ? dstyle = options.fontMetrics().num2 : (dstyle = options.fontMetrics().num3, ruleSpacing *= 3), denomShift = options.fontMetrics().denom2);
        if (dStrut) {
          const axisHeight = options.fontMetrics().axisHeight;
          dstyle - nstyle.depth - (axisHeight + 0.5 * ruleWidth) < ruleSpacing && (dstyle += ruleSpacing - (dstyle - nstyle.depth - (axisHeight + 0.5 * ruleWidth)));
          axisHeight - 0.5 * ruleWidth - (newOptions.height - denomShift) < ruleSpacing && (denomShift += ruleSpacing - (axisHeight - 0.5 * ruleWidth - (newOptions.height - denomShift)));
          nstyle = buildCommon.makeVList({positionType:"individualShift", children:[{type:"elem", elem:newOptions, shift:denomShift}, {type:"elem", elem:dStrut, shift:-(axisHeight - 0.5 * ruleWidth)}, {type:"elem", elem:nstyle, shift:-dstyle}]}, options);
        } else {
          dStrut = dstyle - nstyle.depth - (newOptions.height - denomShift), dStrut < ruleSpacing && (dstyle += 0.5 * (ruleSpacing - dStrut), denomShift += 0.5 * (ruleSpacing - dStrut)), nstyle = buildCommon.makeVList({positionType:"individualShift", children:[{type:"elem", elem:newOptions, shift:denomShift}, {type:"elem", elem:nstyle, shift:-dstyle}]}, options);
        }
        newOptions = options.havingStyle(style);
        nstyle.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
        nstyle.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
        dStrut = style.size === JSCompiler_object_inline_DISPLAY_2534.size ? options.fontMetrics().delim1 : style.size === JSCompiler_object_inline_SCRIPTSCRIPT_2537.size ? options.havingStyle(JSCompiler_object_inline_SCRIPT_2536).fontMetrics().delim2 : options.fontMetrics().delim2;
        dstyle = null == group.leftDelim ? makeNullDelimiter(options, ["mopen"]) : delimiter.customSizedDelim(group.leftDelim, dStrut, !0, options.havingStyle(style), group.mode, ["mopen"]);
        group = group.continued ? buildCommon.makeSpan([]) : null == group.rightDelim ? makeNullDelimiter(options, ["mclose"]) : delimiter.customSizedDelim(group.rightDelim, dStrut, !0, options.havingStyle(style), group.mode, ["mclose"]);
        return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [dstyle, buildCommon.makeSpan(["mfrac"], [nstyle]), group], options);
      }, genfrac_mathmlBuilder = (group, options) => {
        let node = new mathMLTree.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);
        if (!group.hasBarLine) {
          node.setAttribute("linethickness", "0px");
        } else if (group.barSize) {
          var ruleWidth = calculateSize(group.barSize, options);
          node.setAttribute("linethickness", makeEm(ruleWidth));
        }
        ruleWidth = adjustStyle(group.size, options.style);
        ruleWidth.size !== options.style.size && (node = new mathMLTree.MathNode("mstyle", [node]), node.setAttribute("displaystyle", ruleWidth.size === JSCompiler_object_inline_DISPLAY_2534.size ? "true" : "false"), node.setAttribute("scriptlevel", "0"));
        return null != group.leftDelim || null != group.rightDelim ? (options = [], null != group.leftDelim && (ruleWidth = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]), ruleWidth.setAttribute("fence", "true"), options.push(ruleWidth)), options.push(node), null != group.rightDelim && (group = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]), group.setAttribute("fence", "true"), options.push(group)), makeRow(options)) : 
        node;
      };
      defineFunction({type:"genfrac", names:"\\dfrac \\frac \\tfrac \\dbinom \\binom \\tbinom \\\\atopfrac \\\\bracefrac \\\\brackfrac".split(" "), props:{numArgs:2, allowedInArgument:!0}, handler:(_ref, args) => {
        let {parser, funcName} = _ref;
        _ref = args[0];
        args = args[1];
        let hasBarLine, leftDelim = null, rightDelim = null, size = "auto";
        switch(funcName) {
          case "\\dfrac":
          case "\\frac":
          case "\\tfrac":
            hasBarLine = !0;
            break;
          case "\\\\atopfrac":
            hasBarLine = !1;
            break;
          case "\\dbinom":
          case "\\binom":
          case "\\tbinom":
            hasBarLine = !1;
            leftDelim = "(";
            rightDelim = ")";
            break;
          case "\\\\bracefrac":
            hasBarLine = !1;
            leftDelim = "\\{";
            rightDelim = "\\}";
            break;
          case "\\\\brackfrac":
            hasBarLine = !1;
            leftDelim = "[";
            rightDelim = "]";
            break;
          default:
            throw Error("Unrecognized genfrac command");
        }
        switch(funcName) {
          case "\\dfrac":
          case "\\dbinom":
            size = "display";
            break;
          case "\\tfrac":
          case "\\tbinom":
            size = "text";
        }
        return {type:"genfrac", mode:parser.mode, continued:!1, numer:_ref, denom:args, hasBarLine, leftDelim, rightDelim, size, barSize:null};
      }, htmlBuilder:genfrac_htmlBuilder, mathmlBuilder:genfrac_mathmlBuilder});
      defineFunction({type:"genfrac", names:["\\cfrac"], props:{numArgs:2}, handler:(_ref2, args) => {
        ({parser:_ref2} = _ref2);
        return {type:"genfrac", mode:_ref2.mode, continued:!0, numer:args[0], denom:args[1], hasBarLine:!0, leftDelim:null, rightDelim:null, size:"display", barSize:null};
      }});
      defineFunction({type:"infix", names:["\\over", "\\choose", "\\atop", "\\brace", "\\brack"], props:{numArgs:0, infix:!0}, handler(_ref3) {
        let {parser, funcName, token} = _ref3;
        switch(funcName) {
          case "\\over":
            _ref3 = "\\frac";
            break;
          case "\\choose":
            _ref3 = "\\binom";
            break;
          case "\\atop":
            _ref3 = "\\\\atopfrac";
            break;
          case "\\brace":
            _ref3 = "\\\\bracefrac";
            break;
          case "\\brack":
            _ref3 = "\\\\brackfrac";
            break;
          default:
            throw Error("Unrecognized infix genfrac command");
        }
        return {type:"infix", mode:parser.mode, replaceWith:_ref3, token};
      }});
      const stylArray = ["display", "text", "script", "scriptscript"], delimFromValue = function(delimString) {
        let delim = null;
        0 < delimString.length && (delim = delimString, delim = "." === delim ? null : delim);
        return delim;
      };
      defineFunction({type:"genfrac", names:["\\genfrac"], props:{numArgs:6, allowedInArgument:!0, argTypes:"math math size text math math".split(" ")}, handler(_ref4, args) {
        ({parser:_ref4} = _ref4);
        const numer = args[4], denom = args[5];
        var leftNode = normalizeArgument(args[0]);
        leftNode = "atom" === leftNode.type && "open" === leftNode.family ? delimFromValue(leftNode.text) : null;
        var rightNode = normalizeArgument(args[1]);
        rightNode = "atom" === rightNode.type && "close" === rightNode.family ? delimFromValue(rightNode.text) : null;
        var barNode = assertNodeType(args[2], "size");
        let barSize = null;
        barNode.isBlank ? barNode = !0 : (barSize = barNode.value, barNode = 0 < barSize.number);
        let size = "auto";
        args = args[3];
        "ordgroup" === args.type ? 0 < args.body.length && (args = assertNodeType(args.body[0], "textord"), size = stylArray[Number(args.text)]) : (args = assertNodeType(args, "textord"), size = stylArray[Number(args.text)]);
        return {type:"genfrac", mode:_ref4.mode, numer, denom, continued:!1, hasBarLine:barNode, barSize, leftDelim:leftNode, rightDelim:rightNode, size};
      }, htmlBuilder:genfrac_htmlBuilder, mathmlBuilder:genfrac_mathmlBuilder});
      defineFunction({type:"infix", names:["\\above"], props:{numArgs:1, argTypes:["size"], infix:!0}, handler(_ref5, args) {
        let {parser, token} = _ref5;
        return {type:"infix", mode:parser.mode, replaceWith:"\\\\abovefrac", size:assertNodeType(args[0], "size").value, token};
      }});
      defineFunction({type:"genfrac", names:["\\\\abovefrac"], props:{numArgs:3, argTypes:["math", "size", "math"]}, handler:(_ref6, args) => {
        ({parser:_ref6} = _ref6);
        const numer = args[0];
        var value = assertNodeType(args[1], "infix").size;
        if (!value) {
          throw Error("Expected non-null, but got " + String(value));
        }
        return {type:"genfrac", mode:_ref6.mode, numer, denom:args[2], continued:!1, hasBarLine:0 < value.number, barSize:value, leftDelim:null, rightDelim:null, size:"auto"};
      }, htmlBuilder:genfrac_htmlBuilder, mathmlBuilder:genfrac_mathmlBuilder});
      const horizBrace_htmlBuilder = (grp, options) => {
        var style = options.style;
        let supSubGroup;
        "supsub" === grp.type ? (supSubGroup = grp.sup ? buildGroup(grp.sup, options.havingStyle(style.sup()), options) : buildGroup(grp.sub, options.havingStyle(style.sub()), options), grp = assertNodeType(grp.base, "horizBrace")) : grp = assertNodeType(grp, "horizBrace");
        style = buildGroup(grp.base, options.havingBaseStyle(JSCompiler_object_inline_DISPLAY_2534));
        const braceBody = stretchy.svgSpan(grp, options);
        grp.isOver ? (style = buildCommon.makeVList({positionType:"firstBaseline", children:[{type:"elem", elem:style}, {type:"kern", size:0.1}, {type:"elem", elem:braceBody}]}, options), style.children[0].children[0].children[1].classes.push("svg-align")) : (style = buildCommon.makeVList({positionType:"bottom", positionData:style.depth + 0.1 + braceBody.height, children:[{type:"elem", elem:braceBody}, {type:"kern", size:0.1}, {type:"elem", elem:style}]}, options), style.children[0].children[0].children[0].classes.push("svg-align"));
        supSubGroup && (style = buildCommon.makeSpan(["mord", grp.isOver ? "mover" : "munder"], [style], options), style = grp.isOver ? buildCommon.makeVList({positionType:"firstBaseline", children:[{type:"elem", elem:style}, {type:"kern", size:0.2}, {type:"elem", elem:supSubGroup}]}, options) : buildCommon.makeVList({positionType:"bottom", positionData:style.depth + 0.2 + supSubGroup.height + supSubGroup.depth, children:[{type:"elem", elem:supSubGroup}, {type:"kern", size:0.2}, {type:"elem", elem:style}]}, 
        options));
        return buildCommon.makeSpan(["mord", grp.isOver ? "mover" : "munder"], [style], options);
      };
      defineFunction({type:"horizBrace", names:["\\overbrace", "\\underbrace"], props:{numArgs:1}, handler(_ref, args) {
        let {parser, funcName} = _ref;
        return {type:"horizBrace", mode:parser.mode, label:funcName, isOver:/^\\over/.test(funcName), base:args[0]};
      }, htmlBuilder:horizBrace_htmlBuilder, mathmlBuilder:(group, options) => {
        const accentNode = stretchy.mathMLnode(group.label);
        return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
      }});
      defineFunction({type:"href", names:["\\href"], props:{numArgs:2, argTypes:["url", "original"], allowedInText:!0}, handler:(_ref, args) => {
        ({parser:_ref} = _ref);
        const body = args[1];
        args = assertNodeType(args[0], "url").url;
        return _ref.settings.isTrusted({command:"\\href", url:args}) ? {type:"href", mode:_ref.mode, href:args, body:ordargument(body)} : _ref.formatUnsupportedCmd("\\href");
      }, htmlBuilder:(group, options) => {
        const elements = buildExpression(group.body, options, !1);
        return buildCommon.makeAnchor(group.href, [], elements, options);
      }, mathmlBuilder:(group, options) => {
        options = makeRow(buildMathML_buildExpression(group.body, options, void 0));
        options instanceof MathNode || (options = new MathNode("mrow", [options]));
        options.setAttribute("href", group.href);
        return options;
      }});
      defineFunction({type:"href", names:["\\url"], props:{numArgs:1, argTypes:["url"], allowedInText:!0}, handler:(_ref2, args) => {
        ({parser:_ref2} = _ref2);
        args = assertNodeType(args[0], "url").url;
        if (!_ref2.settings.isTrusted({command:"\\url", url:args})) {
          return _ref2.formatUnsupportedCmd("\\url");
        }
        const chars = [];
        for (let i = 0; i < args.length; i++) {
          let c = args[i];
          "~" === c && (c = "\\textasciitilde");
          chars.push({type:"textord", mode:"text", text:c});
        }
        return {type:"href", mode:_ref2.mode, href:args, body:ordargument({type:"text", mode:_ref2.mode, font:"\\texttt", body:chars})};
      }});
      defineFunction({type:"hbox", names:["\\hbox"], props:{numArgs:1, argTypes:["text"], allowedInText:!0, primitive:!0}, handler(_ref, args) {
        ({parser:_ref} = _ref);
        return {type:"hbox", mode:_ref.mode, body:ordargument(args[0])};
      }, htmlBuilder(group, options) {
        group = buildExpression(group.body, options, !1);
        return buildCommon.makeFragment(group);
      }, mathmlBuilder(group, options) {
        return new mathMLTree.MathNode("mrow", buildMathML_buildExpression(group.body, options));
      }});
      defineFunction({type:"html", names:["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"], props:{numArgs:2, argTypes:["raw", "original"], allowedInText:!0}, handler:(_ref, args) => {
        let {parser, funcName} = _ref;
        var value = assertNodeType(args[0], "raw").string;
        args = args[1];
        parser.settings.strict && parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
        _ref = {};
        switch(funcName) {
          case "\\htmlClass":
            _ref.class = value;
            value = {command:"\\htmlClass", class:value};
            break;
          case "\\htmlId":
            _ref.id = value;
            value = {command:"\\htmlId", id:value};
            break;
          case "\\htmlStyle":
            _ref.style = value;
            value = {command:"\\htmlStyle", style:value};
            break;
          case "\\htmlData":
            value = value.split(",");
            for (let i = 0; i < value.length; i++) {
              const keyVal = value[i].split("\x3d");
              if (2 !== keyVal.length) {
                throw new src_ParseError("Error parsing key-value for \\htmlData");
              }
              _ref["data-" + keyVal[0].trim()] = keyVal[1].trim();
            }
            value = {command:"\\htmlData", attributes:_ref};
            break;
          default:
            throw Error("Unrecognized html command");
        }
        return parser.settings.isTrusted(value) ? {type:"html", mode:parser.mode, attributes:_ref, body:ordargument(args)} : parser.formatUnsupportedCmd(funcName);
      }, htmlBuilder:(group, options) => {
        const elements = buildExpression(group.body, options, !1), classes = ["enclosing"];
        group.attributes.class && classes.push(...group.attributes.class.trim().split(/\s+/));
        options = buildCommon.makeSpan(classes, elements, options);
        for (const attr in group.attributes) {
          "class" !== attr && group.attributes.hasOwnProperty(attr) && options.setAttribute(attr, group.attributes[attr]);
        }
        return options;
      }, mathmlBuilder:(group, options) => makeRow(buildMathML_buildExpression(group.body, options, void 0))});
      defineFunction({type:"htmlmathml", names:["\\html@mathml"], props:{numArgs:2, allowedInText:!0}, handler:(_ref, args) => {
        ({parser:_ref} = _ref);
        return {type:"htmlmathml", mode:_ref.mode, html:ordargument(args[0]), mathml:ordargument(args[1])};
      }, htmlBuilder:(group, options) => {
        group = buildExpression(group.html, options, !1);
        return buildCommon.makeFragment(group);
      }, mathmlBuilder:(group, options) => makeRow(buildMathML_buildExpression(group.mathml, options, void 0))});
      const sizeData = function(str) {
        if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
          return {number:+str, unit:"bp"};
        }
        const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
        if (!match) {
          throw new src_ParseError("Invalid size: '" + str + "' in \\includegraphics");
        }
        str = {number:+(match[1] + match[2]), unit:match[3]};
        if (!validUnit(str)) {
          throw new src_ParseError("Invalid unit: '" + str.unit + "' in \\includegraphics.");
        }
        return str;
      };
      defineFunction({type:"includegraphics", names:["\\includegraphics"], props:{numArgs:1, numOptionalArgs:1, argTypes:["raw", "url"], allowedInText:!1}, handler:(_ref, args, optArgs) => {
        ({parser:_ref} = _ref);
        let width = {number:0, unit:"em"}, height = {number:0.9, unit:"em"}, totalheight = {number:0, unit:"em"}, alt = "";
        if (optArgs[0]) {
          optArgs = assertNodeType(optArgs[0], "raw").string.split(",");
          for (let i = 0; i < optArgs.length; i++) {
            const keyVal = optArgs[i].split("\x3d");
            if (2 === keyVal.length) {
              const str = keyVal[1].trim();
              switch(keyVal[0].trim()) {
                case "alt":
                  alt = str;
                  break;
                case "width":
                  width = sizeData(str);
                  break;
                case "height":
                  height = sizeData(str);
                  break;
                case "totalheight":
                  totalheight = sizeData(str);
                  break;
                default:
                  throw new src_ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
              }
            }
          }
        }
        args = assertNodeType(args[0], "url").url;
        "" === alt && (alt = args.replace(/^.*[\\/]/, ""), alt = alt.substring(0, alt.lastIndexOf(".")));
        return _ref.settings.isTrusted({command:"\\includegraphics", url:args}) ? {type:"includegraphics", mode:_ref.mode, alt, width, height, totalheight, src:args} : _ref.formatUnsupportedCmd("\\includegraphics");
      }, htmlBuilder:(group, options) => {
        const height = calculateSize(group.height, options);
        let depth = 0;
        0 < group.totalheight.number && (depth = calculateSize(group.totalheight, options) - height);
        let width = 0;
        0 < group.width.number && (width = calculateSize(group.width, options));
        options = {height:makeEm(height + depth)};
        0 < width && (options.width = makeEm(width));
        0 < depth && (options.verticalAlign = makeEm(-depth));
        group = new Img(group.src, group.alt, options);
        group.height = height;
        group.depth = depth;
        return group;
      }, mathmlBuilder:(group, options) => {
        const node = new mathMLTree.MathNode("mglyph", []);
        node.setAttribute("alt", group.alt);
        const height = calculateSize(group.height, options);
        let depth = 0;
        0 < group.totalheight.number && (depth = calculateSize(group.totalheight, options) - height, node.setAttribute("valign", makeEm(-depth)));
        node.setAttribute("height", makeEm(height + depth));
        0 < group.width.number && (options = calculateSize(group.width, options), node.setAttribute("width", makeEm(options)));
        node.setAttribute("src", group.src);
        return node;
      }});
      defineFunction({type:"kern", names:["\\kern", "\\mkern", "\\hskip", "\\mskip"], props:{numArgs:1, argTypes:["size"], primitive:!0, allowedInText:!0}, handler(_ref, args) {
        let {parser, funcName} = _ref;
        _ref = assertNodeType(args[0], "size");
        parser.settings.strict && (args = "mu" === _ref.value.unit, "m" === funcName[1] ? (args || parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, not " + (_ref.value.unit + " units")), "math" !== parser.mode && parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode")) : args && parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units"));
        return {type:"kern", mode:parser.mode, dimension:_ref.value};
      }, htmlBuilder(group, options) {
        return buildCommon.makeGlue(group.dimension, options);
      }, mathmlBuilder(group, options) {
        group = calculateSize(group.dimension, options);
        return new mathMLTree.SpaceNode(group);
      }});
      defineFunction({type:"lap", names:["\\mathllap", "\\mathrlap", "\\mathclap"], props:{numArgs:1, allowedInText:!0}, handler:(_ref, args) => {
        let {parser, funcName} = _ref;
        _ref = args[0];
        return {type:"lap", mode:parser.mode, alignment:funcName.slice(5), body:_ref};
      }, htmlBuilder:(group, options) => {
        if ("clap" === group.alignment) {
          var inner = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
          inner = buildCommon.makeSpan(["inner"], [inner], options);
        } else {
          inner = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options)]);
        }
        const fix = buildCommon.makeSpan(["fix"], []);
        group = buildCommon.makeSpan([group.alignment], [inner, fix], options);
        inner = buildCommon.makeSpan(["strut"]);
        inner.style.height = makeEm(group.height + group.depth);
        group.depth && (inner.style.verticalAlign = makeEm(-group.depth));
        group.children.unshift(inner);
        group = buildCommon.makeSpan(["thinbox"], [group], options);
        return buildCommon.makeSpan(["mord", "vbox"], [group], options);
      }, mathmlBuilder:(group, options) => {
        options = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
        "rlap" !== group.alignment && options.setAttribute("lspace", ("llap" === group.alignment ? "-1" : "-0.5") + "width");
        options.setAttribute("width", "0px");
        return options;
      }});
      defineFunction({type:"styling", names:["\\(", "$"], props:{numArgs:0, allowedInText:!0, allowedInMath:!1}, handler(_ref, args) {
        let {funcName, parser} = _ref;
        _ref = parser.mode;
        parser.switchMode("math");
        args = "\\(" === funcName ? "\\)" : "$";
        const body = parser.parseExpression(!1, args);
        parser.expect(args);
        parser.switchMode(_ref);
        return {type:"styling", mode:parser.mode, style:"text", body};
      }});
      defineFunction({type:"text", names:["\\)", "\\]"], props:{numArgs:0, allowedInText:!0, allowedInMath:!1}, handler(context, args) {
        throw new src_ParseError("Mismatched " + context.funcName);
      }});
      const chooseMathStyle = (group, options) => {
        switch(options.style.size) {
          case JSCompiler_object_inline_DISPLAY_2534.size:
            return group.display;
          case JSCompiler_object_inline_TEXT_2535.size:
            return group.text;
          case JSCompiler_object_inline_SCRIPT_2536.size:
            return group.script;
          case JSCompiler_object_inline_SCRIPTSCRIPT_2537.size:
            return group.scriptscript;
          default:
            return group.text;
        }
      };
      defineFunction({type:"mathchoice", names:["\\mathchoice"], props:{numArgs:4, primitive:!0}, handler:(_ref, args) => {
        ({parser:_ref} = _ref);
        return {type:"mathchoice", mode:_ref.mode, display:ordargument(args[0]), text:ordargument(args[1]), script:ordargument(args[2]), scriptscript:ordargument(args[3])};
      }, htmlBuilder:(group, options) => {
        group = chooseMathStyle(group, options);
        options = buildExpression(group, options, !1);
        return buildCommon.makeFragment(options);
      }, mathmlBuilder:(group, options) => {
        group = chooseMathStyle(group, options);
        return makeRow(buildMathML_buildExpression(group, options, void 0));
      }});
      const assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {
        base = buildCommon.makeSpan([], [base]);
        var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
        if (supGroup) {
          var sup = buildGroup(supGroup, options.havingStyle(style.sup()), options);
          sup = {elem:sup, kern:Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - sup.depth)};
        }
        if (subGroup) {
          var sub = buildGroup(subGroup, options.havingStyle(style.sub()), options);
          sub = {elem:sub, kern:Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - sub.height)};
        }
        if (sup && sub) {
          baseShift = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift, base = buildCommon.makeVList({positionType:"bottom", positionData:baseShift, children:[{type:"kern", size:options.fontMetrics().bigOpSpacing5}, {type:"elem", elem:sub.elem, marginLeft:makeEm(-slant)}, {type:"kern", size:sub.kern}, {type:"elem", elem:base}, {type:"kern", size:sup.kern}, {type:"elem", elem:sup.elem, marginLeft:makeEm(slant)}, {type:"kern", size:options.fontMetrics().bigOpSpacing5}]}, 
          options);
        } else if (sub) {
          base = buildCommon.makeVList({positionType:"top", positionData:base.height - baseShift, children:[{type:"kern", size:options.fontMetrics().bigOpSpacing5}, {type:"elem", elem:sub.elem, marginLeft:makeEm(-slant)}, {type:"kern", size:sub.kern}, {type:"elem", elem:base}]}, options);
        } else if (sup) {
          base = buildCommon.makeVList({positionType:"bottom", positionData:base.depth + baseShift, children:[{type:"elem", elem:base}, {type:"kern", size:sup.kern}, {type:"elem", elem:sup.elem, marginLeft:makeEm(slant)}, {type:"kern", size:options.fontMetrics().bigOpSpacing5}]}, options);
        } else {
          return base;
        }
        base = [base];
        sub && 0 !== slant && !subIsSingleCharacter && (subIsSingleCharacter = buildCommon.makeSpan(["mspace"], [], options), subIsSingleCharacter.style.marginRight = makeEm(slant), base.unshift(subIsSingleCharacter));
        return buildCommon.makeSpan(["mop", "op-limits"], base, options);
      }, noSuccessor = ["\\smallint"], op_htmlBuilder = (grp, options) => {
        let supGroup, subGroup, hasLimits = !1;
        "supsub" === grp.type ? (supGroup = grp.sup, subGroup = grp.sub, grp = assertNodeType(grp.base, "op"), hasLimits = !0) : grp = assertNodeType(grp, "op");
        const style = options.style;
        var large = !1;
        style.size === JSCompiler_object_inline_DISPLAY_2534.size && grp.symbol && !utils.contains(noSuccessor, grp.name) && (large = !0);
        if (grp.symbol) {
          var base = large ? "Size2-Regular" : "Size1-Regular";
          var stash = "";
          if ("\\oiint" === grp.name || "\\oiiint" === grp.name) {
            stash = grp.name.slice(1), grp.name = "oiint" === stash ? "\\iint" : "\\iiint";
          }
          base = buildCommon.makeSymbol(grp.name, base, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
          if (0 < stash.length) {
            const italic = base.italic, oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
            base = buildCommon.makeVList({positionType:"individualShift", children:[{type:"elem", elem:base, shift:0}, {type:"elem", elem:oval, shift:large ? 0.08 : 0}]}, options);
            grp.name = "\\" + stash;
            base.classes.unshift("mop");
            base.italic = italic;
          }
        } else if (grp.body) {
          base = buildExpression(grp.body, options, !0), 1 === base.length && base[0] instanceof SymbolNode ? (base = base[0], base.classes[0] = "mop") : base = buildCommon.makeSpan(["mop"], base, options);
        } else {
          base = [];
          for (large = 1; large < grp.name.length; large++) {
            base.push(buildCommon.mathsym(grp.name[large], grp.mode, options));
          }
          base = buildCommon.makeSpan(["mop"], base, options);
        }
        stash = large = 0;
        (base instanceof SymbolNode || "\\oiint" === grp.name || "\\oiiint" === grp.name) && !grp.suppressBaseShift && (large = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight, stash = base.italic);
        if (hasLimits) {
          return assembleSupSub(base, supGroup, subGroup, options, style, stash, large);
        }
        large && (base.style.position = "relative", base.style.top = makeEm(large));
        return base;
      }, op_mathmlBuilder = (group, options) => {
        if (group.symbol) {
          options = new MathNode("mo", [makeText(group.name, group.mode)]), utils.contains(noSuccessor, group.name) && options.setAttribute("largeop", "false");
        } else if (group.body) {
          options = new MathNode("mo", buildMathML_buildExpression(group.body, options));
        } else {
          options = new MathNode("mi", [new TextNode(group.name.slice(1))]);
          const operator = new MathNode("mo", [makeText("⁡", "text")]);
          options = group.parentIsSupSub ? new MathNode("mrow", [options, operator]) : newDocumentFragment([options, operator]);
        }
        return options;
      }, singleCharBigOps = {"∏":"\\prod", "∐":"\\coprod", "∑":"\\sum", "⋀":"\\bigwedge", "⋁":"\\bigvee", "⋂":"\\bigcap", "⋃":"\\bigcup", "⨀":"\\bigodot", "⨁":"\\bigoplus", "⨂":"\\bigotimes", "⨄":"\\biguplus", "⨆":"\\bigsqcup"};
      defineFunction({type:"op", names:"\\coprod \\bigvee \\bigwedge \\biguplus \\bigcap \\bigcup \\intop \\prod \\sum \\bigotimes \\bigoplus \\bigodot \\bigsqcup \\smallint ∏ ∐ ∑ ⋀ ⋁ ⋂ ⋃ ⨀ ⨁ ⨂ ⨄ ⨆".split(" "), props:{numArgs:0}, handler:(_ref, args) => {
        let {parser, funcName} = _ref;
        _ref = funcName;
        1 === _ref.length && (_ref = singleCharBigOps[_ref]);
        return {type:"op", mode:parser.mode, limits:!0, parentIsSupSub:!1, symbol:!0, name:_ref};
      }, htmlBuilder:op_htmlBuilder, mathmlBuilder:op_mathmlBuilder});
      defineFunction({type:"op", names:["\\mathop"], props:{numArgs:1, primitive:!0}, handler:(_ref2, args) => {
        ({parser:_ref2} = _ref2);
        return {type:"op", mode:_ref2.mode, limits:!1, parentIsSupSub:!1, symbol:!1, body:ordargument(args[0])};
      }, htmlBuilder:op_htmlBuilder, mathmlBuilder:op_mathmlBuilder});
      const singleCharIntegrals = {"∫":"\\int", "∬":"\\iint", "∭":"\\iiint", "∮":"\\oint", "∯":"\\oiint", "∰":"\\oiiint"};
      defineFunction({type:"op", names:"\\arcsin \\arccos \\arctan \\arctg \\arcctg \\arg \\ch \\cos \\cosec \\cosh \\cot \\cotg \\coth \\csc \\ctg \\cth \\deg \\dim \\exp \\hom \\ker \\lg \\ln \\log \\sec \\sin \\sinh \\sh \\tan \\tanh \\tg \\th".split(" "), props:{numArgs:0}, handler(_ref3) {
        let {parser, funcName} = _ref3;
        return {type:"op", mode:parser.mode, limits:!1, parentIsSupSub:!1, symbol:!1, name:funcName};
      }, htmlBuilder:op_htmlBuilder, mathmlBuilder:op_mathmlBuilder});
      defineFunction({type:"op", names:"\\det \\gcd \\inf \\lim \\max \\min \\Pr \\sup".split(" "), props:{numArgs:0}, handler(_ref4) {
        let {parser, funcName} = _ref4;
        return {type:"op", mode:parser.mode, limits:!0, parentIsSupSub:!1, symbol:!1, name:funcName};
      }, htmlBuilder:op_htmlBuilder, mathmlBuilder:op_mathmlBuilder});
      defineFunction({type:"op", names:"\\int \\iint \\iiint \\oint \\oiint \\oiiint ∫ ∬ ∭ ∮ ∯ ∰".split(" "), props:{numArgs:0}, handler(_ref5) {
        let {parser, funcName} = _ref5;
        _ref5 = funcName;
        1 === _ref5.length && (_ref5 = singleCharIntegrals[_ref5]);
        return {type:"op", mode:parser.mode, limits:!1, parentIsSupSub:!1, symbol:!0, name:_ref5};
      }, htmlBuilder:op_htmlBuilder, mathmlBuilder:op_mathmlBuilder});
      const operatorname_htmlBuilder = (grp, options) => {
        let supGroup, subGroup, hasLimits = !1;
        "supsub" === grp.type ? (supGroup = grp.sup, subGroup = grp.sub, grp = assertNodeType(grp.base, "operatorname"), hasLimits = !0) : grp = assertNodeType(grp, "operatorname");
        if (0 < grp.body.length) {
          grp = grp.body.map(child => {
            const childText = child.text;
            return "string" === typeof childText ? {type:"textord", mode:child.mode, text:childText} : child;
          });
          grp = buildExpression(grp, options.withFont("mathrm"), !0);
          for (let i = 0; i < grp.length; i++) {
            const child = grp[i];
            child instanceof SymbolNode && (child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
          }
          grp = buildCommon.makeSpan(["mop"], grp, options);
        } else {
          grp = buildCommon.makeSpan(["mop"], [], options);
        }
        return hasLimits ? assembleSupSub(grp, supGroup, subGroup, options, options.style, 0, 0) : grp;
      };
      defineFunction({type:"operatorname", names:["\\operatorname@", "\\operatornamewithlimits"], props:{numArgs:1}, handler:(_ref, args) => {
        let {parser, funcName} = _ref;
        return {type:"operatorname", mode:parser.mode, body:ordargument(args[0]), alwaysHandleSupSub:"\\operatornamewithlimits" === funcName, limits:!1, parentIsSupSub:!1};
      }, htmlBuilder:operatorname_htmlBuilder, mathmlBuilder:(group, options) => {
        options = buildMathML_buildExpression(group.body, options.withFont("mathrm"));
        var isAllString = !0;
        for (let i = 0; i < options.length; i++) {
          const node = options[i];
          if (!(node instanceof mathMLTree.SpaceNode)) {
            if (node instanceof mathMLTree.MathNode) {
              switch(node.type) {
                case "mi":
                case "mn":
                case "ms":
                case "mspace":
                case "mtext":
                  break;
                case "mo":
                  const child = node.children[0];
                  1 === node.children.length && child instanceof mathMLTree.TextNode ? child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : isAllString = !1;
                  break;
                default:
                  isAllString = !1;
              }
            } else {
              isAllString = !1;
            }
          }
        }
        isAllString && (options = options.map(node => node.toText()).join(""), options = [new mathMLTree.TextNode(options)]);
        options = new mathMLTree.MathNode("mi", options);
        options.setAttribute("mathvariant", "normal");
        isAllString = new mathMLTree.MathNode("mo", [makeText("⁡", "text")]);
        return group.parentIsSupSub ? new mathMLTree.MathNode("mrow", [options, isAllString]) : mathMLTree.newDocumentFragment([options, isAllString]);
      }});
      _macros["\\operatorname"] = "\\@ifstar\\operatornamewithlimits\\operatorname@";
      defineFunctionBuilders({type:"ordgroup", htmlBuilder(group, options) {
        return group.semisimple ? buildCommon.makeFragment(buildExpression(group.body, options, !1)) : buildCommon.makeSpan(["mord"], buildExpression(group.body, options, !0), options);
      }, mathmlBuilder(group, options) {
        return makeRow(buildMathML_buildExpression(group.body, options, !0));
      }});
      defineFunction({type:"overline", names:["\\overline"], props:{numArgs:1}, handler(_ref, args) {
        ({parser:_ref} = _ref);
        return {type:"overline", mode:_ref.mode, body:args[0]};
      }, htmlBuilder(group, options) {
        group = buildGroup(group.body, options.havingCrampedStyle());
        const line = buildCommon.makeLineSpan("overline-line", options), defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
        group = buildCommon.makeVList({positionType:"firstBaseline", children:[{type:"elem", elem:group}, {type:"kern", size:3 * defaultRuleThickness}, {type:"elem", elem:line}, {type:"kern", size:defaultRuleThickness}]}, options);
        return buildCommon.makeSpan(["mord", "overline"], [group], options);
      }, mathmlBuilder(group, options) {
        const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("‾")]);
        operator.setAttribute("stretchy", "true");
        group = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator]);
        group.setAttribute("accent", "true");
        return group;
      }});
      defineFunction({type:"phantom", names:["\\phantom"], props:{numArgs:1, allowedInText:!0}, handler:(_ref, args) => {
        ({parser:_ref} = _ref);
        return {type:"phantom", mode:_ref.mode, body:ordargument(args[0])};
      }, htmlBuilder:(group, options) => {
        group = buildExpression(group.body, options.withPhantom(), !1);
        return buildCommon.makeFragment(group);
      }, mathmlBuilder:(group, options) => {
        group = buildMathML_buildExpression(group.body, options);
        return new mathMLTree.MathNode("mphantom", group);
      }});
      defineFunction({type:"hphantom", names:["\\hphantom"], props:{numArgs:1, allowedInText:!0}, handler:(_ref2, args) => {
        ({parser:_ref2} = _ref2);
        return {type:"hphantom", mode:_ref2.mode, body:args[0]};
      }, htmlBuilder:(group, options) => {
        group = buildCommon.makeSpan([], [buildGroup(group.body, options.withPhantom())]);
        group.height = 0;
        group.depth = 0;
        if (group.children) {
          for (let i = 0; i < group.children.length; i++) {
            group.children[i].height = 0, group.children[i].depth = 0;
          }
        }
        group = buildCommon.makeVList({positionType:"firstBaseline", children:[{type:"elem", elem:group}]}, options);
        return buildCommon.makeSpan(["mord"], [group], options);
      }, mathmlBuilder:(group, options) => {
        group = buildMathML_buildExpression(ordargument(group.body), options);
        group = new mathMLTree.MathNode("mphantom", group);
        group = new mathMLTree.MathNode("mpadded", [group]);
        group.setAttribute("height", "0px");
        group.setAttribute("depth", "0px");
        return group;
      }});
      defineFunction({type:"vphantom", names:["\\vphantom"], props:{numArgs:1, allowedInText:!0}, handler:(_ref3, args) => {
        ({parser:_ref3} = _ref3);
        return {type:"vphantom", mode:_ref3.mode, body:args[0]};
      }, htmlBuilder:(group, options) => {
        group = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options.withPhantom())]);
        const fix = buildCommon.makeSpan(["fix"], []);
        return buildCommon.makeSpan(["mord", "rlap"], [group, fix], options);
      }, mathmlBuilder:(group, options) => {
        group = buildMathML_buildExpression(ordargument(group.body), options);
        group = new mathMLTree.MathNode("mphantom", group);
        group = new mathMLTree.MathNode("mpadded", [group]);
        group.setAttribute("width", "0px");
        return group;
      }});
      defineFunction({type:"raisebox", names:["\\raisebox"], props:{numArgs:2, argTypes:["size", "hbox"], allowedInText:!0}, handler(_ref, args) {
        ({parser:_ref} = _ref);
        const amount = assertNodeType(args[0], "size").value;
        return {type:"raisebox", mode:_ref.mode, dy:amount, body:args[1]};
      }, htmlBuilder(group, options) {
        const body = buildGroup(group.body, options);
        group = calculateSize(group.dy, options);
        return buildCommon.makeVList({positionType:"shift", positionData:-group, children:[{type:"elem", elem:body}]}, options);
      }, mathmlBuilder(group, options) {
        options = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
        options.setAttribute("voffset", group.dy.number + group.dy.unit);
        return options;
      }});
      defineFunction({type:"internal", names:["\\relax"], props:{numArgs:0, allowedInText:!0}, handler(_ref) {
        ({parser:_ref} = _ref);
        return {type:"internal", mode:_ref.mode};
      }});
      defineFunction({type:"rule", names:["\\rule"], props:{numArgs:2, numOptionalArgs:1, allowedInText:!0, allowedInMath:!0, argTypes:["size", "size", "size"]}, handler(_ref, args, optArgs) {
        ({parser:_ref} = _ref);
        optArgs = optArgs[0];
        const width = assertNodeType(args[0], "size");
        args = assertNodeType(args[1], "size");
        return {type:"rule", mode:_ref.mode, shift:optArgs && assertNodeType(optArgs, "size").value, width:width.value, height:args.value};
      }, htmlBuilder(group, options) {
        const rule = buildCommon.makeSpan(["mord", "rule"], [], options), width = calculateSize(group.width, options), height = calculateSize(group.height, options);
        group = group.shift ? calculateSize(group.shift, options) : 0;
        rule.style.borderRightWidth = makeEm(width);
        rule.style.borderTopWidth = makeEm(height);
        rule.style.bottom = makeEm(group);
        rule.width = width;
        rule.height = height + group;
        rule.depth = -group;
        rule.maxFontSize = 1.125 * height * options.sizeMultiplier;
        return rule;
      }, mathmlBuilder(group, options) {
        var width = calculateSize(group.width, options);
        const height = calculateSize(group.height, options);
        group = group.shift ? calculateSize(group.shift, options) : 0;
        options = options.color && options.getColor() || "black";
        const rule = new mathMLTree.MathNode("mspace");
        rule.setAttribute("mathbackground", options);
        rule.setAttribute("width", makeEm(width));
        rule.setAttribute("height", makeEm(height));
        width = new mathMLTree.MathNode("mpadded", [rule]);
        0 <= group ? width.setAttribute("height", makeEm(group)) : (width.setAttribute("height", makeEm(group)), width.setAttribute("depth", makeEm(-group)));
        width.setAttribute("voffset", makeEm(group));
        return width;
      }});
      const sizeFuncs = "\\tiny \\sixptsize \\scriptsize \\footnotesize \\small \\normalsize \\large \\Large \\LARGE \\huge \\Huge".split(" ");
      defineFunction({type:"sizing", names:sizeFuncs, props:{numArgs:0, allowedInText:!0}, handler:(_ref, args) => {
        let {breakOnTokenText, funcName, parser} = _ref;
        _ref = parser.parseExpression(!1, breakOnTokenText);
        return {type:"sizing", mode:parser.mode, size:sizeFuncs.indexOf(funcName) + 1, body:_ref};
      }, htmlBuilder:(group, options) => {
        const newOptions = options.havingSize(group.size);
        return sizingGroup(group.body, newOptions, options);
      }, mathmlBuilder:(group, options) => {
        options = options.havingSize(group.size);
        group = buildMathML_buildExpression(group.body, options);
        group = new mathMLTree.MathNode("mstyle", group);
        group.setAttribute("mathsize", makeEm(options.sizeMultiplier));
        return group;
      }});
      defineFunction({type:"smash", names:["\\smash"], props:{numArgs:1, numOptionalArgs:1, allowedInText:!0}, handler:(_ref, args, optArgs) => {
        ({parser:_ref} = _ref);
        let smashHeight = !1, smashDepth = !1;
        if (optArgs = optArgs[0] && assertNodeType(optArgs[0], "ordgroup")) {
          let letter;
          for (let i = 0; i < optArgs.body.length; ++i) {
            if (letter = optArgs.body[i].text, "t" === letter) {
              smashHeight = !0;
            } else if ("b" === letter) {
              smashDepth = !0;
            } else {
              smashDepth = smashHeight = !1;
              break;
            }
          }
        } else {
          smashDepth = smashHeight = !0;
        }
        return {type:"smash", mode:_ref.mode, body:args[0], smashHeight, smashDepth};
      }, htmlBuilder:(group, options) => {
        var node = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
        if (!group.smashHeight && !group.smashDepth) {
          return node;
        }
        if (group.smashHeight && (node.height = 0, node.children)) {
          for (let i = 0; i < node.children.length; i++) {
            node.children[i].height = 0;
          }
        }
        if (group.smashDepth && (node.depth = 0, node.children)) {
          for (group = 0; group < node.children.length; group++) {
            node.children[group].depth = 0;
          }
        }
        node = buildCommon.makeVList({positionType:"firstBaseline", children:[{type:"elem", elem:node}]}, options);
        return buildCommon.makeSpan(["mord"], [node], options);
      }, mathmlBuilder:(group, options) => {
        options = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
        group.smashHeight && options.setAttribute("height", "0px");
        group.smashDepth && options.setAttribute("depth", "0px");
        return options;
      }});
      defineFunction({type:"sqrt", names:["\\sqrt"], props:{numArgs:1, numOptionalArgs:1}, handler(_ref, args, optArgs) {
        ({parser:_ref} = _ref);
        return {type:"sqrt", mode:_ref.mode, body:args[0], index:optArgs[0]};
      }, htmlBuilder(group, options) {
        var inner = buildGroup(group.body, options.havingCrampedStyle());
        0 === inner.height && (inner.height = options.fontMetrics().xHeight);
        inner = buildCommon.wrapFragment(inner, options);
        var theta = options.fontMetrics().defaultRuleThickness, phi = theta;
        options.style.id < JSCompiler_object_inline_TEXT_2535.id && (phi = options.fontMetrics().xHeight);
        phi = theta + phi / 4;
        const {span:img, ruleWidth, advanceWidth} = delimiter.sqrtImage(inner.height + inner.depth + phi + theta, options);
        theta = img.height - ruleWidth;
        theta > inner.height + inner.depth + phi && (phi = (phi + theta - inner.height - inner.depth) / 2);
        theta = img.height - inner.height - phi - ruleWidth;
        inner.style.paddingLeft = makeEm(advanceWidth);
        inner = buildCommon.makeVList({positionType:"firstBaseline", children:[{type:"elem", elem:inner, wrapperClasses:["svg-align"]}, {type:"kern", size:-(inner.height + theta)}, {type:"elem", elem:img}, {type:"kern", size:ruleWidth}]}, options);
        return group.index ? (theta = options.havingStyle(JSCompiler_object_inline_SCRIPTSCRIPT_2537), group = buildGroup(group.index, theta, options), group = buildCommon.makeVList({positionType:"shift", positionData:-(0.6 * (inner.height - inner.depth)), children:[{type:"elem", elem:group}]}, options), group = buildCommon.makeSpan(["root"], [group]), buildCommon.makeSpan(["mord", "sqrt"], [group, inner], options)) : buildCommon.makeSpan(["mord", "sqrt"], [inner], options);
      }, mathmlBuilder(group, options) {
        const {body, index} = group;
        return index ? new mathMLTree.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index, options)]) : new mathMLTree.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
      }});
      const styling_styleMap = {display:JSCompiler_object_inline_DISPLAY_2534, text:JSCompiler_object_inline_TEXT_2535, script:JSCompiler_object_inline_SCRIPT_2536, scriptscript:JSCompiler_object_inline_SCRIPTSCRIPT_2537};
      defineFunction({type:"styling", names:["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"], props:{numArgs:0, allowedInText:!0, primitive:!0}, handler(_ref, args) {
        let {breakOnTokenText, funcName, parser} = _ref;
        _ref = parser.parseExpression(!0, breakOnTokenText);
        args = funcName.slice(1, funcName.length - 5);
        return {type:"styling", mode:parser.mode, style:args, body:_ref};
      }, htmlBuilder(group, options) {
        const newOptions = options.havingStyle(styling_styleMap[group.style]).withFont("");
        return sizingGroup(group.body, newOptions, options);
      }, mathmlBuilder(group, options) {
        options = options.havingStyle(styling_styleMap[group.style]);
        options = buildMathML_buildExpression(group.body, options);
        options = new mathMLTree.MathNode("mstyle", options);
        group = {display:["0", "true"], text:["0", "false"], script:["1", "false"], scriptscript:["2", "false"]}[group.style];
        options.setAttribute("scriptlevel", group[0]);
        options.setAttribute("displaystyle", group[1]);
        return options;
      }});
      defineFunctionBuilders({type:"supsub", htmlBuilder(group, options) {
        var JSCompiler_inline_result;
        if (JSCompiler_inline_result = (JSCompiler_inline_result = group.base) ? "op" === JSCompiler_inline_result.type ? JSCompiler_inline_result.limits && (options.style.size === JSCompiler_object_inline_DISPLAY_2534.size || JSCompiler_inline_result.alwaysHandleSupSub) ? op_htmlBuilder : null : "operatorname" === JSCompiler_inline_result.type ? JSCompiler_inline_result.alwaysHandleSupSub && (options.style.size === JSCompiler_object_inline_DISPLAY_2534.size || JSCompiler_inline_result.limits) ? 
        operatorname_htmlBuilder : null : "accent" === JSCompiler_inline_result.type ? utils.isCharacterBox(JSCompiler_inline_result.base) ? htmlBuilder : null : "horizBrace" === JSCompiler_inline_result.type ? !group.sub === JSCompiler_inline_result.isOver ? horizBrace_htmlBuilder : null : null : null) {
          return JSCompiler_inline_result(group, options);
        }
        const {base:valueBase, sup:valueSup, sub:valueSub} = group;
        JSCompiler_inline_result = buildGroup(valueBase, options);
        const metrics = options.fontMetrics();
        let supShift = 0, subShift = 0;
        var isCharacterBox = valueBase && utils.isCharacterBox(valueBase);
        if (valueSup) {
          var newOptions = options.havingStyle(options.style.sup());
          var supm = buildGroup(valueSup, newOptions, options);
          isCharacterBox || (supShift = JSCompiler_inline_result.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier);
        }
        if (valueSub) {
          newOptions = options.havingStyle(options.style.sub());
          var subm = buildGroup(valueSub, newOptions, options);
          isCharacterBox || (subShift = JSCompiler_inline_result.depth + newOptions.fontMetrics().subDrop * newOptions.sizeMultiplier / options.sizeMultiplier);
        }
        let minSupShift;
        minSupShift = options.style === JSCompiler_object_inline_DISPLAY_2534 ? metrics.sup1 : options.style.cramped ? metrics.sup3 : metrics.sup2;
        isCharacterBox = makeEm(0.5 / metrics.ptPerEm / options.sizeMultiplier);
        newOptions = null;
        subm && (group = group.base && "op" === group.base.type && group.base.name && ("\\oiint" === group.base.name || "\\oiiint" === group.base.name), JSCompiler_inline_result instanceof SymbolNode || group) && (newOptions = makeEm(-JSCompiler_inline_result.italic));
        if (supm && subm) {
          supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight), subShift = Math.max(subShift, metrics.sub2), group = 4 * metrics.defaultRuleThickness, supShift - supm.depth - (subm.height - subShift) < group && (subShift = group - (supShift - supm.depth) + subm.height, group = 0.8 * metrics.xHeight - (supShift - supm.depth), 0 < group && (supShift += group, subShift -= group)), supm = buildCommon.makeVList({positionType:"individualShift", children:[{type:"elem", elem:subm, 
          shift:subShift, marginRight:isCharacterBox, marginLeft:newOptions}, {type:"elem", elem:supm, shift:-supShift, marginRight:isCharacterBox}]}, options);
        } else if (subm) {
          subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight), supm = buildCommon.makeVList({positionType:"shift", positionData:subShift, children:[{type:"elem", elem:subm, marginLeft:newOptions, marginRight:isCharacterBox}]}, options);
        } else if (supm) {
          supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight), supm = buildCommon.makeVList({positionType:"shift", positionData:-supShift, children:[{type:"elem", elem:supm, marginRight:isCharacterBox}]}, options);
        } else {
          throw Error("supsub must have either sup or sub.");
        }
        subm = getTypeOfDomTree(JSCompiler_inline_result, "right") || "mord";
        return buildCommon.makeSpan([subm], [JSCompiler_inline_result, buildCommon.makeSpan(["msupsub"], [supm])], options);
      }, mathmlBuilder(group, options) {
        let isBrace = !1, isOver;
        if (group.base && "horizBrace" === group.base.type) {
          var isSup = !!group.sup;
          isSup === group.base.isOver && (isBrace = !0, isOver = group.base.isOver);
        }
        !group.base || "op" !== group.base.type && "operatorname" !== group.base.type || (group.base.parentIsSupSub = !0);
        isSup = [buildMathML_buildGroup(group.base, options)];
        group.sub && isSup.push(buildMathML_buildGroup(group.sub, options));
        group.sup && isSup.push(buildMathML_buildGroup(group.sup, options));
        options = isBrace ? isOver ? "mover" : "munder" : group.sub ? group.sup ? (group = group.base) && "op" === group.type && group.limits && options.style === JSCompiler_object_inline_DISPLAY_2534 ? "munderover" : group && "operatorname" === group.type && group.alwaysHandleSupSub && (options.style === JSCompiler_object_inline_DISPLAY_2534 || group.limits) ? "munderover" : "msubsup" : (group = group.base) && "op" === group.type && group.limits && (options.style === JSCompiler_object_inline_DISPLAY_2534 || 
        group.alwaysHandleSupSub) ? "munder" : group && "operatorname" === group.type && group.alwaysHandleSupSub && (group.limits || options.style === JSCompiler_object_inline_DISPLAY_2534) ? "munder" : "msub" : (group = group.base) && "op" === group.type && group.limits && (options.style === JSCompiler_object_inline_DISPLAY_2534 || group.alwaysHandleSupSub) ? "mover" : group && "operatorname" === group.type && group.alwaysHandleSupSub && (group.limits || options.style === JSCompiler_object_inline_DISPLAY_2534) ? 
        "mover" : "msup";
        return new mathMLTree.MathNode(options, isSup);
      }});
      defineFunctionBuilders({type:"atom", htmlBuilder(group, options) {
        return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
      }, mathmlBuilder(group, options) {
        const node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
        "bin" === group.family ? (group = getVariant(group, options), "bold-italic" === group && node.setAttribute("mathvariant", group)) : "punct" === group.family ? node.setAttribute("separator", "true") : ("open" === group.family || "close" === group.family) && node.setAttribute("stretchy", "false");
        return node;
      }});
      const defaultVariant = {mi:"italic", mn:"normal", mtext:"normal"};
      defineFunctionBuilders({type:"mathord", htmlBuilder(group, options) {
        return buildCommon.makeOrd(group, options, "mathord");
      }, mathmlBuilder(group, options) {
        const node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
        group = getVariant(group, options) || "italic";
        group !== defaultVariant[node.type] && node.setAttribute("mathvariant", group);
        return node;
      }});
      defineFunctionBuilders({type:"textord", htmlBuilder(group, options) {
        return buildCommon.makeOrd(group, options, "textord");
      }, mathmlBuilder(group, options) {
        const text = makeText(group.text, group.mode, options);
        options = getVariant(group, options) || "normal";
        group = "text" === group.mode ? new mathMLTree.MathNode("mtext", [text]) : /[0-9]/.test(group.text) ? new mathMLTree.MathNode("mn", [text]) : "\\prime" === group.text ? new mathMLTree.MathNode("mo", [text]) : new mathMLTree.MathNode("mi", [text]);
        options !== defaultVariant[group.type] && group.setAttribute("mathvariant", options);
        return group;
      }});
      const cssSpace = {"\\nobreak":"nobreak", "\\allowbreak":"allowbreak"}, regularSpace = {" ":{}, "\\ ":{}, "~":{className:"nobreak"}, "\\space":{}, "\\nobreakspace":{className:"nobreak"}};
      defineFunctionBuilders({type:"spacing", htmlBuilder(group, options) {
        if (regularSpace.hasOwnProperty(group.text)) {
          const className = regularSpace[group.text].className || "";
          return "text" === group.mode ? (group = buildCommon.makeOrd(group, options, "textord"), group.classes.push(className), group) : buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
        }
        if (cssSpace.hasOwnProperty(group.text)) {
          return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
        }
        throw new src_ParseError('Unknown type of space "' + group.text + '"');
      }, mathmlBuilder(group, options) {
        if (regularSpace.hasOwnProperty(group.text)) {
          group = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode(" ")]);
        } else {
          if (cssSpace.hasOwnProperty(group.text)) {
            return new mathMLTree.MathNode("mspace");
          }
          throw new src_ParseError('Unknown type of space "' + group.text + '"');
        }
        return group;
      }});
      const pad = () => {
        const padNode = new mathMLTree.MathNode("mtd", []);
        padNode.setAttribute("width", "50%");
        return padNode;
      };
      defineFunctionBuilders({type:"tag", mathmlBuilder(group, options) {
        group = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [makeRow(buildMathML_buildExpression(group.body, options, void 0))]), pad(), new mathMLTree.MathNode("mtd", [makeRow(buildMathML_buildExpression(group.tag, options, void 0))])])]);
        group.setAttribute("width", "100%");
        return group;
      }});
      const textFontFamilies = {"\\text":void 0, "\\textrm":"textrm", "\\textsf":"textsf", "\\texttt":"texttt", "\\textnormal":"textrm"}, textFontWeights = {"\\textbf":"textbf", "\\textmd":"textmd"}, textFontShapes = {"\\textit":"textit", "\\textup":"textup"}, optionsWithFont = (group, options) => {
        if (group = group.font) {
          if (textFontFamilies[group]) {
            return options.withTextFontFamily(textFontFamilies[group]);
          }
          if (textFontWeights[group]) {
            return options.withTextFontWeight(textFontWeights[group]);
          }
          if ("\\emph" === group) {
            return "textit" === options.fontShape ? options.withTextFontShape("textup") : options.withTextFontShape("textit");
          }
        } else {
          return options;
        }
        return options.withTextFontShape(textFontShapes[group]);
      };
      defineFunction({type:"text", names:"\\text \\textrm \\textsf \\texttt \\textnormal \\textbf \\textmd \\textit \\textup \\emph".split(" "), props:{numArgs:1, argTypes:["text"], allowedInArgument:!0, allowedInText:!0}, handler(_ref, args) {
        let {parser, funcName} = _ref;
        return {type:"text", mode:parser.mode, body:ordargument(args[0]), font:funcName};
      }, htmlBuilder(group, options) {
        options = optionsWithFont(group, options);
        group = buildExpression(group.body, options, !0);
        return buildCommon.makeSpan(["mord", "text"], group, options);
      }, mathmlBuilder(group, options) {
        options = optionsWithFont(group, options);
        return makeRow(buildMathML_buildExpression(group.body, options, void 0));
      }});
      defineFunction({type:"underline", names:["\\underline"], props:{numArgs:1, allowedInText:!0}, handler(_ref, args) {
        ({parser:_ref} = _ref);
        return {type:"underline", mode:_ref.mode, body:args[0]};
      }, htmlBuilder(group, options) {
        group = buildGroup(group.body, options);
        const line = buildCommon.makeLineSpan("underline-line", options), defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
        group = buildCommon.makeVList({positionType:"top", positionData:group.height, children:[{type:"kern", size:defaultRuleThickness}, {type:"elem", elem:line}, {type:"kern", size:3 * defaultRuleThickness}, {type:"elem", elem:group}]}, options);
        return buildCommon.makeSpan(["mord", "underline"], [group], options);
      }, mathmlBuilder(group, options) {
        const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("‾")]);
        operator.setAttribute("stretchy", "true");
        group = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator]);
        group.setAttribute("accentunder", "true");
        return group;
      }});
      defineFunction({type:"vcenter", names:["\\vcenter"], props:{numArgs:1, argTypes:["original"], allowedInText:!1}, handler(_ref, args) {
        ({parser:_ref} = _ref);
        return {type:"vcenter", mode:_ref.mode, body:args[0]};
      }, htmlBuilder(group, options) {
        group = buildGroup(group.body, options);
        const axisHeight = options.fontMetrics().axisHeight;
        return buildCommon.makeVList({positionType:"shift", positionData:0.5 * (group.height - axisHeight - (group.depth + axisHeight)), children:[{type:"elem", elem:group}]}, options);
      }, mathmlBuilder(group, options) {
        return new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)], ["vcenter"]);
      }});
      defineFunction({type:"verb", names:["\\verb"], props:{numArgs:0, allowedInText:!0}, handler(context, args, optArgs) {
        throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
      }, htmlBuilder(group, options) {
        const text = group.body.replace(/ /g, group.star ? "␣" : " "), body = [], newOptions = options.havingStyle(options.style.text());
        for (let i = 0; i < text.length; i++) {
          let c = text[i];
          "~" === c && (c = "\\textasciitilde");
          body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
        }
        return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
      }, mathmlBuilder(group, options) {
        group = new mathMLTree.TextNode(group.body.replace(/ /g, group.star ? "␣" : " "));
        group = new mathMLTree.MathNode("mtext", [group]);
        group.setAttribute("mathvariant", "monospace");
        return group;
      }});
      var src_functions = _functions;
      const combiningDiacriticalMarksEndRegex = RegExp("[̀-ͯ]+$");
      class Lexer {
        constructor(input, settings) {
          this.catcodes = this.tokenRegex = this.settings = this.input = void 0;
          this.input = input;
          this.settings = settings;
          this.tokenRegex = RegExp("([ \r\n\t]+)|\\\\(\n|[ \r\t]+\n?)[ \r\t]*|([!-\\[\\]-‧‪-퟿豈-￿][̀-ͯ]*|[\ud800-\udbff][\udc00-\udfff][̀-ͯ]*|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5|(\\\\[a-zA-Z@]+)[ \r\n\t]*|\\\\[^\ud800-\udfff])", "g");
          this.catcodes = {"%":14, "~":13};
        }
        setCatcode(char, code) {
          this.catcodes[char] = code;
        }
        lex() {
          const input = this.input;
          var pos = this.tokenRegex.lastIndex;
          if (pos === input.length) {
            return new Token("EOF", new SourceLocation(this, pos, pos));
          }
          var match = this.tokenRegex.exec(input);
          if (null === match || match.index !== pos) {
            throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
          }
          match = match[6] || match[3] || (match[2] ? "\\ " : " ");
          return 14 === this.catcodes[match] ? (pos = input.indexOf("\n", this.tokenRegex.lastIndex), -1 === pos ? (this.tokenRegex.lastIndex = input.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = pos + 1, this.lex()) : new Token(match, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
        }
      }
      class Namespace {
        constructor(builtins, globalMacros) {
          void 0 === builtins && (builtins = {});
          void 0 === globalMacros && (globalMacros = {});
          this.undefStack = this.builtins = this.current = void 0;
          this.current = globalMacros;
          this.builtins = builtins;
          this.undefStack = [];
        }
        beginGroup() {
          this.undefStack.push({});
        }
        endGroup() {
          if (0 === this.undefStack.length) {
            throw new src_ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
          }
          const undefs = this.undefStack.pop();
          for (const undef in undefs) {
            undefs.hasOwnProperty(undef) && (null == undefs[undef] ? delete this.current[undef] : this.current[undef] = undefs[undef]);
          }
        }
        endGroups() {
          for (; 0 < this.undefStack.length;) {
            this.endGroup();
          }
        }
        has(name) {
          return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
        }
        get(name) {
          return this.current.hasOwnProperty(name) ? this.current[name] : this.builtins[name];
        }
        set(name, value, global) {
          void 0 === global && (global = !1);
          if (global) {
            for (global = 0; global < this.undefStack.length; global++) {
              delete this.undefStack[global][name];
            }
            0 < this.undefStack.length && (this.undefStack[this.undefStack.length - 1][name] = value);
          } else {
            (global = this.undefStack[this.undefStack.length - 1]) && !global.hasOwnProperty(name) && (global[name] = this.current[name]);
          }
          null == value ? delete this.current[name] : this.current[name] = value;
        }
      }
      var src_macros = _macros;
      defineMacro("\\noexpand", function(context) {
        const t = context.popToken();
        context.isExpandable(t.text) && (t.noexpand = !0, t.treatAsRelax = !0);
        return {tokens:[t], numArgs:0};
      });
      defineMacro("\\expandafter", function(context) {
        const t = context.popToken();
        context.expandOnce(!0);
        return {tokens:[t], numArgs:0};
      });
      defineMacro("\\@firstoftwo", function(context) {
        return {tokens:context.consumeArgs(2)[0], numArgs:0};
      });
      defineMacro("\\@secondoftwo", function(context) {
        return {tokens:context.consumeArgs(2)[1], numArgs:0};
      });
      defineMacro("\\@ifnextchar", function(context) {
        const args = context.consumeArgs(3);
        context.consumeSpaces();
        context = context.future();
        return 1 === args[0].length && args[0][0].text === context.text ? {tokens:args[1], numArgs:0} : {tokens:args[2], numArgs:0};
      });
      _macros["\\@ifstar"] = "\\@ifnextchar *{\\@firstoftwo{#1}}";
      defineMacro("\\TextOrMath", function(context) {
        const args = context.consumeArgs(2);
        return "text" === context.mode ? {tokens:args[0], numArgs:0} : {tokens:args[1], numArgs:0};
      });
      const digitToNumber = {0:0, 1:1, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:9, a:10, A:10, b:11, B:11, c:12, C:12, d:13, D:13, e:14, E:14, f:15, F:15};
      defineMacro("\\char", function(context) {
        let token = context.popToken(), base, number = "";
        if ("'" === token.text) {
          base = 8, token = context.popToken();
        } else if ('"' === token.text) {
          base = 16, token = context.popToken();
        } else if ("`" === token.text) {
          if (token = context.popToken(), "\\" === token.text[0]) {
            number = token.text.charCodeAt(1);
          } else {
            if ("EOF" === token.text) {
              throw new src_ParseError("\\char` missing argument");
            }
            number = token.text.charCodeAt(0);
          }
        } else {
          base = 10;
        }
        if (base) {
          number = digitToNumber[token.text];
          if (null == number || number >= base) {
            throw new src_ParseError("Invalid base-" + base + " digit " + token.text);
          }
          let digit;
          for (; null != (digit = digitToNumber[context.future().text]) && digit < base;) {
            number *= base, number += digit, context.popToken();
          }
        }
        return "\\@char{" + number + "}";
      });
      const newcommand = (context, existsOK, nonexistsOK, skipIfExists) => {
        var arg = context.consumeArg().tokens;
        if (1 !== arg.length) {
          throw new src_ParseError("\\newcommand's first argument must be a macro name");
        }
        const name = arg[0].text, exists = context.isDefined(name);
        if (exists && !existsOK) {
          throw new src_ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
        }
        if (!exists && !nonexistsOK) {
          throw new src_ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
        }
        existsOK = 0;
        arg = context.consumeArg().tokens;
        if (1 === arg.length && "[" === arg[0].text) {
          arg = "";
          for (existsOK = context.expandNextToken(); "]" !== existsOK.text && "EOF" !== existsOK.text;) {
            arg += existsOK.text, existsOK = context.expandNextToken();
          }
          if (!arg.match(/^\s*[0-9]+\s*$/)) {
            throw new src_ParseError("Invalid number of arguments: " + arg);
          }
          existsOK = parseInt(arg);
          arg = context.consumeArg().tokens;
        }
        exists && skipIfExists || context.macros.set(name, {tokens:arg, numArgs:existsOK});
        return "";
      };
      defineMacro("\\newcommand", context => newcommand(context, !1, !0, !1));
      defineMacro("\\renewcommand", context => newcommand(context, !0, !1, !1));
      defineMacro("\\providecommand", context => newcommand(context, !0, !0, !0));
      defineMacro("\\message", context => {
        context = context.consumeArgs(1)[0];
        console.log(context.reverse().map(token => token.text).join(""));
        return "";
      });
      defineMacro("\\errmessage", context => {
        context = context.consumeArgs(1)[0];
        console.error(context.reverse().map(token => token.text).join(""));
        return "";
      });
      defineMacro("\\show", context => {
        const tok = context.popToken(), name = tok.text;
        console.log(tok, context.macros.get(name), src_functions[name], src_symbols.math[name], src_symbols.text[name]);
        return "";
      });
      _macros["\\bgroup"] = "{";
      _macros["\\egroup"] = "}";
      _macros["~"] = "\\nobreakspace";
      _macros["\\lq"] = "`";
      _macros["\\rq"] = "'";
      _macros["\\aa"] = "\\r a";
      _macros["\\AA"] = "\\r A";
      _macros["\\textcopyright"] = "\\html@mathml{\\textcircled{c}}{\\char`©}";
      _macros["\\copyright"] = "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}";
      _macros["\\textregistered"] = "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}";
      _macros["ℬ"] = "\\mathscr{B}";
      _macros["ℰ"] = "\\mathscr{E}";
      _macros["ℱ"] = "\\mathscr{F}";
      _macros["ℋ"] = "\\mathscr{H}";
      _macros["ℐ"] = "\\mathscr{I}";
      _macros["ℒ"] = "\\mathscr{L}";
      _macros["ℳ"] = "\\mathscr{M}";
      _macros["ℛ"] = "\\mathscr{R}";
      _macros["ℭ"] = "\\mathfrak{C}";
      _macros["ℌ"] = "\\mathfrak{H}";
      _macros["ℨ"] = "\\mathfrak{Z}";
      _macros["\\Bbbk"] = "\\Bbb{k}";
      _macros["·"] = "\\cdotp";
      _macros["\\llap"] = "\\mathllap{\\textrm{#1}}";
      _macros["\\rlap"] = "\\mathrlap{\\textrm{#1}}";
      _macros["\\clap"] = "\\mathclap{\\textrm{#1}}";
      _macros["\\mathstrut"] = "\\vphantom{(}";
      _macros["\\underbar"] = "\\underline{\\text{#1}}";
      _macros["\\not"] = '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}';
      _macros["\\neq"] = "\\html@mathml{\\mathrel{\\not\x3d}}{\\mathrel{\\char`≠}}";
      _macros["\\ne"] = "\\neq";
      _macros["≠"] = "\\neq";
      _macros["\\notin"] = "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}";
      _macros["∉"] = "\\notin";
      _macros["≘"] = "\\html@mathml{\\mathrel{\x3d\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}";
      _macros["≙"] = "\\html@mathml{\\stackrel{\\tiny\\wedge}{\x3d}}{\\mathrel{\\char`≘}}";
      _macros["≚"] = "\\html@mathml{\\stackrel{\\tiny\\vee}{\x3d}}{\\mathrel{\\char`≚}}";
      _macros["≛"] = "\\html@mathml{\\stackrel{\\scriptsize\\star}{\x3d}}{\\mathrel{\\char`≛}}";
      _macros["≝"] = "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{\x3d}}{\\mathrel{\\char`≝}}";
      _macros["≞"] = "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{\x3d}}{\\mathrel{\\char`≞}}";
      _macros["≟"] = "\\html@mathml{\\stackrel{\\tiny?}{\x3d}}{\\mathrel{\\char`≟}}";
      _macros["⟂"] = "\\perp";
      _macros["‼"] = "\\mathclose{!\\mkern-0.8mu!}";
      _macros["∌"] = "\\notni";
      _macros["⌜"] = "\\ulcorner";
      _macros["⌝"] = "\\urcorner";
      _macros["⌞"] = "\\llcorner";
      _macros["⌟"] = "\\lrcorner";
      _macros["©"] = "\\copyright";
      _macros["®"] = "\\textregistered";
      _macros["️"] = "\\textregistered";
      _macros["\\ulcorner"] = '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}';
      _macros["\\urcorner"] = '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}';
      _macros["\\llcorner"] = '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}';
      _macros["\\lrcorner"] = '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}';
      _macros["\\vdots"] = "{\\varvdots\\rule{0pt}{15pt}}";
      _macros["⋮"] = "\\vdots";
      _macros["\\varGamma"] = "\\mathit{\\Gamma}";
      _macros["\\varDelta"] = "\\mathit{\\Delta}";
      _macros["\\varTheta"] = "\\mathit{\\Theta}";
      _macros["\\varLambda"] = "\\mathit{\\Lambda}";
      _macros["\\varXi"] = "\\mathit{\\Xi}";
      _macros["\\varPi"] = "\\mathit{\\Pi}";
      _macros["\\varSigma"] = "\\mathit{\\Sigma}";
      _macros["\\varUpsilon"] = "\\mathit{\\Upsilon}";
      _macros["\\varPhi"] = "\\mathit{\\Phi}";
      _macros["\\varPsi"] = "\\mathit{\\Psi}";
      _macros["\\varOmega"] = "\\mathit{\\Omega}";
      _macros["\\substack"] = "\\begin{subarray}{c}#1\\end{subarray}";
      _macros["\\colon"] = "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax";
      _macros["\\boxed"] = "\\fbox{$\\displaystyle{#1}$}";
      _macros["\\iff"] = "\\DOTSB\\;\\Longleftrightarrow\\;";
      _macros["\\implies"] = "\\DOTSB\\;\\Longrightarrow\\;";
      _macros["\\impliedby"] = "\\DOTSB\\;\\Longleftarrow\\;";
      _macros["\\dddot"] = "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}";
      _macros["\\ddddot"] = "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}";
      const dotsByToken = {",":"\\dotsc", "\\not":"\\dotsb", "+":"\\dotsb", "\x3d":"\\dotsb", "\x3c":"\\dotsb", "\x3e":"\\dotsb", "-":"\\dotsb", "*":"\\dotsb", ":":"\\dotsb", "\\DOTSB":"\\dotsb", "\\coprod":"\\dotsb", "\\bigvee":"\\dotsb", "\\bigwedge":"\\dotsb", "\\biguplus":"\\dotsb", "\\bigcap":"\\dotsb", "\\bigcup":"\\dotsb", "\\prod":"\\dotsb", "\\sum":"\\dotsb", "\\bigotimes":"\\dotsb", "\\bigoplus":"\\dotsb", "\\bigodot":"\\dotsb", "\\bigsqcup":"\\dotsb", "\\And":"\\dotsb", "\\longrightarrow":"\\dotsb", 
      "\\Longrightarrow":"\\dotsb", "\\longleftarrow":"\\dotsb", "\\Longleftarrow":"\\dotsb", "\\longleftrightarrow":"\\dotsb", "\\Longleftrightarrow":"\\dotsb", "\\mapsto":"\\dotsb", "\\longmapsto":"\\dotsb", "\\hookrightarrow":"\\dotsb", "\\doteq":"\\dotsb", "\\mathbin":"\\dotsb", "\\mathrel":"\\dotsb", "\\relbar":"\\dotsb", "\\Relbar":"\\dotsb", "\\xrightarrow":"\\dotsb", "\\xleftarrow":"\\dotsb", "\\DOTSI":"\\dotsi", "\\int":"\\dotsi", "\\oint":"\\dotsi", "\\iint":"\\dotsi", "\\iiint":"\\dotsi", 
      "\\iiiint":"\\dotsi", "\\idotsint":"\\dotsi", "\\DOTSX":"\\dotsx"};
      defineMacro("\\dots", function(context) {
        let thedots = "\\dotso";
        context = context.expandAfterFuture().text;
        context in dotsByToken ? thedots = dotsByToken[context] : "\\not" === context.slice(0, 4) ? thedots = "\\dotsb" : context in src_symbols.math && utils.contains(["bin", "rel"], src_symbols.math[context].group) && (thedots = "\\dotsb");
        return thedots;
      });
      const spaceAfterDots = {")":!0, "]":!0, "\\rbrack":!0, "\\}":!0, "\\rbrace":!0, "\\rangle":!0, "\\rceil":!0, "\\rfloor":!0, "\\rgroup":!0, "\\rmoustache":!0, "\\right":!0, "\\bigr":!0, "\\biggr":!0, "\\Bigr":!0, "\\Biggr":!0, $:!0, ";":!0, ".":!0, ",":!0};
      defineMacro("\\dotso", function(context) {
        return context.future().text in spaceAfterDots ? "\\ldots\\," : "\\ldots";
      });
      defineMacro("\\dotsc", function(context) {
        context = context.future().text;
        return context in spaceAfterDots && "," !== context ? "\\ldots\\," : "\\ldots";
      });
      defineMacro("\\cdots", function(context) {
        return context.future().text in spaceAfterDots ? "\\@cdots\\," : "\\@cdots";
      });
      _macros["\\dotsb"] = "\\cdots";
      _macros["\\dotsm"] = "\\cdots";
      _macros["\\dotsi"] = "\\!\\cdots";
      _macros["\\dotsx"] = "\\ldots\\,";
      _macros["\\DOTSI"] = "\\relax";
      _macros["\\DOTSB"] = "\\relax";
      _macros["\\DOTSX"] = "\\relax";
      _macros["\\tmspace"] = "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax";
      _macros["\\,"] = "\\tmspace+{3mu}{.1667em}";
      _macros["\\thinspace"] = "\\,";
      _macros["\\\x3e"] = "\\mskip{4mu}";
      _macros["\\:"] = "\\tmspace+{4mu}{.2222em}";
      _macros["\\medspace"] = "\\:";
      _macros["\\;"] = "\\tmspace+{5mu}{.2777em}";
      _macros["\\thickspace"] = "\\;";
      _macros["\\!"] = "\\tmspace-{3mu}{.1667em}";
      _macros["\\negthinspace"] = "\\!";
      _macros["\\negmedspace"] = "\\tmspace-{4mu}{.2222em}";
      _macros["\\negthickspace"] = "\\tmspace-{5mu}{.277em}";
      _macros["\\enspace"] = "\\kern.5em ";
      _macros["\\enskip"] = "\\hskip.5em\\relax";
      _macros["\\quad"] = "\\hskip1em\\relax";
      _macros["\\qquad"] = "\\hskip2em\\relax";
      _macros["\\tag"] = "\\@ifstar\\tag@literal\\tag@paren";
      _macros["\\tag@paren"] = "\\tag@literal{({#1})}";
      defineMacro("\\tag@literal", context => {
        if (context.macros.get("\\df@tag")) {
          throw new src_ParseError("Multiple \\tag");
        }
        return "\\gdef\\df@tag{\\text{#1}}";
      });
      _macros["\\bmod"] = "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}";
      _macros["\\pod"] = "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)";
      _macros["\\pmod"] = "\\pod{{\\rm mod}\\mkern6mu#1}";
      _macros["\\mod"] = "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1";
      _macros["\\newline"] = "\\\\\\relax";
      _macros["\\TeX"] = "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}";
      const latexRaiseA = makeEm(fontMetricsData["Main-Regular"][84][1] - 0.7 * fontMetricsData["Main-Regular"][65][1]);
      _macros["\\LaTeX"] = "\\textrm{\\html@mathml{L\\kern-.36em\\raisebox{" + (latexRaiseA + "}{\\scriptstyle A}\\kern-.15em\\TeX}{LaTeX}}");
      _macros["\\KaTeX"] = "\\textrm{\\html@mathml{K\\kern-.17em\\raisebox{" + (latexRaiseA + "}{\\scriptstyle A}\\kern-.15em\\TeX}{KaTeX}}");
      _macros["\\hspace"] = "\\@ifstar\\@hspacer\\@hspace";
      _macros["\\@hspace"] = "\\hskip #1\\relax";
      _macros["\\@hspacer"] = "\\rule{0pt}{0pt}\\hskip #1\\relax";
      _macros["\\ordinarycolon"] = ":";
      _macros["\\vcentcolon"] = "\\mathrel{\\mathop\\ordinarycolon}";
      _macros["\\dblcolon"] = '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}';
      _macros["\\coloneqq"] = '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\x3d}}{\\mathop{\\char"2254}}';
      _macros["\\Coloneqq"] = '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\x3d}}{\\mathop{\\char"2237\\char"3d}}';
      _macros["\\coloneq"] = '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}';
      _macros["\\Coloneq"] = '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}';
      _macros["\\eqqcolon"] = '\\html@mathml{\\mathrel{\x3d\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}';
      _macros["\\Eqqcolon"] = '\\html@mathml{\\mathrel{\x3d\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}';
      _macros["\\eqcolon"] = '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}';
      _macros["\\Eqcolon"] = '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}';
      _macros["\\colonapprox"] = '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}';
      _macros["\\Colonapprox"] = '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}';
      _macros["\\colonsim"] = '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}';
      _macros["\\Colonsim"] = '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}';
      _macros["∷"] = "\\dblcolon";
      _macros["∹"] = "\\eqcolon";
      _macros["≔"] = "\\coloneqq";
      _macros["≕"] = "\\eqqcolon";
      _macros["⩴"] = "\\Coloneqq";
      _macros["\\ratio"] = "\\vcentcolon";
      _macros["\\coloncolon"] = "\\dblcolon";
      _macros["\\colonequals"] = "\\coloneqq";
      _macros["\\coloncolonequals"] = "\\Coloneqq";
      _macros["\\equalscolon"] = "\\eqqcolon";
      _macros["\\equalscoloncolon"] = "\\Eqqcolon";
      _macros["\\colonminus"] = "\\coloneq";
      _macros["\\coloncolonminus"] = "\\Coloneq";
      _macros["\\minuscolon"] = "\\eqcolon";
      _macros["\\minuscoloncolon"] = "\\Eqcolon";
      _macros["\\coloncolonapprox"] = "\\Colonapprox";
      _macros["\\coloncolonsim"] = "\\Colonsim";
      _macros["\\simcolon"] = "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}";
      _macros["\\simcoloncolon"] = "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}";
      _macros["\\approxcolon"] = "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}";
      _macros["\\approxcoloncolon"] = "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}";
      _macros["\\notni"] = "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}";
      _macros["\\limsup"] = "\\DOTSB\\operatorname*{lim\\,sup}";
      _macros["\\liminf"] = "\\DOTSB\\operatorname*{lim\\,inf}";
      _macros["\\injlim"] = "\\DOTSB\\operatorname*{inj\\,lim}";
      _macros["\\projlim"] = "\\DOTSB\\operatorname*{proj\\,lim}";
      _macros["\\varlimsup"] = "\\DOTSB\\operatorname*{\\overline{lim}}";
      _macros["\\varliminf"] = "\\DOTSB\\operatorname*{\\underline{lim}}";
      _macros["\\varinjlim"] = "\\DOTSB\\operatorname*{\\underrightarrow{lim}}";
      _macros["\\varprojlim"] = "\\DOTSB\\operatorname*{\\underleftarrow{lim}}";
      _macros["\\gvertneqq"] = "\\html@mathml{\\@gvertneqq}{≩}";
      _macros["\\lvertneqq"] = "\\html@mathml{\\@lvertneqq}{≨}";
      _macros["\\ngeqq"] = "\\html@mathml{\\@ngeqq}{≱}";
      _macros["\\ngeqslant"] = "\\html@mathml{\\@ngeqslant}{≱}";
      _macros["\\nleqq"] = "\\html@mathml{\\@nleqq}{≰}";
      _macros["\\nleqslant"] = "\\html@mathml{\\@nleqslant}{≰}";
      _macros["\\nshortmid"] = "\\html@mathml{\\@nshortmid}{∤}";
      _macros["\\nshortparallel"] = "\\html@mathml{\\@nshortparallel}{∦}";
      _macros["\\nsubseteqq"] = "\\html@mathml{\\@nsubseteqq}{⊈}";
      _macros["\\nsupseteqq"] = "\\html@mathml{\\@nsupseteqq}{⊉}";
      _macros["\\varsubsetneq"] = "\\html@mathml{\\@varsubsetneq}{⊊}";
      _macros["\\varsubsetneqq"] = "\\html@mathml{\\@varsubsetneqq}{⫋}";
      _macros["\\varsupsetneq"] = "\\html@mathml{\\@varsupsetneq}{⊋}";
      _macros["\\varsupsetneqq"] = "\\html@mathml{\\@varsupsetneqq}{⫌}";
      _macros["\\imath"] = "\\html@mathml{\\@imath}{ı}";
      _macros["\\jmath"] = "\\html@mathml{\\@jmath}{ȷ}";
      _macros["\\llbracket"] = "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}";
      _macros["\\rrbracket"] = "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}";
      _macros["⟦"] = "\\llbracket";
      _macros["⟧"] = "\\rrbracket";
      _macros["\\lBrace"] = "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}";
      _macros["\\rBrace"] = "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}";
      _macros["⦃"] = "\\lBrace";
      _macros["⦄"] = "\\rBrace";
      _macros["\\minuso"] = "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}";
      _macros["⦵"] = "\\minuso";
      _macros["\\darr"] = "\\downarrow";
      _macros["\\dArr"] = "\\Downarrow";
      _macros["\\Darr"] = "\\Downarrow";
      _macros["\\lang"] = "\\langle";
      _macros["\\rang"] = "\\rangle";
      _macros["\\uarr"] = "\\uparrow";
      _macros["\\uArr"] = "\\Uparrow";
      _macros["\\Uarr"] = "\\Uparrow";
      _macros["\\N"] = "\\mathbb{N}";
      _macros["\\R"] = "\\mathbb{R}";
      _macros["\\Z"] = "\\mathbb{Z}";
      _macros["\\alef"] = "\\aleph";
      _macros["\\alefsym"] = "\\aleph";
      _macros["\\Alpha"] = "\\mathrm{A}";
      _macros["\\Beta"] = "\\mathrm{B}";
      _macros["\\bull"] = "\\bullet";
      _macros["\\Chi"] = "\\mathrm{X}";
      _macros["\\clubs"] = "\\clubsuit";
      _macros["\\cnums"] = "\\mathbb{C}";
      _macros["\\Complex"] = "\\mathbb{C}";
      _macros["\\Dagger"] = "\\ddagger";
      _macros["\\diamonds"] = "\\diamondsuit";
      _macros["\\empty"] = "\\emptyset";
      _macros["\\Epsilon"] = "\\mathrm{E}";
      _macros["\\Eta"] = "\\mathrm{H}";
      _macros["\\exist"] = "\\exists";
      _macros["\\harr"] = "\\leftrightarrow";
      _macros["\\hArr"] = "\\Leftrightarrow";
      _macros["\\Harr"] = "\\Leftrightarrow";
      _macros["\\hearts"] = "\\heartsuit";
      _macros["\\image"] = "\\Im";
      _macros["\\infin"] = "\\infty";
      _macros["\\Iota"] = "\\mathrm{I}";
      _macros["\\isin"] = "\\in";
      _macros["\\Kappa"] = "\\mathrm{K}";
      _macros["\\larr"] = "\\leftarrow";
      _macros["\\lArr"] = "\\Leftarrow";
      _macros["\\Larr"] = "\\Leftarrow";
      _macros["\\lrarr"] = "\\leftrightarrow";
      _macros["\\lrArr"] = "\\Leftrightarrow";
      _macros["\\Lrarr"] = "\\Leftrightarrow";
      _macros["\\Mu"] = "\\mathrm{M}";
      _macros["\\natnums"] = "\\mathbb{N}";
      _macros["\\Nu"] = "\\mathrm{N}";
      _macros["\\Omicron"] = "\\mathrm{O}";
      _macros["\\plusmn"] = "\\pm";
      _macros["\\rarr"] = "\\rightarrow";
      _macros["\\rArr"] = "\\Rightarrow";
      _macros["\\Rarr"] = "\\Rightarrow";
      _macros["\\real"] = "\\Re";
      _macros["\\reals"] = "\\mathbb{R}";
      _macros["\\Reals"] = "\\mathbb{R}";
      _macros["\\Rho"] = "\\mathrm{P}";
      _macros["\\sdot"] = "\\cdot";
      _macros["\\sect"] = "\\S";
      _macros["\\spades"] = "\\spadesuit";
      _macros["\\sub"] = "\\subset";
      _macros["\\sube"] = "\\subseteq";
      _macros["\\supe"] = "\\supseteq";
      _macros["\\Tau"] = "\\mathrm{T}";
      _macros["\\thetasym"] = "\\vartheta";
      _macros["\\weierp"] = "\\wp";
      _macros["\\Zeta"] = "\\mathrm{Z}";
      _macros["\\argmin"] = "\\DOTSB\\operatorname*{arg\\,min}";
      _macros["\\argmax"] = "\\DOTSB\\operatorname*{arg\\,max}";
      _macros["\\plim"] = "\\DOTSB\\mathop{\\operatorname{plim}}\\limits";
      _macros["\\bra"] = "\\mathinner{\\langle{#1}|}";
      _macros["\\ket"] = "\\mathinner{|{#1}\\rangle}";
      _macros["\\braket"] = "\\mathinner{\\langle{#1}\\rangle}";
      _macros["\\Bra"] = "\\left\\langle#1\\right|";
      _macros["\\Ket"] = "\\left|#1\\right\\rangle";
      const braketHelper = one => context => {
        var left = context.consumeArg().tokens;
        const middle = context.consumeArg().tokens, middleDouble = context.consumeArg().tokens, right = context.consumeArg().tokens, oldMiddle = context.macros.get("|"), oldMiddleDouble = context.macros.get("\\|");
        context.macros.beginGroup();
        var midMacro = double => context => {
          one && (context.macros.set("|", oldMiddle), middleDouble.length && context.macros.set("\\|", oldMiddleDouble));
          let doubled = double;
          !double && middleDouble.length && "|" === context.future().text && (context.popToken(), doubled = !0);
          return {tokens:doubled ? middleDouble : middle, numArgs:0};
        };
        context.macros.set("|", midMacro(!1));
        middleDouble.length && context.macros.set("\\|", midMacro(!0));
        midMacro = context.consumeArg().tokens;
        left = context.expandTokens([...right, ...midMacro, ...left]);
        context.macros.endGroup();
        return {tokens:left.reverse(), numArgs:0};
      };
      defineMacro("\\bra@ket", braketHelper(!1));
      defineMacro("\\bra@set", braketHelper(!0));
      _macros["\\Braket"] = "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}";
      _macros["\\Set"] = "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}";
      _macros["\\set"] = "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}";
      _macros["\\angln"] = "{\\angl n}";
      _macros["\\blue"] = "\\textcolor{##6495ed}{#1}";
      _macros["\\orange"] = "\\textcolor{##ffa500}{#1}";
      _macros["\\pink"] = "\\textcolor{##ff00af}{#1}";
      _macros["\\red"] = "\\textcolor{##df0030}{#1}";
      _macros["\\green"] = "\\textcolor{##28ae7b}{#1}";
      _macros["\\gray"] = "\\textcolor{gray}{#1}";
      _macros["\\purple"] = "\\textcolor{##9d38bd}{#1}";
      _macros["\\blueA"] = "\\textcolor{##ccfaff}{#1}";
      _macros["\\blueB"] = "\\textcolor{##80f6ff}{#1}";
      _macros["\\blueC"] = "\\textcolor{##63d9ea}{#1}";
      _macros["\\blueD"] = "\\textcolor{##11accd}{#1}";
      _macros["\\blueE"] = "\\textcolor{##0c7f99}{#1}";
      _macros["\\tealA"] = "\\textcolor{##94fff5}{#1}";
      _macros["\\tealB"] = "\\textcolor{##26edd5}{#1}";
      _macros["\\tealC"] = "\\textcolor{##01d1c1}{#1}";
      _macros["\\tealD"] = "\\textcolor{##01a995}{#1}";
      _macros["\\tealE"] = "\\textcolor{##208170}{#1}";
      _macros["\\greenA"] = "\\textcolor{##b6ffb0}{#1}";
      _macros["\\greenB"] = "\\textcolor{##8af281}{#1}";
      _macros["\\greenC"] = "\\textcolor{##74cf70}{#1}";
      _macros["\\greenD"] = "\\textcolor{##1fab54}{#1}";
      _macros["\\greenE"] = "\\textcolor{##0d923f}{#1}";
      _macros["\\goldA"] = "\\textcolor{##ffd0a9}{#1}";
      _macros["\\goldB"] = "\\textcolor{##ffbb71}{#1}";
      _macros["\\goldC"] = "\\textcolor{##ff9c39}{#1}";
      _macros["\\goldD"] = "\\textcolor{##e07d10}{#1}";
      _macros["\\goldE"] = "\\textcolor{##a75a05}{#1}";
      _macros["\\redA"] = "\\textcolor{##fca9a9}{#1}";
      _macros["\\redB"] = "\\textcolor{##ff8482}{#1}";
      _macros["\\redC"] = "\\textcolor{##f9685d}{#1}";
      _macros["\\redD"] = "\\textcolor{##e84d39}{#1}";
      _macros["\\redE"] = "\\textcolor{##bc2612}{#1}";
      _macros["\\maroonA"] = "\\textcolor{##ffbde0}{#1}";
      _macros["\\maroonB"] = "\\textcolor{##ff92c6}{#1}";
      _macros["\\maroonC"] = "\\textcolor{##ed5fa6}{#1}";
      _macros["\\maroonD"] = "\\textcolor{##ca337c}{#1}";
      _macros["\\maroonE"] = "\\textcolor{##9e034e}{#1}";
      _macros["\\purpleA"] = "\\textcolor{##ddd7ff}{#1}";
      _macros["\\purpleB"] = "\\textcolor{##c6b9fc}{#1}";
      _macros["\\purpleC"] = "\\textcolor{##aa87ff}{#1}";
      _macros["\\purpleD"] = "\\textcolor{##7854ab}{#1}";
      _macros["\\purpleE"] = "\\textcolor{##543b78}{#1}";
      _macros["\\mintA"] = "\\textcolor{##f5f9e8}{#1}";
      _macros["\\mintB"] = "\\textcolor{##edf2df}{#1}";
      _macros["\\mintC"] = "\\textcolor{##e0e5cc}{#1}";
      _macros["\\grayA"] = "\\textcolor{##f6f7f7}{#1}";
      _macros["\\grayB"] = "\\textcolor{##f0f1f2}{#1}";
      _macros["\\grayC"] = "\\textcolor{##e3e5e6}{#1}";
      _macros["\\grayD"] = "\\textcolor{##d6d8da}{#1}";
      _macros["\\grayE"] = "\\textcolor{##babec2}{#1}";
      _macros["\\grayF"] = "\\textcolor{##888d93}{#1}";
      _macros["\\grayG"] = "\\textcolor{##626569}{#1}";
      _macros["\\grayH"] = "\\textcolor{##3b3e40}{#1}";
      _macros["\\grayI"] = "\\textcolor{##21242c}{#1}";
      _macros["\\kaBlue"] = "\\textcolor{##314453}{#1}";
      _macros["\\kaGreen"] = "\\textcolor{##71B307}{#1}";
      const implicitCommands = {"^":!0, _:!0, "\\limits":!0, "\\nolimits":!0};
      class MacroExpander {
        constructor(input, settings, mode) {
          this.mode = this.stack = this.macros = this.lexer = this.expansionCount = this.settings = void 0;
          this.settings = settings;
          this.expansionCount = 0;
          this.feed(input);
          this.macros = new Namespace(src_macros, settings.macros);
          this.mode = mode;
          this.stack = [];
        }
        feed(input) {
          this.lexer = new Lexer(input, this.settings);
        }
        switchMode(newMode) {
          this.mode = newMode;
        }
        beginGroup() {
          this.macros.beginGroup();
        }
        endGroup() {
          this.macros.endGroup();
        }
        endGroups() {
          this.macros.endGroups();
        }
        future() {
          0 === this.stack.length && this.pushToken(this.lexer.lex());
          return this.stack[this.stack.length - 1];
        }
        popToken() {
          this.future();
          return this.stack.pop();
        }
        pushToken(token) {
          this.stack.push(token);
        }
        pushTokens(tokens) {
          this.stack.push(...tokens);
        }
        scanArgument(isOptional) {
          let end, tokens;
          if (isOptional) {
            this.consumeSpaces();
            if ("[" !== this.future().text) {
              return null;
            }
            isOptional = this.popToken();
            ({tokens, end} = this.consumeArg(["]"]));
          } else {
            ({tokens, start:isOptional, end} = this.consumeArg());
          }
          this.pushToken(new Token("EOF", end.loc));
          this.pushTokens(tokens);
          return isOptional.range(end, "");
        }
        consumeSpaces() {
          for (;;) {
            if (" " === this.future().text) {
              this.stack.pop();
            } else {
              break;
            }
          }
        }
        consumeArg(delims) {
          const tokens = [], isDelimited = delims && 0 < delims.length;
          isDelimited || this.consumeSpaces();
          const start = this.future();
          let tok, depth = 0, match = 0;
          do {
            tok = this.popToken();
            tokens.push(tok);
            if ("{" === tok.text) {
              ++depth;
            } else if ("}" === tok.text) {
              if (--depth, -1 === depth) {
                throw new src_ParseError("Extra }", tok);
              }
            } else if ("EOF" === tok.text) {
              throw new src_ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
            }
            if (delims && isDelimited) {
              if ((0 === depth || 1 === depth && "{" === delims[match]) && tok.text === delims[match]) {
                if (++match, match === delims.length) {
                  tokens.splice(-match, match);
                  break;
                }
              } else {
                match = 0;
              }
            }
          } while (0 !== depth || isDelimited);
          "{" === start.text && "}" === tokens[tokens.length - 1].text && (tokens.pop(), tokens.shift());
          tokens.reverse();
          return {tokens, start, end:tok};
        }
        consumeArgs(numArgs, delimiters) {
          if (delimiters) {
            if (delimiters.length !== numArgs + 1) {
              throw new src_ParseError("The length of delimiters doesn't match the number of args!");
            }
            var delims = delimiters[0];
            for (var i = 0; i < delims.length; i++) {
              const tok = this.popToken();
              if (delims[i] !== tok.text) {
                throw new src_ParseError("Use of the macro doesn't match its definition", tok);
              }
            }
          }
          delims = [];
          for (i = 0; i < numArgs; i++) {
            delims.push(this.consumeArg(delimiters && delimiters[i + 1]).tokens);
          }
          return delims;
        }
        countExpansion(amount) {
          this.expansionCount += amount;
          if (this.expansionCount > this.settings.maxExpand) {
            throw new src_ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
          }
        }
        expandOnce(expandableOnly) {
          var topToken = this.popToken(), name = topToken.text, expansion = topToken.noexpand ? null : this._getExpansion(name);
          if (null == expansion || expandableOnly && expansion.unexpandable) {
            if (expandableOnly && null == expansion && "\\" === name[0] && !this.isDefined(name)) {
              throw new src_ParseError("Undefined control sequence: " + name);
            }
            this.pushToken(topToken);
            return !1;
          }
          this.countExpansion(1);
          expandableOnly = expansion.tokens;
          topToken = this.consumeArgs(expansion.numArgs, expansion.delimiters);
          if (expansion.numArgs) {
            for (expandableOnly = expandableOnly.slice(), expansion = expandableOnly.length - 1; 0 <= expansion; --expansion) {
              if (name = expandableOnly[expansion], "#" === name.text) {
                if (0 === expansion) {
                  throw new src_ParseError("Incomplete placeholder at end of macro body", name);
                }
                name = expandableOnly[--expansion];
                if ("#" === name.text) {
                  expandableOnly.splice(expansion + 1, 1);
                } else if (/^[1-9]$/.test(name.text)) {
                  expandableOnly.splice(expansion, 2, ...topToken[+name.text - 1]);
                } else {
                  throw new src_ParseError("Not a valid argument number", name);
                }
              }
            }
          }
          this.pushTokens(expandableOnly);
          return expandableOnly.length;
        }
        expandAfterFuture() {
          this.expandOnce();
          return this.future();
        }
        expandNextToken() {
          for (;;) {
            if (!1 === this.expandOnce()) {
              const token = this.stack.pop();
              token.treatAsRelax && (token.text = "\\relax");
              return token;
            }
          }
          throw Error();
        }
        expandMacro(name) {
          return this.macros.has(name) ? this.expandTokens([new Token(name)]) : void 0;
        }
        expandTokens(tokens) {
          const output = [], oldStackLength = this.stack.length;
          for (this.pushTokens(tokens); this.stack.length > oldStackLength;) {
            !1 === this.expandOnce(!0) && (tokens = this.stack.pop(), tokens.treatAsRelax && (tokens.noexpand = !1, tokens.treatAsRelax = !1), output.push(tokens));
          }
          this.countExpansion(output.length);
          return output;
        }
        expandMacroAsText(name) {
          return (name = this.expandMacro(name)) ? name.map(token => token.text).join("") : name;
        }
        _getExpansion(name) {
          var definition = this.macros.get(name);
          if (null == definition) {
            return definition;
          }
          if (1 === name.length && (name = this.lexer.catcodes[name], null != name && 13 !== name)) {
            return;
          }
          name = "function" === typeof definition ? definition(this) : definition;
          if ("string" === typeof name) {
            definition = 0;
            if (-1 !== name.indexOf("#")) {
              for (var stripped = name.replace(/##/g, ""); -1 !== stripped.indexOf("#" + (definition + 1));) {
                ++definition;
              }
            }
            name = new Lexer(name, this.settings);
            stripped = [];
            let tok = name.lex();
            for (; "EOF" !== tok.text;) {
              stripped.push(tok), tok = name.lex();
            }
            stripped.reverse();
            return {tokens:stripped, numArgs:definition};
          }
          return name;
        }
        isDefined(name) {
          return this.macros.has(name) || src_functions.hasOwnProperty(name) || src_symbols.math.hasOwnProperty(name) || src_symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
        }
        isExpandable(name) {
          const macro = this.macros.get(name);
          return null != macro ? "string" === typeof macro || "function" === typeof macro || !macro.unexpandable : src_functions.hasOwnProperty(name) && !src_functions[name].primitive;
        }
      }
      const unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/, uSubsAndSups = Object.freeze({"₊":"+", "₋":"-", "₌":"\x3d", "₍":"(", "₎":")", "₀":"0", "₁":"1", "₂":"2", "₃":"3", "₄":"4", "₅":"5", "₆":"6", "₇":"7", "₈":"8", "₉":"9", "ₐ":"a", "ₑ":"e", "ₕ":"h", "ᵢ":"i", "ⱼ":"j", "ₖ":"k", "ₗ":"l", "ₘ":"m", "ₙ":"n", "ₒ":"o", "ₚ":"p", "ᵣ":"r", "ₛ":"s", "ₜ":"t", "ᵤ":"u", "ᵥ":"v", "ₓ":"x", "ᵦ":"β", "ᵧ":"γ", "ᵨ":"ρ", "ᵩ":"ϕ", "ᵪ":"χ", "⁺":"+", "⁻":"-", "⁼":"\x3d", "⁽":"(", "⁾":")", "⁰":"0", "¹":"1", 
      "²":"2", "³":"3", "⁴":"4", "⁵":"5", "⁶":"6", "⁷":"7", "⁸":"8", "⁹":"9", "ᴬ":"A", "ᴮ":"B", "ᴰ":"D", "ᴱ":"E", "ᴳ":"G", "ᴴ":"H", "ᴵ":"I", "ᴶ":"J", "ᴷ":"K", "ᴸ":"L", "ᴹ":"M", "ᴺ":"N", "ᴼ":"O", "ᴾ":"P", "ᴿ":"R", "ᵀ":"T", "ᵁ":"U", "ⱽ":"V", "ᵂ":"W", "ᵃ":"a", "ᵇ":"b", "ᶜ":"c", "ᵈ":"d", "ᵉ":"e", "ᶠ":"f", "ᵍ":"g", "ʰ":"h", "ⁱ":"i", "ʲ":"j", "ᵏ":"k", "ˡ":"l", "ᵐ":"m", "ⁿ":"n", "ᵒ":"o", "ᵖ":"p", "ʳ":"r", "ˢ":"s", "ᵗ":"t", "ᵘ":"u", "ᵛ":"v", "ʷ":"w", "ˣ":"x", "ʸ":"y", "ᶻ":"z", "ᵝ":"β", "ᵞ":"γ", "ᵟ":"δ", 
      "ᵠ":"ϕ", "ᵡ":"χ", "ᶿ":"θ"}), unicodeAccents = {"́":{text:"\\'", math:"\\acute"}, "̀":{text:"\\`", math:"\\grave"}, "̈":{text:'\\"', math:"\\ddot"}, "̃":{text:"\\~", math:"\\tilde"}, "̄":{text:"\\\x3d", math:"\\bar"}, "̆":{text:"\\u", math:"\\breve"}, "̌":{text:"\\v", math:"\\check"}, "̂":{text:"\\^", math:"\\hat"}, "̇":{text:"\\.", math:"\\dot"}, "̊":{text:"\\r", math:"\\mathring"}, "̋":{text:"\\H"}, "̧":{text:"\\c"}}, unicodeSymbols = {"á":"á", "à":"à", "ä":"ä", "ǟ":"ǟ", "ã":"ã", "ā":"ā", 
      "ă":"ă", "ắ":"ắ", "ằ":"ằ", "ẵ":"ẵ", "ǎ":"ǎ", "â":"â", "ấ":"ấ", "ầ":"ầ", "ẫ":"ẫ", "ȧ":"ȧ", "ǡ":"ǡ", "å":"å", "ǻ":"ǻ", "ḃ":"ḃ", "ć":"ć", "ḉ":"ḉ", "č":"č", "ĉ":"ĉ", "ċ":"ċ", "ç":"ç", "ď":"ď", "ḋ":"ḋ", "ḑ":"ḑ", "é":"é", "è":"è", "ë":"ë", "ẽ":"ẽ", "ē":"ē", "ḗ":"ḗ", "ḕ":"ḕ", "ĕ":"ĕ", "ḝ":"ḝ", "ě":"ě", "ê":"ê", "ế":"ế", "ề":"ề", "ễ":"ễ", "ė":"ė", "ȩ":"ȩ", "ḟ":"ḟ", "ǵ":"ǵ", "ḡ":"ḡ", "ğ":"ğ", "ǧ":"ǧ", "ĝ":"ĝ", "ġ":"ġ", "ģ":"ģ", "ḧ":"ḧ", 
      "ȟ":"ȟ", "ĥ":"ĥ", "ḣ":"ḣ", "ḩ":"ḩ", "í":"í", "ì":"ì", "ï":"ï", "ḯ":"ḯ", "ĩ":"ĩ", "ī":"ī", "ĭ":"ĭ", "ǐ":"ǐ", "î":"î", "ǰ":"ǰ", "ĵ":"ĵ", "ḱ":"ḱ", "ǩ":"ǩ", "ķ":"ķ", "ĺ":"ĺ", "ľ":"ľ", "ļ":"ļ", "ḿ":"ḿ", "ṁ":"ṁ", "ń":"ń", "ǹ":"ǹ", "ñ":"ñ", "ň":"ň", "ṅ":"ṅ", "ņ":"ņ", "ó":"ó", "ò":"ò", "ö":"ö", "ȫ":"ȫ", "õ":"õ", "ṍ":"ṍ", "ṏ":"ṏ", "ȭ":"ȭ", "ō":"ō", "ṓ":"ṓ", "ṑ":"ṑ", "ŏ":"ŏ", "ǒ":"ǒ", "ô":"ô", "ố":"ố", "ồ":"ồ", "ỗ":"ỗ", "ȯ":"ȯ", "ȱ":"ȱ", "ő":"ő", 
      "ṕ":"ṕ", "ṗ":"ṗ", "ŕ":"ŕ", "ř":"ř", "ṙ":"ṙ", "ŗ":"ŗ", "ś":"ś", "ṥ":"ṥ", "š":"š", "ṧ":"ṧ", "ŝ":"ŝ", "ṡ":"ṡ", "ş":"ş", "ẗ":"ẗ", "ť":"ť", "ṫ":"ṫ", "ţ":"ţ", "ú":"ú", "ù":"ù", "ü":"ü", "ǘ":"ǘ", "ǜ":"ǜ", "ǖ":"ǖ", "ǚ":"ǚ", "ũ":"ũ", "ṹ":"ṹ", "ū":"ū", "ṻ":"ṻ", "ŭ":"ŭ", "ǔ":"ǔ", "û":"û", "ů":"ů", "ű":"ű", "ṽ":"ṽ", "ẃ":"ẃ", "ẁ":"ẁ", "ẅ":"ẅ", "ŵ":"ŵ", "ẇ":"ẇ", "ẘ":"ẘ", "ẍ":"ẍ", "ẋ":"ẋ", "ý":"ý", "ỳ":"ỳ", "ÿ":"ÿ", "ỹ":"ỹ", "ȳ":"ȳ", "ŷ":"ŷ", "ẏ":"ẏ", 
      "ẙ":"ẙ", "ź":"ź", "ž":"ž", "ẑ":"ẑ", "ż":"ż", "Á":"Á", "À":"À", "Ä":"Ä", "Ǟ":"Ǟ", "Ã":"Ã", "Ā":"Ā", "Ă":"Ă", "Ắ":"Ắ", "Ằ":"Ằ", "Ẵ":"Ẵ", "Ǎ":"Ǎ", "Â":"Â", "Ấ":"Ấ", "Ầ":"Ầ", "Ẫ":"Ẫ", "Ȧ":"Ȧ", "Ǡ":"Ǡ", "Å":"Å", "Ǻ":"Ǻ", "Ḃ":"Ḃ", "Ć":"Ć", "Ḉ":"Ḉ", "Č":"Č", "Ĉ":"Ĉ", "Ċ":"Ċ", "Ç":"Ç", "Ď":"Ď", "Ḋ":"Ḋ", "Ḑ":"Ḑ", "É":"É", "È":"È", "Ë":"Ë", "Ẽ":"Ẽ", "Ē":"Ē", "Ḗ":"Ḗ", "Ḕ":"Ḕ", "Ĕ":"Ĕ", "Ḝ":"Ḝ", "Ě":"Ě", "Ê":"Ê", "Ế":"Ế", "Ề":"Ề", "Ễ":"Ễ", 
      "Ė":"Ė", "Ȩ":"Ȩ", "Ḟ":"Ḟ", "Ǵ":"Ǵ", "Ḡ":"Ḡ", "Ğ":"Ğ", "Ǧ":"Ǧ", "Ĝ":"Ĝ", "Ġ":"Ġ", "Ģ":"Ģ", "Ḧ":"Ḧ", "Ȟ":"Ȟ", "Ĥ":"Ĥ", "Ḣ":"Ḣ", "Ḩ":"Ḩ", "Í":"Í", "Ì":"Ì", "Ï":"Ï", "Ḯ":"Ḯ", "Ĩ":"Ĩ", "Ī":"Ī", "Ĭ":"Ĭ", "Ǐ":"Ǐ", "Î":"Î", "İ":"İ", "Ĵ":"Ĵ", "Ḱ":"Ḱ", "Ǩ":"Ǩ", "Ķ":"Ķ", "Ĺ":"Ĺ", "Ľ":"Ľ", "Ļ":"Ļ", "Ḿ":"Ḿ", "Ṁ":"Ṁ", "Ń":"Ń", "Ǹ":"Ǹ", "Ñ":"Ñ", "Ň":"Ň", "Ṅ":"Ṅ", "Ņ":"Ņ", "Ó":"Ó", "Ò":"Ò", "Ö":"Ö", "Ȫ":"Ȫ", "Õ":"Õ", "Ṍ":"Ṍ", "Ṏ":"Ṏ", "Ȭ":"Ȭ", "Ō":"Ō", 
      "Ṓ":"Ṓ", "Ṑ":"Ṑ", "Ŏ":"Ŏ", "Ǒ":"Ǒ", "Ô":"Ô", "Ố":"Ố", "Ồ":"Ồ", "Ỗ":"Ỗ", "Ȯ":"Ȯ", "Ȱ":"Ȱ", "Ő":"Ő", "Ṕ":"Ṕ", "Ṗ":"Ṗ", "Ŕ":"Ŕ", "Ř":"Ř", "Ṙ":"Ṙ", "Ŗ":"Ŗ", "Ś":"Ś", "Ṥ":"Ṥ", "Š":"Š", "Ṧ":"Ṧ", "Ŝ":"Ŝ", "Ṡ":"Ṡ", "Ş":"Ş", "Ť":"Ť", "Ṫ":"Ṫ", "Ţ":"Ţ", "Ú":"Ú", "Ù":"Ù", "Ü":"Ü", "Ǘ":"Ǘ", "Ǜ":"Ǜ", "Ǖ":"Ǖ", "Ǚ":"Ǚ", "Ũ":"Ũ", "Ṹ":"Ṹ", "Ū":"Ū", "Ṻ":"Ṻ", "Ŭ":"Ŭ", "Ǔ":"Ǔ", "Û":"Û", "Ů":"Ů", "Ű":"Ű", "Ṽ":"Ṽ", "Ẃ":"Ẃ", "Ẁ":"Ẁ", "Ẅ":"Ẅ", "Ŵ":"Ŵ", "Ẇ":"Ẇ", 
      "Ẍ":"Ẍ", "Ẋ":"Ẋ", "Ý":"Ý", "Ỳ":"Ỳ", "Ÿ":"Ÿ", "Ỹ":"Ỹ", "Ȳ":"Ȳ", "Ŷ":"Ŷ", "Ẏ":"Ẏ", "Ź":"Ź", "Ž":"Ž", "Ẑ":"Ẑ", "Ż":"Ż", "ά":"ά", "ὰ":"ὰ", "ᾱ":"ᾱ", "ᾰ":"ᾰ", "έ":"έ", "ὲ":"ὲ", "ή":"ή", "ὴ":"ὴ", "ί":"ί", "ὶ":"ὶ", "ϊ":"ϊ", "ΐ":"ΐ", "ῒ":"ῒ", "ῑ":"ῑ", "ῐ":"ῐ", "ό":"ό", "ὸ":"ὸ", "ύ":"ύ", "ὺ":"ὺ", "ϋ":"ϋ", "ΰ":"ΰ", "ῢ":"ῢ", "ῡ":"ῡ", "ῠ":"ῠ", "ώ":"ώ", "ὼ":"ὼ", "Ύ":"Ύ", "Ὺ":"Ὺ", "Ϋ":"Ϋ", "Ῡ":"Ῡ", "Ῠ":"Ῠ", "Ώ":"Ώ", "Ὼ":"Ὼ"};
      class Parser {
        constructor(input, settings) {
          this.nextToken = this.leftrightDepth = this.settings = this.gullet = this.mode = void 0;
          this.mode = "math";
          this.gullet = new MacroExpander(input, settings, this.mode);
          this.settings = settings;
          this.leftrightDepth = 0;
        }
        expect(text, consume) {
          void 0 === consume && (consume = !0);
          if (this.fetch().text !== text) {
            throw new src_ParseError("Expected '" + text + "', got '" + this.fetch().text + "'", this.fetch());
          }
          consume && this.consume();
        }
        consume() {
          this.nextToken = null;
        }
        fetch() {
          null == this.nextToken && (this.nextToken = this.gullet.expandNextToken());
          return this.nextToken;
        }
        switchMode(newMode) {
          this.mode = newMode;
          this.gullet.switchMode(newMode);
        }
        parse() {
          this.settings.globalGroup || this.gullet.beginGroup();
          this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
          try {
            const parse = this.parseExpression(!1);
            this.expect("EOF");
            this.settings.globalGroup || this.gullet.endGroup();
            return parse;
          } finally {
            this.gullet.endGroups();
          }
        }
        subparse(tokens) {
          const oldToken = this.nextToken;
          this.consume();
          this.gullet.pushToken(new Token("}"));
          this.gullet.pushTokens(tokens);
          tokens = this.parseExpression(!1);
          this.expect("}");
          this.nextToken = oldToken;
          return tokens;
        }
        parseExpression(breakOnInfix, breakOnTokenText) {
          const body = [];
          for (;;) {
            "math" === this.mode && this.consumeSpaces();
            var lex = this.fetch();
            if (-1 !== Parser.endOfExpression.indexOf(lex.text)) {
              break;
            }
            if (breakOnTokenText && lex.text === breakOnTokenText) {
              break;
            }
            if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
              break;
            }
            lex = this.parseAtom(breakOnTokenText);
            if (!lex) {
              break;
            } else if ("internal" === lex.type) {
              continue;
            }
            body.push(lex);
          }
          "text" === this.mode && this.formLigatures(body);
          return this.handleInfixNodes(body);
        }
        handleInfixNodes(body) {
          let overIndex = -1, funcName;
          for (var i = 0; i < body.length; i++) {
            if ("infix" === body[i].type) {
              if (-1 !== overIndex) {
                throw new src_ParseError("only one infix operator per group", body[i].token);
              }
              overIndex = i;
              funcName = body[i].replaceWith;
            }
          }
          if (-1 !== overIndex && funcName) {
            i = body.slice(0, overIndex);
            var denomNode = body.slice(overIndex + 1);
            i = 1 === i.length && "ordgroup" === i[0].type ? i[0] : {type:"ordgroup", mode:this.mode, body:i};
            denomNode = 1 === denomNode.length && "ordgroup" === denomNode[0].type ? denomNode[0] : {type:"ordgroup", mode:this.mode, body:denomNode};
            return ["\\\\abovefrac" === funcName ? this.callFunction(funcName, [i, body[overIndex], denomNode], []) : this.callFunction(funcName, [i, denomNode], [])];
          }
          return body;
        }
        handleSupSubscript(name) {
          const symbolToken = this.fetch(), symbol = symbolToken.text;
          this.consume();
          this.consumeSpaces();
          name = this.parseGroup(name);
          if (!name) {
            throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
          }
          return name;
        }
        formatUnsupportedCmd(text) {
          const textordArray = [];
          for (let i = 0; i < text.length; i++) {
            textordArray.push({type:"textord", mode:"text", text:text[i]});
          }
          return {type:"color", mode:this.mode, color:this.settings.errorColor, body:[{type:"text", mode:this.mode, body:textordArray}]};
        }
        parseAtom(breakOnTokenText) {
          breakOnTokenText = this.parseGroup("atom", breakOnTokenText);
          if ("text" === this.mode) {
            return breakOnTokenText;
          }
          let subscript;
          for (;;) {
            this.consumeSpaces();
            var lex = this.fetch();
            if ("\\limits" === lex.text || "\\nolimits" === lex.text) {
              if (breakOnTokenText && "op" === breakOnTokenText.type) {
                breakOnTokenText.limits = "\\limits" === lex.text, breakOnTokenText.alwaysHandleSupSub = !0;
              } else if (breakOnTokenText && "operatorname" === breakOnTokenText.type) {
                breakOnTokenText.alwaysHandleSupSub && (breakOnTokenText.limits = "\\limits" === lex.text);
              } else {
                throw new src_ParseError("Limit controls must follow a math operator", lex);
              }
              this.consume();
            } else if ("^" === lex.text) {
              if (superscript) {
                throw new src_ParseError("Double superscript", lex);
              }
              var superscript = this.handleSupSubscript("superscript");
            } else if ("_" === lex.text) {
              if (subscript) {
                throw new src_ParseError("Double subscript", lex);
              }
              subscript = this.handleSupSubscript("subscript");
            } else if ("'" === lex.text) {
              if (superscript) {
                throw new src_ParseError("Double superscript", lex);
              }
              superscript = {type:"textord", mode:this.mode, text:"\\prime"};
              var primes = [superscript];
              for (this.consume(); "'" === this.fetch().text;) {
                primes.push(superscript), this.consume();
              }
              "^" === this.fetch().text && primes.push(this.handleSupSubscript("superscript"));
              superscript = {type:"ordgroup", mode:this.mode, body:primes};
            } else if (uSubsAndSups[lex.text]) {
              primes = unicodeSubRegEx.test(lex.text);
              var subsupTokens = [];
              subsupTokens.push(new Token(uSubsAndSups[lex.text]));
              for (this.consume();;) {
                lex = this.fetch().text;
                if (!uSubsAndSups[lex]) {
                  break;
                }
                if (unicodeSubRegEx.test(lex) !== primes) {
                  break;
                }
                subsupTokens.unshift(new Token(uSubsAndSups[lex]));
                this.consume();
              }
              subsupTokens = this.subparse(subsupTokens);
              primes ? subscript = {type:"ordgroup", mode:"math", body:subsupTokens} : superscript = {type:"ordgroup", mode:"math", body:subsupTokens};
            } else {
              break;
            }
          }
          return superscript || subscript ? {type:"supsub", mode:this.mode, base:breakOnTokenText, sup:superscript, sub:subscript} : breakOnTokenText;
        }
        parseFunction(breakOnTokenText, name) {
          const token = this.fetch(), func = token.text, funcData = src_functions[func];
          if (!funcData) {
            return null;
          }
          this.consume();
          if (name && "atom" !== name && !funcData.allowedInArgument) {
            throw new src_ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
          }
          if ("text" === this.mode && !funcData.allowedInText) {
            throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
          }
          if ("math" === this.mode && !1 === funcData.allowedInMath) {
            throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
          }
          const {args, optArgs} = this.parseArguments(func, funcData);
          return this.callFunction(func, args, optArgs, token, breakOnTokenText);
        }
        callFunction(name, args, optArgs, token, breakOnTokenText) {
          token = {funcName:name, parser:this, token, breakOnTokenText};
          if ((breakOnTokenText = src_functions[name]) && breakOnTokenText.handler) {
            return breakOnTokenText.handler(token, args, optArgs);
          }
          throw new src_ParseError("No function handler for " + name);
        }
        parseArguments(func, funcData) {
          const totalArgs = funcData.numArgs + funcData.numOptionalArgs;
          if (0 === totalArgs) {
            return {args:[], optArgs:[]};
          }
          const args = [], optArgs = [];
          for (let i = 0; i < totalArgs; i++) {
            var argType = funcData.argTypes && funcData.argTypes[i];
            const isOptional = i < funcData.numOptionalArgs;
            if (funcData.primitive && null == argType || "sqrt" === funcData.type && 1 === i && null == optArgs[0]) {
              argType = "primitive";
            }
            argType = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
            if (isOptional) {
              optArgs.push(argType);
            } else if (null != argType) {
              args.push(argType);
            } else {
              throw new src_ParseError("Null argument, please report this as a bug");
            }
          }
          return {args, optArgs};
        }
        parseGroupOfType(name, type, optional) {
          switch(type) {
            case "color":
              return this.parseColorGroup(optional);
            case "size":
              return this.parseSizeGroup(optional);
            case "url":
              return this.parseUrlGroup(optional);
            case "math":
            case "text":
              return this.parseArgumentGroup(optional, type);
            case "hbox":
              return name = this.parseArgumentGroup(optional, "text"), null != name ? {type:"styling", mode:name.mode, body:[name], style:"text"} : null;
            case "raw":
              return name = this.parseStringGroup("raw", optional), null != name ? {type:"raw", mode:"text", string:name.text} : null;
            case "primitive":
              if (optional) {
                throw new src_ParseError("A primitive argument cannot be optional");
              }
              type = this.parseGroup(name);
              if (null == type) {
                throw new src_ParseError("Expected group as " + name, this.fetch());
              }
              return type;
            case "original":
            case null:
            case void 0:
              return this.parseArgumentGroup(optional);
            default:
              throw new src_ParseError("Unknown group type as " + name, this.fetch());
          }
        }
        consumeSpaces() {
          for (; " " === this.fetch().text;) {
            this.consume();
          }
        }
        parseStringGroup(modeName, optional) {
          modeName = this.gullet.scanArgument(optional);
          if (null == modeName) {
            return null;
          }
          optional = "";
          let nextToken;
          for (; "EOF" !== (nextToken = this.fetch()).text;) {
            optional += nextToken.text, this.consume();
          }
          this.consume();
          modeName.text = optional;
          return modeName;
        }
        parseRegexGroup(regex, modeName) {
          const firstToken = this.fetch();
          let lastToken = firstToken, str = "", nextToken;
          for (; "EOF" !== (nextToken = this.fetch()).text && regex.test(str + nextToken.text);) {
            lastToken = nextToken, str += lastToken.text, this.consume();
          }
          if ("" === str) {
            throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
          }
          return firstToken.range(lastToken, str);
        }
        parseColorGroup(optional) {
          optional = this.parseStringGroup("color", optional);
          if (null == optional) {
            return null;
          }
          const match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(optional.text);
          if (!match) {
            throw new src_ParseError("Invalid color: '" + optional.text + "'", optional);
          }
          optional = match[0];
          /^[0-9a-f]{6}$/i.test(optional) && (optional = "#" + optional);
          return {type:"color-token", mode:this.mode, color:optional};
        }
        parseSizeGroup(optional) {
          let res, isBlank = !1;
          this.gullet.consumeSpaces();
          res = optional || "{" === this.gullet.future().text ? this.parseStringGroup("size", optional) : this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
          if (!res) {
            return null;
          }
          optional || 0 !== res.text.length || (res.text = "0pt", isBlank = !0);
          optional = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
          if (!optional) {
            throw new src_ParseError("Invalid size: '" + res.text + "'", res);
          }
          optional = {number:+(optional[1] + optional[2]), unit:optional[3]};
          if (!validUnit(optional)) {
            throw new src_ParseError("Invalid unit: '" + optional.unit + "'", res);
          }
          return {type:"size", mode:this.mode, value:optional, isBlank};
        }
        parseUrlGroup(optional) {
          this.gullet.lexer.setCatcode("%", 13);
          this.gullet.lexer.setCatcode("~", 12);
          optional = this.parseStringGroup("url", optional);
          this.gullet.lexer.setCatcode("%", 14);
          this.gullet.lexer.setCatcode("~", 13);
          if (null == optional) {
            return null;
          }
          optional = optional.text.replace(/\\([#$%&~_^{}])/g, "$1");
          return {type:"url", mode:this.mode, url:optional};
        }
        parseArgumentGroup(optional, mode) {
          var argToken = this.gullet.scanArgument(optional);
          if (null == argToken) {
            return null;
          }
          optional = this.mode;
          mode && this.switchMode(mode);
          this.gullet.beginGroup();
          const expression = this.parseExpression(!1, "EOF");
          this.expect("EOF");
          this.gullet.endGroup();
          argToken = {type:"ordgroup", mode:this.mode, loc:argToken.loc, body:expression};
          mode && this.switchMode(optional);
          return argToken;
        }
        parseGroup(name, breakOnTokenText) {
          const firstToken = this.fetch(), text = firstToken.text;
          if ("{" === text || "\\begingroup" === text) {
            this.consume();
            name = "{" === text ? "}" : "\\endgroup";
            this.gullet.beginGroup();
            breakOnTokenText = this.parseExpression(!1, name);
            const lastToken = this.fetch();
            this.expect(name);
            this.gullet.endGroup();
            name = {type:"ordgroup", mode:this.mode, loc:SourceLocation.range(firstToken, lastToken), body:breakOnTokenText, semisimple:"\\begingroup" === text || void 0};
          } else {
            if (name = this.parseFunction(breakOnTokenText, name) || this.parseSymbol(), null == name && "\\" === text[0] && !implicitCommands.hasOwnProperty(text)) {
              if (this.settings.throwOnError) {
                throw new src_ParseError("Undefined control sequence: " + text, firstToken);
              }
              name = this.formatUnsupportedCmd(text);
              this.consume();
            }
          }
          return name;
        }
        formLigatures(group) {
          let n = group.length - 1;
          for (let i = 0; i < n; ++i) {
            const a = group[i], v = a.text;
            "-" === v && "-" === group[i + 1].text && (i + 1 < n && "-" === group[i + 2].text ? (group.splice(i, 3, {type:"textord", mode:"text", loc:SourceLocation.range(a, group[i + 2]), text:"---"}), n -= 2) : (group.splice(i, 2, {type:"textord", mode:"text", loc:SourceLocation.range(a, group[i + 1]), text:"--"}), --n));
            "'" !== v && "`" !== v || group[i + 1].text !== v || (group.splice(i, 2, {type:"textord", mode:"text", loc:SourceLocation.range(a, group[i + 1]), text:v + v}), --n);
          }
        }
        parseSymbol() {
          var nucleus = this.fetch(), text = nucleus.text;
          if (/^\\verb[^a-zA-Z]/.test(text)) {
            this.consume();
            nucleus = text.slice(5);
            var star = "*" === nucleus.charAt(0);
            star && (nucleus = nucleus.slice(1));
            if (2 > nucleus.length || nucleus.charAt(0) !== nucleus.slice(-1)) {
              throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
            }
            nucleus = nucleus.slice(1, -1);
            return {type:"verb", mode:"text", body:nucleus, star};
          }
          unicodeSymbols.hasOwnProperty(text[0]) && !src_symbols[this.mode][text[0]] && (this.settings.strict && "math" === this.mode && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text[0] + '" used in math mode', nucleus), text = unicodeSymbols[text[0]] + text.slice(1));
          if (star = combiningDiacriticalMarksEndRegex.exec(text)) {
            text = text.substring(0, star.index), "i" === text ? text = "ı" : "j" === text && (text = "ȷ");
          }
          if (src_symbols[this.mode][text]) {
            this.settings.strict && "math" === this.mode && 0 <= "ÐÞþ".indexOf(text) && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text[0] + '" used in math mode', nucleus);
            var group = src_symbols[this.mode][text].group, loc = SourceLocation.range(nucleus);
            text = ATOMS.hasOwnProperty(group) ? {type:"atom", mode:this.mode, family:group, loc, text} : {type:group, mode:this.mode, loc, text};
          } else if (128 <= text.charCodeAt(0)) {
            this.settings.strict && (supportedCodepoint(text.charCodeAt(0)) ? "math" === this.mode && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text[0] + '" used in math mode', nucleus) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text[0] + '" (' + (text.charCodeAt(0) + ")"), nucleus)), text = {type:"textord", mode:"text", loc:SourceLocation.range(nucleus), text};
          } else {
            return null;
          }
          this.consume();
          if (star) {
            for (group = 0; group < star[0].length; group++) {
              loc = star[0][group];
              if (!unicodeAccents[loc]) {
                throw new src_ParseError("Unknown accent ' " + loc + "'", nucleus);
              }
              const command = unicodeAccents[loc][this.mode] || unicodeAccents[loc].text;
              if (!command) {
                throw new src_ParseError("Accent " + loc + " unsupported in " + this.mode + " mode", nucleus);
              }
              text = {type:"accent", mode:this.mode, loc:SourceLocation.range(nucleus), label:command, isStretchy:!1, isShifty:!0, base:text};
            }
          }
          return text;
        }
      }
      Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "\x26"];
      var src_parseTree = function(toParse, settings) {
        if (!("string" === typeof toParse || toParse instanceof String)) {
          throw new TypeError("KaTeX can only parse string typed expression");
        }
        toParse = new Parser(toParse, settings);
        delete toParse.gullet.macros.current["\\df@tag"];
        let tree = toParse.parse();
        delete toParse.gullet.macros.current["\\current@color"];
        delete toParse.gullet.macros.current["\\color"];
        if (toParse.gullet.macros.get("\\df@tag")) {
          if (!settings.displayMode) {
            throw new src_ParseError("\\tag works only in display equations");
          }
          tree = [{type:"tag", mode:"text", body:tree, tag:toParse.subparse([new Token("\\df@tag")])}];
        }
        return tree;
      };
      let render = function(expression, baseNode, options) {
        baseNode.textContent = "";
        expression = renderToDomTree(expression, options).toNode();
        baseNode.appendChild(expression);
      };
      "undefined" !== typeof document && "CSS1Compat" !== document.compatMode && ("undefined" !== typeof console && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), render = function() {
        throw new src_ParseError("KaTeX doesn't work in quirks mode.");
      });
      const renderError = function(error, expression, options) {
        if (options.throwOnError || !(error instanceof src_ParseError)) {
          throw error;
        }
        expression = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
        expression.setAttribute("title", error.toString());
        expression.setAttribute("style", "color:" + options.errorColor);
        return expression;
      }, renderToDomTree = function(expression, options$jscomp$0) {
        options$jscomp$0 = new Settings(options$jscomp$0);
        try {
          {
            var tree = src_parseTree(expression, options$jscomp$0);
            const options = optionsFromSettings(options$jscomp$0);
            let katexNode;
            if ("mathml" === options$jscomp$0.output) {
              var JSCompiler_inline_result = buildMathML(tree, expression, options, options$jscomp$0.displayMode, !0);
            } else {
              if ("html" === options$jscomp$0.output) {
                const htmlNode = buildHTML(tree, options);
                katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
              } else {
                const mathMLNode = buildMathML(tree, expression, options, options$jscomp$0.displayMode, !1), htmlNode = buildHTML(tree, options);
                katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, htmlNode]);
              }
              JSCompiler_inline_result = displayWrap(katexNode, options$jscomp$0);
            }
          }
          return JSCompiler_inline_result;
        } catch (error) {
          return renderError(error, expression, options$jscomp$0);
        }
      };
      var katex_webpack = {version:"0.16.20", render, renderToString:function(expression, options) {
        return renderToDomTree(expression, options).toMarkup();
      }, ParseError:src_ParseError, SETTINGS_SCHEMA, __parse:function(expression, options) {
        options = new Settings(options);
        return src_parseTree(expression, options);
      }, __renderToDomTree:renderToDomTree, __renderToHTMLTree:function(expression, options$jscomp$0) {
        options$jscomp$0 = new Settings(options$jscomp$0);
        try {
          const tree = src_parseTree(expression, options$jscomp$0), options = optionsFromSettings(options$jscomp$0), htmlNode = buildHTML(tree, options), katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
          return displayWrap(katexNode, options$jscomp$0);
        } catch (error) {
          return renderError(error, expression, options$jscomp$0);
        }
      }, __setFontMetrics:function(fontName, metrics) {
        fontMetricsData[fontName] = metrics;
      }, __defineSymbol:defineSymbol, __defineFunction:defineFunction, __defineMacro:defineMacro, __domTree:{Span, Anchor, SymbolNode, SvgNode, PathNode, LineNode}};
      return __webpack_exports__ = __webpack_exports__["default"];
    }();
  });
};

//# sourceMappingURL=module$node_modules$katex$dist$katex.js.map
